<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机视觉课程笔记（7）</title>
      <link href="/2021/10/27/unsw/comp9517/ji-suan-ji-shi-jue-ke-cheng-bi-ji-7/"/>
      <url>/2021/10/27/unsw/comp9517/ji-suan-ji-shi-jue-ke-cheng-bi-ji-7/</url>
      
        <content type="html"><![CDATA[<h2 id="motion-动作"><a class="markdownIt-Anchor" href="#motion-动作"></a> Motion 动作</h2><p>将时间维度添加到图像形成中：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211027230842961.png" alt="image-20211027230842961"></p><p>图像序列的变化为</p><ul><li>检测正在移动的物体</li><li>计算运动物体的轨迹</li><li>对运动物体进行运动分析</li><li>根据物体的行为识别物体</li><li>计算观察者在世界中的运动</li><li>检测和识别场景中的活动</li></ul><h4 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h4><ul><li>动态的识别<ul><li>基于步态的人体识别，自动目标检测</li></ul></li><li>自动监测<ul><li>监控现场以发现可疑活动或不太可能发生的事件</li></ul></li><li>视频索引<ul><li>多媒体数据库中视频的自动标注和检索</li></ul></li><li>人机交互<ul><li>手势识别，眼睛注视跟踪数据输入电脑</li></ul></li><li>交通监控<ul><li>实时采集流量统计信息，引导流量</li></ul></li><li>车辆导航<ul><li>基于视频的路径规划和避障功能</li></ul></li></ul><h2 id="变化检测-change-detection"><a class="markdownIt-Anchor" href="#变化检测-change-detection"></a> 变化检测 Change Detection</h2><p>检测物体在恒定背景下移动</p><p>对象的前边缘和后边缘每帧只前进几个像素</p><p>通过从先前的图像<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">I_{t-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>中减去图像<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">I_{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，边缘应该是明显的，因为只有像素显著地不同于零</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> COMP9517 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉课程笔记（5）</title>
      <link href="/2021/10/25/unsw/comp9517/ji-suan-ji-shi-jue-ke-cheng-bi-ji-5/"/>
      <url>/2021/10/25/unsw/comp9517/ji-suan-ji-shi-jue-ke-cheng-bi-ji-5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>python skimage图像处理(三)<br><a href="https://www.jianshu.com/p/7693222523c0">https://www.jianshu.com/p/7693222523c0</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> COMP9517 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程决策结构（5）</title>
      <link href="/2021/10/25/unsw/gsoe9210/gong-cheng-jue-ce-jie-gou-5/"/>
      <url>/2021/10/25/unsw/gsoe9210/gong-cheng-jue-ce-jie-gou-5/</url>
      
        <content type="html"><![CDATA[<p>EMV</p><p><em><strong>Monotonic increasing function</strong></em> 单调递增函数</p><p><strong>Strictly increasing function</strong> 严格递增函数</p><p><strong>Certainty equivalent 确定性等价</strong></p><p><strong>Risk premium 风险溢价</strong></p><p><strong>Repeated trials 重复试验</strong></p><p><strong>Risk averse</strong></p><p><strong>Risk seeking</strong></p><p><strong>Risk neutral</strong></p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> GSOE9210 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络与深度学习（ass1）</title>
      <link href="/2021/10/18/unsw/comp9444/shen-jing-wang-luo-yu-shen-du-xue-xi-ass1/"/>
      <url>/2021/10/18/unsw/comp9444/shen-jing-wang-luo-yu-shen-du-xue-xi-ass1/</url>
      
        <content type="html"><![CDATA[<p>Due: Monday 25 October, 23:59 pm</p><p>在这篇作业中，你将执行和训练不同的神经网络模型来完成四项不同的任务，并分析结果。</p><p><a href="http://xn--Pythonkuzu-ji2pmmy6cb7af8b1z6prdgj45ptu4b.py">你需要提交三个Python文件kuzu.py</a>, <a href="http://frac.xn--pyencoder-rw9o.py">frac.py和encoder.py</a>，以及一份书面报告hw1.pdf (pdf格式)。</p><h2 id="第一部分日语字符识别"><a class="markdownIt-Anchor" href="#第一部分日语字符识别"></a> 第一部分：日语字符识别</h2><p>对于作业的第一部分，你们将实现识别手写平假名符号的网络。使用的数据集是Kuzushiji-MNIST或简称KMNIST。这篇论文值得一读。简而言之：1868年日本改革其教育制度时，日语发生了重大变化，如今大多数日本人无法阅读150多年前出版的文本。本文提供了一个手写的，标记的例子，这种旧式的脚本(库祖寺)。然而，除了这个数据集之外，它们还提供了一个简单得多的数据集，其中包含10个平假名字符，每个类有7000个样本。这是我们将要使用的数据集。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018224359338.png" alt="image-20211018224359338"></p><p>与1900年相比，1772年的文本(左)显示了日语书写的标准化。</p><ol><li>（1分）引入一个模型NetLin，它计算图像中像素的线性函数，然后是log softmax。运行代码输入:</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python3 kuzu_main.py --net lin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将最终的准确性和混淆矩阵复制到你的报告中。最终的准确度应该在70%左右。请注意，混淆矩阵的行表示目标字符，而列 <strong>columns</strong> 表示网络选择的字符。 (0=“o”, 1=“ki”, 2=“su”, 3=“tsu”, 4=“na”, 5=“ha”, 6=“ma”, 7=“ya”, 8=“re”, 9=“wo”)。</p><p>更多例子在<a href="http://codh.rois.ac.jp/kmnist/index.html.en">这里</a></p><ol start="2"><li>（1分）实现一个完全连接的2层网络NetFull(即一个隐藏层，加上输出层)，使用tanh在隐藏节点和日志softmax在输出节点。运行代码输入:</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python3 kuzu_main.py --net full<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为隐藏节点的数量尝试不同的值(10的倍数)，并尝试确定一个在测试集上达到较高准确性(至少84%)的值。将最终的准确性和混淆矩阵复制到你的报告中，并包括网络中独立参数的总数的计算。</p><ol start="3"><li>（1分）实现一个称为NetConv的卷积网络，有两个卷积层加上一个完全连接层，所有使用relu激活函数，然后是输出层，使用log softmax。你可以自由选择自己的数量、过滤器的大小，元参数值(学习率和动量)，以及是使用Max池还是完全卷积架构。运行代码输入:</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python3 kuzu_main.py --net conv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>经过10个训练阶段后，您的网络在测试集中应该始终保持至少93%的准确率。将最终的准确性和混淆矩阵复制到你的报告中，并包括网络中独立参数的总数的计算。</p><ol start="4"><li>（3分）简要讨论以下几点:</li></ol><p>a.三个模型的相对准确性</p><p>b.三个模型中每个独立参数的数量</p><p>c.每个模型的混淆矩阵：哪些字符最可能被误认为其他字符，为什么?</p><h2 id="第二部分分形分类任务"><a class="markdownIt-Anchor" href="#第二部分分形分类任务"></a> 第二部分：分形分类任务</h2><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018231855741.png" alt="image-20211018231855741"></p><p>在第2部分中，您将训练一个网络来区分上面所示的分形图案中的点。提供的代码frac_main.py从fractal.csv加载训练数据，应用指定的神经网络模型，并生成结果函数的图和数据。对于这个任务，没有很多测试集，但是我们通过绘制网络计算的函数并进行视觉评估来判断泛化。</p><ol><li><p>（1分）提供一个名为Full2Net的Pytorch模块的代码，它实现了一个3层完全连接的神经网络，其中有两个隐藏层，使用tanh激活，然后是一个节点和sigmoid激活的输出层。你的网络在每一层中应该有相同数量的隐藏节点，由变量hid指定。隐藏层激活(应用后(Tanh)应该储存在self中。hid1和self.hid2，这样之后就可以画出来了。</p></li><li><p>（1分）通过以下命令训练你的网络</p></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python3 frac_main.py --net full2 --hid ⟨hid⟩<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>尝试确定一个隐藏节点的数量，接近网络训练成功所需的最小值(尽管，它不需要是绝对最小值)。在找到一组允许网络收敛的初始权值之前，您可能需要多次运行网络。(如果它训练了几分钟，似乎卡在局部最小值中，则使用⟨cntrl⟩-c杀死它，并再次运行它)。您可以自由调整学习速率和初始权重大小。graph_output()方法将生成Network计算出的函数的图像，并将其存储在名为like的plot子目录中<br>out_full2_? . png。您应该在您的报告中包括这张图片，以及计算网络中独立参数的总数(基于您所选择的隐藏节点的数量)。</p><ol start="3"><li>（1分）为一个名为Full3Net的Pytorch模块提供代码，它实现了一个4层网络，与Full2Net相同，但有一个额外的隐藏层。所有三个隐藏层应该有相同数量的节点(hid)。隐层激活(应用tanh后)应存储到 self.hid1, self.hid2 和 self.hid3 中。</li><li>（1分）通过以下命令训练你的四层网络</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python3 frac_main.py --net full3 --hid ⟨hid⟩<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>尝试确定一个隐藏节点的数量，接近网络训练成功所需的最小值。记住，成本函数最初可能会下降，出现几个时期的停滞，但随后继续下降。graph_output()方法将生成一个图片的函数计算您的网络并将其存储在情节子目录的名字像out_full3_? . png,和graph_hidden()方法应该生成的所有隐藏在所有三个隐藏层节点,名字像 hid_full3_?_?_?.png。你应该在你的报告中包括输出的图形和所有三层中所有隐藏单元的图形，以及网络中独立参数的总数的计算。</p><ol start="5"><li>（2分）提供一个名为DenseNet的Pytorch模块的代码，它实现了一个3层紧密连接的神经网络。你的网络应该和Full2Net一样，除了它还应该包括从输入到第二层隐藏层和输出层的快捷连接，以及从第一层隐藏层到第二层隐藏层和输出层的快捷连接。每个隐藏层都应该有hid单位和tanh激活，输出节点应该有sigmoid激活。隐层激活(应用双氰后)应存储到 self.hid1 和  self.hid2 中。具体来说，隐藏的和输出的激活应该根据以下公式计算。(注意，在PyTorch中有多种实现这些方程的方法；例如，使用一个单独的nn。参数为每个偏差和权值矩阵，或将它们组合成神经网络。线性和利用torch.cat())。</li></ol><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018232640006.png" alt="image-20211018232640006"></p><ol start="6"><li>（1分）通过以下命令训练你的密集网络</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python3 frac_main.py --net dense --hid ⟨hid⟩<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如前所述，尝试确定一些隐藏节点，这些节点接近网络训练成功所需的最小值。你应该在你的报告中包括输出和所有隐藏节点的图形，以及网络中独立参数的总数的计算。</p><ol start="7"><li>（3分）简要讨论以下几点:</li></ol><p>a. 三个网络中每个独立参数的总数(使用由实验确定的隐藏节点的数量)和训练每种类型的网络所需的纪元的大致数量</p><p>b. 定性描述Full3Net和DenseNet的不同层所计算的函数</p><p>c. 三种网络计算的总体函数(即输出作为输入的函数)之间的性质差异(如果有的话)</p><h2 id="第三部分编码器网络"><a class="markdownIt-Anchor" href="#第三部分编码器网络"></a> 第三部分：编码器网络</h2><p>在第3部分中，您将编辑文件encoder.py来创建一个数据集，当与encoder_main.py一起运行时，该数据集将生成以下图像(这是中国大陆的风样式化地图)。</p><p>![image-20211018233003647](/Users/yinkejian/Library/Application Support/typora-user-images/image-20211018233003647.png)</p><p>首先运行代码</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python3 encoder_main.py --target star16<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，target是由encoder.py中的张量star16决定的，它有16行8列，表示有16个输入和8个输出。输入使用一次性编码，并使用torch.eye()以身份矩阵的形式生成。</p><ol><li>（2分）在file encoder.py中以张量ch34的形式手工创建一个数据集，当使用下面的命令运行时，将生成与上面所示基本相同的图像(但可能是旋转或反射的)。</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python3 encoder_main.py --target ch34<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>点和线的图案必须相同，除了可能的旋转或反射。特别要注意图形边角和边缘的五个“锚点”。</p><p>张量应该有34行23列。在报告中包含最终的图像，并在文件encoder.py中包含张量ch34</p><h2 id="第4部分循环网络的隐藏单元动力学"><a class="markdownIt-Anchor" href="#第4部分循环网络的隐藏单元动力学"></a> 第4部分：循环网络的隐藏单元动力学</h2><p>![image-20211018233234519](/Users/yinkejian/Library/Application Support/typora-user-images/image-20211018233234519.png)</p><p>在第4部分中，您将使用提供的代码seq_train.py和seq_plot.py来研究在语言预测任务上训练的循环网络的隐藏单元动态。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018233251696.png" alt="image-20211018233251696"></p><ol><li>（2分）在Reber语法预测任务中通过以下命令训练简单递归网络</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python3 seq_train.py --lang reber<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个SRN有7个输入，2个隐藏单元和7个输出。训练后的网络每10000个纪元存储在网络子目录中。训练结束后，通过输入绘制纪元50000处隐藏单元的激活情况</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python3 seq_plot.py --lang reber --epoch 50<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这些点应按颜色排列成可分辨的簇。如果不是，则再次运行代码，直到训练成功。隐藏的单位激活根据它们的“状态”打印，使用彩色地图“jet”:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018233411318.png" alt="image-20211018233411318"></p><p>根据这个彩色地图，在状态机中对应每个状态的点簇周围画一个圆圈，并在状态之间画箭头，每个箭头都用其对应的符号标记，从而注释您的图形(电子或打印输出上的笔)。在你的报告中包括带注释的数字。</p><ol start="2"><li>（1分）在<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018233516423.png" alt="image-20211018233516423">语言预测任务上通过以下命令训练SRN</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">python3 seq_train.py --lang anbn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018233516423.png" alt="image-20211018233516423">语言是随机数a和等量B的连接。SRN有2个输入，2个隐藏单元和2个输出。</p><p>随着训练的进行，观察A和B的预测概率。每个序列中的第一个B和第一个A之后的所有A都不是确定性的，只能在概率意义上预测。但是，如果训练成功了，所有其他符号都应该被正确地预测出来。特别是，网络应该预测每个序列的最后一个B以及随后的a。误差应该一致在0.01或0.02范围内。如果网络似乎已经成功地学习了任务，您可以使用⟨cntrl⟩-c在任何时候停止它。如果它似乎卡在局部最小值中，您可以停止它并再次运行代码，直到它成功为止。</p><p>训练结束后，通过以下命令绘制隐藏单元的激活图</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python3 seq_plot.py --lang anbn --epoch 100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在你的报告中包括结果数字。各州再次根据彩色地图“喷射”打印。然而，请注意，这些“状态”不是唯一的，而是用来计算我们已经看到的A的数量或我们仍然希望看到的B的数量。</p><ol start="3"><li><p>（2分）根据你在问题2中生成的图，简要说明网络是如何完成<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018233516423.png" alt="image-20211018233516423">预测任务的。具体来说，您应该描述隐藏单元激活如何随着字符串的处理而变化，以及它如何能够正确预测每个序列中的最后一个B以及下面的A。</p></li><li><p>（1分）在<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018233916417.png" alt="image-20211018233916417">语言预测任务上通过打字训练SRN</p></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python3 seq_train.py --lang anbncn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>SRN现在有3个输入，3个隐藏单位和3个输出。同样，“状态”是用来计数A和倒数B和C的。继续训练(如有必要，重新启动)，直到网络能够可靠地预测所有的C以及随后的A，并且误差始终在0.01或0.02的范围内。</p><p>训练结束后，通过输入绘制隐藏单元的激活图</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python3 seq_plot.py --lang anbncn --epoch 200<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在三维中旋转图形以获得隐藏单元空间中的点的一个或多个良好视图。</p><ol start="5"><li><p>（2分）根据你在问题4中生成的图，简要说明<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018233916417.png" alt="image-20211018233916417">预测任务是如何通过网络实现的。具体来说，您应该描述隐藏单元激活如何在字符串被处理时发生变化，以及它如何能够正确预测每个序列中的最后一个B以及所有的C和下面的A。</p></li><li><p>（4分）这个问题本来是要更有挑战性的。通过输入，训练LSTM网络来预测嵌入的Reber语法</p></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python3 seq_train.py --lang reber --embed True --model lstm --hid 4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果您愿意，您可以调整隐藏节点的数量。一旦训练成功，尝试分析LSTM的行为，并解释任务是如何完成的(这可能涉及修改代码，以便它返回和打印上下文单元以及隐藏单元)。</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> COMP9444 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络与深度学习（5）</title>
      <link href="/2021/10/18/unsw/comp9444/shen-jing-wang-luo-yu-shen-du-xue-xi-5/"/>
      <url>/2021/10/18/unsw/comp9444/shen-jing-wang-luo-yu-shen-du-xue-xi-5/</url>
      
        <content type="html"><![CDATA[<h2 id="总览"><a class="markdownIt-Anchor" href="#总览"></a> 总览</h2><p>本周，我们将探索神经网络在序列和语言处理中的应用。简单递归网络(SRN)可以被训练来识别或预测形式语言，我们可以分析它们隐藏的单元动力学。通过使用门控机制，长短期记忆(LSTM)和门控递归网络(GRU)能够学习比SRN更长的距离依赖关系。</p><h2 id="复发网络-recurrent-networks"><a class="markdownIt-Anchor" href="#复发网络-recurrent-networks"></a> 复发网络 Recurrent Networks</h2><h3 id="处理时间序列-processing-temporal-sequences"><a class="markdownIt-Anchor" href="#处理时间序列-processing-temporal-sequences"></a> 处理时间序列 Processing Temporal Sequences</h3><p>有许多任务的输出依赖于一系列输入，而不是单个输入。例如:</p><ul><li>语音识别 speech recognition</li><li>时间序列预测 time series prediction</li><li>机器翻译 machine translation</li><li>手写识别 handwriting recognition</li></ul><h3 id="nettalk滑动窗口方法-nettalk-sliding-window-approach"><a class="markdownIt-Anchor" href="#nettalk滑动窗口方法-nettalk-sliding-window-approach"></a> NetTalk滑动窗口方法 NetTalk sliding window approach</h3><p>它的输入由七个连续的字符组成，目的是输出一组指定中间字符正确发音的语音属性。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/vMGAVzG42PWOjYc4yQ7azwhF.jpeg" alt="img"></p><p>对于这7个输入字符中的每个字符，使用了一种一次性编码，使用29个单元(包括26个字母，加上标点和单词边界)，总共有203个输入。具有sigmoidal传递函数的隐藏单元有80个，26个输出编码21个发音特征以及重音和音节边界。</p><h3 id="简单的复发性网络srn-simple-recurrent-network"><a class="markdownIt-Anchor" href="#简单的复发性网络srn-simple-recurrent-network"></a> 简单的复发性网络(SRN) Simple Recurrent Network</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/OtGbYVvxrNlxk6z3gVGZhr2P.jpeg" alt="img"></p><p>简单递归网络(SRN)是Elman(1990)提出的。一个输入序列一次性输入到网络。在每个时间步，当前激活的隐藏层复制到一个“上下文”层。然后从当前输入和上下文层计算隐含层的新激活。因此，上下文层被用来“记住”网络需要的任何信息，以预测正确的输出。</p><p>基本的SRN可以通过直接从输入到输出的“捷径”连接，或从输出到隐藏层的连接(有时称为“乔丹网络”)来增强。</p><h3 id="通过时间反向传播-backpropagation-through-time"><a class="markdownIt-Anchor" href="#通过时间反向传播-backpropagation-through-time"></a> 通过时间反向传播 Backpropagation through time</h3><p>对于任何给定的输入序列，我们都可以将一个循环体系结构“展开”成一个具有共享权重的等价前馈体系结构。将反向传播应用到展开的体系结构称为时间上的反向传播。我们可以回溯到一个时间步，或者固定数量的时间步，或者一直回溯到序列的开始。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/kFliqBkm1vPl2HsPaGlREUih.png" alt="img"></p><h2 id="识别器和预测-recognizers-and-predictors"><a class="markdownIt-Anchor" href="#识别器和预测-recognizers-and-predictors"></a> 识别器和预测 Recognizers and Predictors</h2><p>二级网络或门控网络 Second Order Network or Gated Network</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/ss4MUZEJcORwv6EO4m4YzZ8D.jpeg" alt="img"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211020234706089.png" alt="image-20211020234706089"></p><h3 id="动力识别器-dynamical-recognizers"><a class="markdownIt-Anchor" href="#动力识别器-dynamical-recognizers"></a> 动力识别器 Dynamical Recognizers</h3><p>一种常见的序列处理任务是形式语言识别。网络每次扫描一个字符序列，然后必须输出1或0，以便分别将该序列分类为Accept或Reject。例如，考虑这组训练数据:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018213756136.png" alt="image-20211018213756136"></p><p>对这些数据的自然概括是将完全由1组成的字符串分类为Accept，将任何包含0的字符串分类为Reject。这个图显示了在这些数据上训练二阶网络的结果。交叉表示初始状态，而圆点表示网络处理一组随机生成的测试字符串时发生的所有隐藏状态。分隔线显示了字符串被分类为Accept的最终状态和被分类为Reject的最终状态之间的边界。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/cfmvuSjh2EPshoucLBy2Ox7e.png" alt="img"></p><p>在某些情况下，我们可以使用分析工具提取有限状态机，它可以精确地模拟网络的行为，如图所示。每个隐藏单元状态簇被转换为单个状态，簇之间的转换被转换为箭头，初始状态由一个没有来源的箭头表示。在分界线的接受一侧的状态用一个双圆表示；用一个圆圈圈住拒绝的。</p><p>下面是另一个例子，在这个例子中，网络学会拒绝任何包含三个连续0的字符串，并接受其他所有字符串。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018214113514.png" alt="image-20211018214113514"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/s4aXj85aMZUUb2npaorJpgSa.png" alt="img"></p><h3 id="非正则语言-non-regular-languages"><a class="markdownIt-Anchor" href="#非正则语言-non-regular-languages"></a> 非正则语言 Non-Regular languages</h3><p>可以用有限状态机描述的语言称为<strong>正则</strong>(<strong>Regular</strong>)语言。</p><p>一个非正规语言的简单例子是<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018214328634.png" alt="image-20211018214328634">，表示每个连续的a序列后面必须跟相同数量的连续b，如</p><p><em>abaabbabaaabbbaaaabbbbabaabbaaaaabbbbb . . .</em></p><p>具有2个输入、2个隐藏节点和2个输出的SRN可以被训练来预测<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018214328634.png" alt="image-20211018214328634">。在这种情况下，网络必须一次扫描一个输入字符序列，并在每一步尝试预测序列中的下一个字符。在某些情况下，预测是有概率的。对于<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018214328634-20211018214538014.png" alt="image-20211018214328634">任务，第一个b是不可预测的，但后续b和下一个子序列中的初始a是可预测的。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/ltlnUCwdnczEGY1fNW8MGD7w.jpeg" alt="img"></p><p>该网络没有实现有限状态机，而是利用激活空间中的两个不动点——一个吸引，另一个排斥。当它向有吸引力的不动点振荡时，网络有效地“计数”a，然后当它从有排斥的不动点振荡时，倒数相同数量的b。当在两个不动点上对循环映射进行线性化时，我们发现两个主要的特征值几乎是互相倒数的。有趣的是，网络只训练到<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018214734497.png" alt="image-20211018214734497">通常可以归纳为<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018214745256.png" alt="image-20211018214745256">。</p><p>用进化训练权值比用反向传播训练权值更稳定。经过进化训练的网络有时表现出单调的而不是振荡的轨迹。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/DkEv7YrsxVJ6kKDBbGcZ9Kt4.jpeg" alt="img"></p><h3 id="计数的螺旋式上升-counting-by-spiralling"><a class="markdownIt-Anchor" href="#计数的螺旋式上升-counting-by-spiralling"></a> 计数的螺旋式上升 Counting by spiralling</h3><p>SRN也可以训练识别平衡括号语言，将a当作左括号，将b当作右括号(Boden, 2003)。在这种情况下，线性化映射在不动点的特征值是复数，网络通过向内螺旋的方式计算a值，通过向外螺旋的方式计算b值。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/0ZuKWMbUhviPiva5gR6O7gfM.jpeg" alt="img"></p><h2 id="隐单元动力学-hidden-unit-dynamics-for-image-20211018215054090"><a class="markdownIt-Anchor" href="#隐单元动力学-hidden-unit-dynamics-for-image-20211018215054090"></a> 隐单元动力学 <img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018215054090.png" alt=""> Hidden unit dynamics for <img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018215054090.png" alt="image-20211018215054090"></h2><p>一个有三个输入、三个隐藏单元和三个输出的SRN可以用来学习语言<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018215132594.png" alt="image-20211018215132594">，被归类为轻度上下文敏感。这个网络在一个方向上计数，同时在另一个方向上计数，从而产生一个星形图案。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/QJkPsHkOJ2xKiZfZhdCWEb1f.jpeg" alt="img"></p><p>用简单语言分析网络动态具有启发性。但是，最终，SRN在它们能够学习的依赖范围内是有限的，原因类似于我们在第2周前馈网络环境中讨论的消失梯度问题。在下一节中，我们将介绍长短期记忆，它能够学习更长的依赖关系，并结合单词向量、注意力和其他增强功能，能够执行严重的现实世界任务，如多语言翻译。</p><h2 id="长短期记忆lstm-long-short-term-memory"><a class="markdownIt-Anchor" href="#长短期记忆lstm-long-short-term-memory"></a> 长短期记忆(LSTM) Long Short Term Memory</h2><p>简单递归网络(SRNs)可以学习中等距离的依赖关系，但很难学习长距离的依赖关系。长短期记忆(LSTM)能够通过遗忘、输入和输出门的组合来学习长期依赖关系。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/EH9dQCfsCQJYONPnwb6mtaKK.jpeg" alt="img"></p><p>LSTM维护一个<strong>上下文context</strong>层，它与<strong>隐藏层hidden</strong>不同，但包含相同数量的单元。LSTM在每个时间步长的完整工作由以下方程描述：</p><p>Gates:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018215959369.png" alt="image-20211018215959369"></p><p>候选人激活 Candidate Activation:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018220029031.png" alt="image-20211018220029031"></p><p>State:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018220044558.png" alt="image-20211018220044558"></p><p>Output:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018220059055.png" alt="image-20211018220059055"></p><p>首先，<strong>遗忘forget</strong>门(f)被用来确定，对于每个上下文单元，0和1之间的比率，这个上下文单元的值将乘以这个比率。如果比值接近于零，则对应上下文单元的先前值将在很大程度上被遗忘；如果它接近1，那么之前的值将大部分保留。</p><p>接下来，使用tanh计算−1和+1之间的<strong>更新update</strong>值(g)，并使用<strong>输入input</strong>门(i)来确定这些更新值在被添加到当前上下文值之前所乘的比率。</p><p>最后，<strong>输出output</strong>门(o)被计算并用于确定上下文单位值的tanh乘以的比率，以产生下一个<strong>隐藏hidden</strong>的单位值。</p><p>通过这种方式，上下文单元能够专门化，其中一些经常改变它们的值，而另一些则在许多时间步骤中保持它们的状态，直到特殊情况导致大门被“打开”，并允许这些单位的值发生变化。</p><h3 id="嵌入式reber语法-embedded-reber-grammar"><a class="markdownIt-Anchor" href="#嵌入式reber语法-embedded-reber-grammar"></a> 嵌入式Reber语法 Embedded Reber Grammar</h3><p>不同的序列处理算法学习长期依赖关系的能力可以使用雷柏语法和嵌入式雷柏语法来探索。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/ZHbO0G6aU8pT7MkThdOrwgHw.png" alt="img"></p><p><strong>Reber Grammar</strong> (RG)由左边所示的有限状态机定义。当在两个转变之间有选择时，它们被理解为被选择的概率相等。嵌入的Reber语法(ERG)显示在右边，每个标记为“Reber语法”的框包含在左边的有限状态机的相同副本。困难在学习ERG是网络必须记住过渡(T和P)发生在最初的B，并保留这些信息处理与RG相关联的转换时的两个相同的盒子，为了正确地预测T和P发生前最后的E。</p><p>在本周的练习中，你们将演示SRN能够学习RG，但学习ERG却很困难，而LSTM也可以学习ERG。我们可以想象其中一个上下文单元以某种方式被分配了保留关于初始T或P的知识的任务，而这些知识分别通过遗忘门和输入输出门的适当的高值和低值被保留了下来。</p><h3 id="封闭的复发性单元-gated-recurrent-unit"><a class="markdownIt-Anchor" href="#封闭的复发性单元-gated-recurrent-unit"></a> 封闭的复发性单元 Gated Recurrent Unit</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/XLXmfmoAsnwF8clJh7nTdOI9.jpeg" alt="img"></p><p>门控循环单元(GRU)与LSTM类似，但只有两个门而不是三个。其更新方程如下：</p><p>Gates:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018220712136.png" alt="image-20211018220712136"></p><p>候选人激活:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018220734617.png" alt="image-20211018220734617"></p><p>Output:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018220835225.png" alt="image-20211018220835225"></p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><h4 id="question-1"><a class="markdownIt-Anchor" href="#question-1"></a> Question 1</h4><p>问：解释向NetTalk系统提供输入的格式和方法，以及目标输出</p><p>答：字符是使用滑动窗口的方法提供给NetTalk的。在一个7个单词的窗口中，字符被编码为1热编码，以形成大小为7×29的输入。该网络有26个输出，每个输出对应音标字母表中的一个字母。目标输出是输入中中心字符的正确发音。</p><h4 id="question-2"><a class="markdownIt-Anchor" href="#question-2"></a> Question 2</h4><p>问：解释上下文层在Elman网络中的作用。</p><p>答：上下文层是前一个时间步的隐藏层的副本。隐藏层接受来自隐藏层和上下文层的连接。这在理论上允许网络无限期地保留“状态”信息。</p><h4 id="question-3"><a class="markdownIt-Anchor" href="#question-3"></a> Question 3</h4><p>画一个LSTM的图，写出它的运算方程。</p><p>答：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/EH9dQCfsCQJYONPnwb6mtaKK-20211018221348584.jpeg" alt="img"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018221406804.png" alt="image-20211018221406804"></p><h4 id="question-4"><a class="markdownIt-Anchor" href="#question-4"></a> Question 4</h4><p>画一个门控循环单元Gated Recurrent Unit的图，并写出它的运行方程。</p><p>答：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/XLXmfmoAsnwF8clJh7nTdOI9-20211018221518877.jpeg" alt="img"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018221752890.png" alt="image-20211018221752890"></p><blockquote><p>理解 LSTM 网络 <a href="https://www.jianshu.com/p/9dc9f41f0b29">https://www.jianshu.com/p/9dc9f41f0b29</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> COMP9444 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络与深度学习（4）</title>
      <link href="/2021/10/17/unsw/comp9444/shen-jing-wang-luo-yu-shen-du-xue-xi-4/"/>
      <url>/2021/10/17/unsw/comp9444/shen-jing-wang-luo-yu-shen-du-xue-xi-4/</url>
      
        <content type="html"><![CDATA[<p><em><strong>convolutional neural networks</strong></em> 卷积神经网络</p><p><em><strong>progressively deeper networks</strong></em>  逐步深入网络</p><p><em><strong>backpropagation</strong></em> n. 反向传播</p><p><em><strong>weight initialisation, batch normalisation, residual networks and dense networks</strong></em> 权值初始化、批处理归一化、残差网络和密集网络</p><h2 id="综述"><a class="markdownIt-Anchor" href="#综述"></a> 综述</h2><p>本节课我们将研究一个典型PyTorch程序的基本结构和组件，并运行一些简单的示例。我们还将学习如何分析神经网络的隐藏单元动力学。</p><h2 id="图像分类image-classification"><a class="markdownIt-Anchor" href="#图像分类image-classification"></a> 图像分类(Image Classification)</h2><p>最常用的三种图像分类数据集是MNIST、CIFAR-10和ImageNet</p><h3 id="mnist-数据集mnist-dataset"><a class="markdownIt-Anchor" href="#mnist-数据集mnist-dataset"></a> MNIST 数据集(MNIST Dataset)</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/2muVvYRiH2vXb7Xx8BIbGPIN.png" alt="img"></p><p>MNIST手写数字数据集于1998年发布，由50,000张训练图像和10,000张测试图像组成。这些图像是黑白的，分辨率为28×28像素。</p><h3 id="cifar-10数据集cifar-10-dataset"><a class="markdownIt-Anchor" href="#cifar-10数据集cifar-10-dataset"></a> CIFAR-10数据集(CIFAR-10 Dataset)</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/azHBaeiQlMkMmcSUFVhokEwr.png" alt="img"></p><p>CIFAR-10数据集于2009年推出，由10个不同类别的6万张分辨率为32times×32的彩色图像组成。</p><h3 id="imagenet-数据集imagenet-dataset"><a class="markdownIt-Anchor" href="#imagenet-数据集imagenet-dataset"></a> ImageNet 数据集(ImageNet Dataset)</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/JTHGgHNmXsjeZhstVEAw8HXN.jpeg" alt="img"></p><p>ImageNet数据集由1000个不同类别的120万张图像组成，并成为ImageNet LSVRC竞赛的基础。</p><p>2012年，利用名为AlexNet的8层卷积神经网络，ImageNet数据集在预测准确性方面取得了重大进展。随后的增强允许更深入的网络被训练，并达到更高的准确性。</p><h2 id="卷积网络-convolutional-networks"><a class="markdownIt-Anchor" href="#卷积网络-convolutional-networks"></a> 卷积网络 Convolutional Networks</h2><p><strong>卷积层</strong>(<strong>convolutional layer</strong>): 对图像的不同部分应用相同的权重。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/ef1gGb1c6OQtztA5qzx3poFc.png" alt="img"></p><p>卷积神经网络一般由以下几部分组成:</p><p><strong>卷积层 convolutional</strong> <strong>layers</strong>:从前一层提取平移不变特征</p><p><strong>子采样或池化层 subsampling or pooling layers</strong>:将前一层多个单元的激活合并为一个单元</p><p><strong>全连接层 fully connected</strong> <strong>layers</strong>:收集空间扩散信息</p><p><strong>输出层 output layer</strong>:在类之间选择</p><h4 id="视觉皮层-visual-cortex"><a class="markdownIt-Anchor" href="#视觉皮层-visual-cortex"></a> 视觉皮层 Visual cortex</h4><h2 id="卷积的细节convolution-in-detail"><a class="markdownIt-Anchor" href="#卷积的细节convolution-in-detail"></a> 卷积的细节(Convolution in Detail)</h2><h3 id="卷积运算符convolution-operator"><a class="markdownIt-Anchor" href="#卷积运算符convolution-operator"></a> 卷积运算符(Convolution operator)</h3><p><strong>连续卷积(Continuous convolution)</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211017230304461.png" alt="image-20211017230304461"></p><p><strong>离散卷积(Discrete convolution)</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211017230339521.png" alt="image-20211017230339521"></p><p><strong>二维卷积(Two-dimensional convolution)</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211017230408592.png" alt="image-20211017230408592"></p><h3 id="卷积网络层convolutional-network-layer"><a class="markdownIt-Anchor" href="#卷积网络层convolutional-network-layer"></a> 卷积网络层(Convolutional Network Layer)</h3><p>图像高度J×图像宽度K，图层数L，过滤器尺寸M×N</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/k4aKsVYKnmSbeILl1E4kYSQt.png" alt="img"></p><p><em>J</em>=6,<em>K</em>=7,<em>L</em>=3,<em>M</em>=3,<em>N</em>=3</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211017231015204.png" alt="image-20211017231015204"></p><p>自由参数(free parameters)个数为: F × (1 + L × M × N)，其中，F是这一层滤波器的数量。</p><p><strong>褶积层 convolution layer</strong> 尺寸为 (<em>J</em>+1−<em>M</em>)×(<em>K</em>+1−<em>N</em>)</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211017231322766.png" alt="image-20211017231322766"></p><h3 id="池和填充-pooling-and-padding"><a class="markdownIt-Anchor" href="#池和填充-pooling-and-padding"></a> 池和填充 Pooling and Padding</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/ef1gGb1c6OQtztA5qzx3poFc-20211017231356927.png" alt="img"></p><h4 id="最大池-max-pooling"><a class="markdownIt-Anchor" href="#最大池-max-pooling"></a> 最大池 Max Pooling</h4><p>子抽样的一种常见形式是最大池化。前一层被划分为小组单元(通常是在2×2网格中)，每个小组单元之间的最大激活被复制到随后层中的单个单元。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/QET9VLGN5Vquhz6K4apbLC4J.png" alt="img"></p><h4 id="补零-zero-padding"><a class="markdownIt-Anchor" href="#补零-zero-padding"></a> 补零 Zero Padding</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/Yl8uqo7XUrlwgjahjT36MiAX.png" alt="img"></p><h2 id="步幅和数据增强-stride-and-data-augmentation"><a class="markdownIt-Anchor" href="#步幅和数据增强-stride-and-data-augmentation"></a> 步幅和数据增强 Stride and Data Augmentation</h2><p>数据增强是指使用领域知识从最初提供的训练项目中生成额外的训练项目。</p><p>例子：AlexNet</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/ZAy1JlxKMOUiSOstZ2UzvaGy.png" alt="img"></p><ul><li><p>5个卷积层加上3个完全连接层</p></li><li><p>在输出层应用1000类的Softmax</p></li><li><p>两个gpu，它们只在特定的层上进行交互</p></li><li><p>大跨步汇集3×3社区</p></li><li><p>在完全连接的层有50%的跌落</p></li><li><p>通过随机裁剪以及在RGB空间上变换的数据增强</p></li></ul><p>在AlexNet中，每个原始图像都以不同的方式随机裁剪，以创建224×224大小的图像。图像也可以从左到右反射，并可以对图像的RGB通道进行更改。</p><h3 id="跨度-stride"><a class="markdownIt-Anchor" href="#跨度-stride"></a> 跨度 Stride</h3><p>设 <strong>stride</strong> of s &gt; 1</p><p>如，<em>J</em>=7,<em>K</em>=9,<em>L</em>=3,<em>M</em>=3,<em>N</em>=3,<em>s</em>=2</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/LEkFHjmTpLMEL6GAggCbqsif.png" alt="img"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211017231922865.png" alt="image-20211017231922865"></p><p>每个过滤器的自由参数的数量为 1+<em>L</em>×<em>M</em>×<em>N</em></p><h3 id="跨维度-stride-dimensions"><a class="markdownIt-Anchor" href="#跨维度-stride-dimensions"></a> 跨维度 Stride Dimensions</h3><p>j的取值为 0,<em>s</em>,2<em>s</em>,…,(<em>J</em>−<em>M</em>).</p><p>k的取值为 0,<em>s</em>,2<em>s</em>,…,(<em>K</em>−<em>N</em>).</p><p>下一层是 (1+(<em>J</em>−<em>M</em>)/<em>s</em>) by (1+(K−N)/s)(1+(<em>K</em>−<em>N</em>)/<em>s</em>)</p><h4 id="带有零填充的步幅"><a class="markdownIt-Anchor" href="#带有零填充的步幅"></a> 带有零填充的步幅</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/yj21hHxbbbgYA5ZEpFqs8spm.png" alt="img"></p><p>与宽度P的零填充相结合时，</p><p><em>j</em> 取值为 0, s,2s, . . . , (J+2P−M)0,<em>s</em>,2<em>s</em>,…,(<em>J</em>+2<em>P</em>−<em>M</em>).</p><p>k 取值为 0, s,2s, . . . , (K+2P−N)0,<em>s</em>,2<em>s</em>,…,(<em>K</em>+2<em>P</em>−<em>N</em>)</p><p>下一层的尺寸是 (1+(<em>J</em>+2<em>P</em>−<em>M</em>)/<em>s</em>) by (1+(K+2P−N)/s)</p><h3 id="例如alexnet-conv-layer-1"><a class="markdownIt-Anchor" href="#例如alexnet-conv-layer-1"></a> 例如：AlexNet Conv Layer 1</h3><p>J = K = 224, P = 2, M = N = 11, s = 4. 下一层的宽度为:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211017232605360.png" alt="image-20211017232605360"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211017232720341.png" alt="image-20211017232720341"></p><h3 id="重叠的池-overlapping-pooling"><a class="markdownIt-Anchor" href="#重叠的池-overlapping-pooling"></a> 重叠的池 Overlapping Pooling</h3><p>如果前一层为J ×K，应用max pooling, 宽度 F, 跨度 s，则下一层的尺寸为:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211017232901824.png" alt="image-20211017232901824"></p><h4 id="卷积过滤器-convolutional-filters"><a class="markdownIt-Anchor" href="#卷积过滤器-convolutional-filters"></a> 卷积过滤器 Convolutional Filters</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/jTzOm6iay2Uryn8a8MIgZ2DX.jpeg" alt="img"></p><h2 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h2><p>如果 <em>J</em>=<em>K</em>=84,<em>L</em>=4,<em>M</em>=<em>N</em>=8,<em>P</em>=0,<em>s</em>=4，那么</p><p><strong>第一次卷积层</strong>：</p><ol><li>重量过滤器WF weights per filter = 1 + M × N × L = 1 + 8 × 8 × 4=257</li><li>宽度W高度H width and height = 1 + ( J - M ) / s = 1 + ( 84 - 8 ) / 4 = 20</li><li>神经元数量NN number of neurons = W × H × L × s = 20 × 20 × 16 = 6400</li><li>连接数CO connections = W × H × L × s × WF = NN × WF = 20 × 20 × 16 × 257 = 1644800</li><li>独立参数IP independent parameters = L × s × WF = 16 × 257 = 4112</li></ol><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211017233513855.png" alt="image-20211017233513855"></p><p><strong>第二个卷积层</strong>：</p><p><em>J</em>2=<em>K2</em>=20,<em>L2</em>=16,<em>M</em>2=<em>N2</em>=4,<em>P</em>=0,<em>s2</em>=2</p><ol><li>重量过滤器WF2 weights per filter = 1 + M2 × N2 × L2 = 1 + 4 × 4 × 16=257</li><li>宽度W2和高度H2 width and height = 1+ ( J2 - M2 ) / s2 = 1+ (20 - 4 ) / 2 = 9</li><li>神经元数量NN2 number of neurons = W2 × H2 × L2 × s2 = 9 × 9 × 32 = 2592</li><li>连接数CO2 connections = W2 × H2 × L2 × s2 × WF2 = 9 × 9 × 32 × 257 = 666144</li><li>独立参数IP2 independent parameters = L2 × s2 × WF2 = 32 × 257= 8224</li></ol><p><strong>完全连接层 fully connected layer</strong></p><ol><li>重量过滤器WFF weights per filter = 1 + NN2 = 1 + 2592 = 2593</li><li>宽度和高度 width and height (not applicable)</li><li>神经元数量NNF number of neurons = M2 × N2 × L2 = 256</li><li>连接数COF connections = NNF × WFF = 256 × 2593=663808</li><li>独立参数 independent parameters = NNF × WFF = 663808</li></ol><p><strong>输出层  the output layer</strong></p><ol><li>重量过滤器WFO weights per filter = 1 + NNF = 1+256 = 257</li><li>宽度和高度 width and height (not applicable)</li><li>神经元数量NNO number of neurons = ? =18</li><li>连接数 connections = NNO × WFO = 18 × 257 = 4626</li><li>独立参数 independent parameters = NNO × WFO = 4626</li></ol><p><strong>结果卷积层 resulting convolutional layer</strong></p><p>对于<em>J</em>=<em>K</em>,<em>L</em>=?,<em>M</em>=<em>N</em>,<em>P</em>=0,<em>s</em>，有</p><p>大小：( 1 + (  J+2P − M ) / s ) × ( 1 + ( K + 2P − N ) / s )</p><p><strong>结果(downsampled)层</strong></p><p>max pooling with filter size F<br>( 1 + ( J − F ) / s ) × ( 1 + ( K − F ) / s )</p><h2 id="各激活函数图形"><a class="markdownIt-Anchor" href="#各激活函数图形"></a> 各激活函数图形</h2><p>Sigmoid:</p><p>![image-20211018111108564](/Users/yinkejian/Library/Application Support/typora-user-images/image-20211018111108564.png)</p><p>Tanh:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018111133170.png" alt="image-20211018111133170"></p><p>ReLU:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018111145031.png" alt="image-20211018111145031"></p><h2 id="权重初始化-weight-initialization"><a class="markdownIt-Anchor" href="#权重初始化-weight-initialization"></a> 权重初始化 Weight Initialization</h2><p>权值初始化的目的是在深度神经网络的每一层中选择初始权值的大小，使梯度保持在一个健康的范围内，而不是消失(vanish)或爆炸(explode)。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018162028877.png" alt="image-20211018162028877"></p><p>其中，g()是传递函数</p><p>回顾<strong>均值(mean)</strong> 和**方差(variance)**的定义</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018162447080.png" alt="image-20211018162447080"></p><p>所以，如果<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018162802310.png" alt="image-20211018162802310">，那么<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018162822589.png" alt="image-20211018162822589"></p><p><em><strong>独立的，同分布的 independent and identically distributed (i.i.d.)</strong></em></p><p>更一般地，如果<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018162957127.png" alt="image-20211018162957127">，<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018163019154.png" alt="image-20211018163019154">，那么<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018163107521.png" alt="image-20211018163107521"></p><h2 id="统计例子抛硬币"><a class="markdownIt-Anchor" href="#统计例子抛硬币"></a> 统计例子:抛硬币</h2><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018163801875.png" alt="image-20211018163801875"></p><p>如果投掷100次，那么 <em>μ</em>=100×0.5=50 ，σ^2=100 × 0.25 = 25</p><p>如果投掷10000次，那么 <em>μ</em>=10000×0.5=5000 ，σ^2=10000 × 0.25 = 2500</p><p>我们更关注<strong>标准偏差standard deviation</strong>，n=1/100//10000时，σ=0.5/5/50</p><h3 id="权重初始化-weight-initialisation"><a class="markdownIt-Anchor" href="#权重初始化-weight-initialisation"></a> 权重初始化 Weight Initialisation</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018164408104.png" alt="image-20211018164408104"></p><p>其中G0是一个常数，其值的估计考虑到传递函数。</p><p>将所有D层从输入x=x(1)乘到输出z=x (D+1)，得到</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018164552141.png" alt="image-20211018164552141"></p><p>当我们通过反向传播应用梯度下降时，微分将遵循类似的模式:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018164614149.png" alt="image-20211018164614149"></p><p>为了让乘积中的所有项都近似等于1，对于传递函数tanh()，使用<strong>xavier</strong>初始化：</p><p>![image-20211018164833867](/Users/yinkejian/Library/Application Support/typora-user-images/image-20211018164833867.png)</p><p>对于整流线性单元(ReLU)，上述分析基本上仍然有效，有<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018165030004.png" alt="image-20211018165030004">，使用 <strong>kaiming</strong>初始化，权重是从均值为0和标准差的高斯分布中选择的。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018165148154.png" alt="image-20211018165148154"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018165216568.png" alt="image-20211018165216568"></p><p>左图是22-层 ReLU 网络 ，Var[<em>w</em>]=<em>2/n</em> converges faster than Var[<em>w</em>]=1/n</p><p>右图是30-层 ReLU 网络 ，Var[<em>w</em>]=<em>2/n</em> is successful 当 Var[<em>w</em>]=<em>1/n</em> fails to learn at all.</p><h3 id="批量归一化-batch-normalization"><a class="markdownIt-Anchor" href="#批量归一化-batch-normalization"></a> 批量归一化 Batch Normalization</h3><p>批量归一化与权重初始化的目的相似，但它适用于整个培训过程，而不仅仅是在开始。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018165700104.png" alt="image-20211018165700104"></p><p>然后这些激活可以被移动和重新缩放，以具有平均值mean<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018165801759.png" alt="image-20211018165801759">和标准偏差<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018165821689.png" alt=""><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018165744918.png" alt="image-20211018165744918"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018165821689.png" alt="image-20211018165821689"></p><h2 id="残差网络和密集网络-resnets-and-densenets"><a class="markdownIt-Anchor" href="#残差网络和密集网络-resnets-and-densenets"></a> 残差网络和密集网络 ResNets and DenseNets</h2><h3 id="残差网络-residual-networks"><a class="markdownIt-Anchor" href="#残差网络-residual-networks"></a> 残差网络 Residual Networks</h3><p>通过引入跳跃连接形成残差网络，可以成功训练深度网络(大于30层)。这个想法是在一个深度网络中取任意两个连续的堆叠层，并添加一个“跳过”连接，绕过这些层并添加到它们的输出中。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018170147416.png" alt="image-20211018170147416"></p><p>通过这种方式，前一层试图做“整体”工作，使x尽可能接近整个网络的目标输出。F(x)是一个残差分量，用于修正前一层的错误，或提供前一层不够强大而无法计算的额外细节。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018170244455.png" alt="image-20211018170244455"></p><h3 id="密集网络-dense-networks"><a class="markdownIt-Anchor" href="#密集网络-dense-networks"></a> 密集网络 Dense Networks</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018170357029.png" alt="image-20211018170357029"></p><p>在ImageNet上，使用紧密连接的块的网络也取得了良好的效果。在每个块内，每一层都通过快捷连接到所有前面的层。</p><h2 id="神经风格转移-neural-style-transfer"><a class="markdownIt-Anchor" href="#神经风格转移-neural-style-transfer"></a> 神经风格转移 Neural Style Transfer</h2><p>卷积神经网络可以用于除目标分类以外的许多任务。其中一个任务是神经风格转换(Neural Style Transfer, Gatys, 2016)，其目的是将一幅图像的内容与另一幅图像的风格相结合，如图所示。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018170933363.png" alt="image-20211018170933363"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018171245915.png" alt="image-20211018171245915"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018171254735.png" alt="image-20211018171254735"></p><p>注意，在这种情况下，梯度下降不是应用于网络的权值(保持固定)，而是应用于图像本身像素的R,G,B值。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018171457486.png" alt="image-20211018171457486"></p><h2 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h2><h4 id="question-1"><a class="markdownIt-Anchor" href="#question-1"></a> Question 1</h4><p>描述梯度消失和爆炸的问题，以及权重初始化如何帮助防止它。</p><p>Explain the problem of vanishing and exploding gradients, and how Weight Initialization can help to prevent it.</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018171724954.png" alt="image-20211018171724954"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018172016107.png" alt="image-20211018172016107"></p><h4 id="question-2"><a class="markdownIt-Anchor" href="#question-2"></a> Question 2</h4><p>描述批处理规范化算法。Describe the Batch Normalization algorithm.</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211018171955496.png" alt="image-20211018171955496"></p><h4 id="question-3"><a class="markdownIt-Anchor" href="#question-3"></a> Question 3</h4><p>解释残余网络和密集网络的区别。</p><p>残余网络包括绕过每对连续层的“跳过”连接。因此，这些中间层计算一个残余分量，它被添加到前一层的输出中并纠正它们的错误，或者提供它们不够强大而无法计算的额外细节。</p><p>一个密集网络由紧密连接的块组成，由卷积和池层分隔。在一个密集的块内，每一层都通过快捷连接到前面的所有层。</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> COMP9444 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy使用手册</title>
      <link href="/2021/10/14/ji-zhu-xue-xi/ai/numpy-shi-yong-shou-ce/"/>
      <url>/2021/10/14/ji-zhu-xue-xi/ai/numpy-shi-yong-shou-ce/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as np# 定义 2 行 3 列，全0数组a = np.zeros((2,5)) # 修改某一个元素a[1][2] = 1a[0][4] = 10print(a)# 修改一行或多行元素a[[0,1,3],2] = 1 print(a)# 修改一列或多列元素a = np.zeros((4,10))a[1,[2,3,4,5,6,7,8]] = 100# 使用切片赋值a[1:3,2:8] = 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>本文参考链接</strong></p><p>numpy之数组的赋值<br><a href="https://blog.csdn.net/PJCKR/article/details/95453642">https://blog.csdn.net/PJCKR/article/details/95453642</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持续更新 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络与深度学习（3）</title>
      <link href="/2021/10/14/unsw/comp9444/shen-jing-wang-luo-yu-shen-du-xue-xi-3/"/>
      <url>/2021/10/14/unsw/comp9444/shen-jing-wang-luo-yu-shen-du-xue-xi-3/</url>
      
        <content type="html"><![CDATA[<h2 id="综述"><a class="markdownIt-Anchor" href="#综述"></a> 综述</h2><p>本节课我们将研究一个典型PyTorch程序的基本结构和组件，并运行一些简单的示例。我们还将学习如何分析神经网络的隐藏单元动力学。</p><h2 id="pytorch"><a class="markdownIt-Anchor" href="#pytorch"></a> PyTorch</h2><p><strong>典型的PyTorch结构为</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># create neural network according to model specificationnet = MyModel().to(device) # CPU or GPU# prepare to load the training and test datatrain_loader = torch.utils.data.DataLoader(...)test_loader = torch.utils.data.DataLoader(...)# choose between SGD, Adam or other optimizeroptimizer = torch.optim.SGD(net.parameters,...)# enter the training loopfor epoch in range(1, epochs):    train(params, net, device, train_loader, optimizer)    # periodically evaluate the network on the test data    if epoch % 10 == 0:        test(params, net, device, test_loader)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>定义模型</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class MyModel(torch.nn.Module):    def __init__(self):        super(MyModel, self).__init__()        # define structure of the network here    def forward(self, input):        # apply network and return output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>自定义模型</strong></p><p>这段代码定义了一个模块，用于计算表单函数<img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211014194324098.png" alt="image-20211014194324098"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import torch.nn as nnclass MyModel(nn.Module):    def __init__(self):        super(MyModel, self).__init__()        self.A = nn.Parameter(torch.randn((1),requires_grad=True))        self.B = nn.Parameter(torch.randn((1),requires_grad=True))    def forward(self, input):        output = self.A * input[:,0] * torch.log(input[:,1]) \               + self.B * input[:,1] * input[:,1]        return output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>从单个组件构建网络</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class MyModel(torch.nn.Module):    def __init__(self):        super(MyModel, self).__init__()        self.in_to_hid = torch.nn.Linear(2,2)        self.hid_to_out = torch.nn.Linear(2,1)    def forward(self, input):        hid_sum = self.in_to_hid(input)        hidden = torch.tanh(hid_sum)        out_sum = self.hid_to_out(hidden)        output = torch.sigmoid(out_sum)        return output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>定义顺序网络</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class MyModel(torch.nn.Module):    def __init__(self, num_input, num_hid, num_out):        super(MyModel, self).__init__()        self.main = nn.Sequential(            nn.Linear(num_input, num_hid),            nn.Tanh(),            nn.Linear(num_hid, num_out),            nn.Sigmoid()        )    def forward(self, input):        output = self.main(input)        return output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>序列化组件</strong></p><p>网络层 Network layer:</p><ul><li>nn.Linear()</li><li>nn.Conv2d()</li></ul><p>中间层 Intermediate Operators:</p><ul><li>nn.Dropout()</li><li>nn.BatchNorm()</li></ul><p>激活层 Activation Functions:</p><ul><li>nn.Tanh()</li><li>nn.Sigmoid()</li><li>nn.ReLU()</li></ul><p><strong>显式地声明数据</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import torch.utils.data# input and target values for the XOR taskinput = torch.Tensor([[0,0],[0,1],[1,0],[1,1]])target = torch.Tensor([[0],[1],[1],[0]])xdata = torch.utils.data.TensorDataset(input,target)train_loader = torch.utils.data.DataLoader(xdata,batch_size=4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>从a.csv文件中加载数据</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pddf = pd.read_csv("sonar.all-data.csv")df = df.replace(’R’,0)df = df.replace(’M’,1)data = torch.tensor(df.values,dtype=torch.float32)num_input = data.shape[1] - 1input = data[:,0:num_input]target = data[:,num_input:num_input+1]dataset = torch.utils.data.TensorDataset(input,target)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>自定义数据集</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from data import ImageFolder    # load images from a specified directory    dataset = ImageFolder(folder, transform)import torchvision.datasets as dsets    # download popular image datasets remotely    mnistset = dsets.MNIST(...)    cifarset = dsets.CIFAR10(...)    celebset = dsets.CelebA(...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>选择一个优化器</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># SGD stands for “Stochastic Gradient Descent”optimizer = torch.optim.SGD( net.parameters(),    lr=0.01, momentum=0.9,    weight_decay=0.0001)# Adam = Adaptive Moment Estimation (good for deep networks)optimizer = torch.optim.Adam(net.parameters(),eps=0.000001,    lr=0.01, betas=(0.5,0.999),    weight_decay=0.0001)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>训练</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def train(args, net, device, train_loader, optimizer):for batch_idx, (data,target) in enumerate(train_loader):    optimizer.zero_grad() # zero the gradients    output = net(data) # apply network    loss = ... # compute loss function    loss.backward() # update gradients    optimizer.step() # update weights<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>损失函数</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">loss = torch.sum((output-target)*(output-target))loss = F.nll_loss(output,target)loss = F.binary_cross_entropy(output,target)loss = F.softmax(output,dim=1)loss = F.log_softmax(output,dim=1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>测试</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def test(args, model, device, test_loader):with torch.no_grad(): # suppress updating of gradients    net.eval() # toggle batch norm, dropout    test_loss = 0    for data, target in test_loader:        output = model(data)        test_loss += ...    print(test_loss)    net.train() # toggle batch norm, dropout back again<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>计算图</strong></p><p>PyTorch自动构建一个计算图，使其能够反向传播导数。</p><p>每个参数都包含.data和.grad组件，例如:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">A.dataA.grad# 将所有的.grad组件设置为零optimizer.zero_grad()# 通过在计算图中反向传播梯度，更新所有Parameters的.grad组件loss.backward() # 更新.data组件optimizer.step()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>控制计算图</strong></p><p>如果我们需要阻止梯度通过某个变量(或表达式)a反向传播，我们可以通过以下方法将其从计算图中排除:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">A.detach()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认情况下，loss.backward()在计算梯度之后丢弃计算图。</p><p>如果需要，我们可以这样调用它，迫使它保留计算图:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">loss.backward(retain_graph=True)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> COMP9444 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全链路监控</title>
      <link href="/2021/10/11/ji-zhu-xue-xi/jian-kong-xi-tong/quan-lian-lu-jian-kong/"/>
      <url>/2021/10/11/ji-zhu-xue-xi/jian-kong-xi-tong/quan-lian-lu-jian-kong/</url>
      
        <content type="html"><![CDATA[<h2 id="名词"><a class="markdownIt-Anchor" href="#名词"></a> 名词</h2><p><strong>调用链</strong>是全链路追踪监控的核心概念。从请求源头（前端页面、移动端）到最后的底层服务（比如DB、Redis）的所有中间调用环节。</p><h2 id="难点"><a class="markdownIt-Anchor" href="#难点"></a> 难点</h2><p>数据数据互联互通：多语言协议栈统一、前/后/云（多）端联动、跨云数据融合是实现全链路追踪的三大挑战</p><ol><li><strong>如何快速发现问题？</strong></li><li><strong>如何判断故障影响范围？</strong></li><li><strong>如何梳理服务依赖以及依赖的合理性？</strong></li><li><strong>如何分析链路性能问题以及实时容量规划？</strong></li></ol><h2 id="架构"><a class="markdownIt-Anchor" href="#架构"></a> 架构</h2><h3 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成</h3><p>终端用户、后端应用、云端组件</p><p>开源自建、开源托管与商业化自研</p><h2 id="三方协议"><a class="markdownIt-Anchor" href="#三方协议"></a> 三方协议</h2><p>透传协议标准化：开源透传协议有Jaeger、SkyWalking、ZipKin</p><p>云服务商更好的支持开源链路标准，添加核心方法埋点，并支持开源协议栈透传与数据回流（如阿里云 ARMS 前端监控支持 Jaeger 协议透传与方法栈追踪）。</p><p>由于不同系统可能因为归属等问题，无法完成全链路协议栈统一，为了实现多端联动，需要由 Trace 系统提供异构协议栈的打通方案。</p><p>目的多云数据统一可见：链路数据跨云上报、跨云查询</p><p>跨云上报的优点是部署成本低，一套服务端便于维护；缺点是跨云传输会占用公网带宽</p><p>跨云查询是指原始链路数据保存在当前云网络内，将一次用户查询分别下发，再将查询结果聚合进行统一处理，减少公网传输成本。</p><h2 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h2><p>全面、有效的数据诊断能力：代码级诊断、内存分析、线程池分析、无损统计</p><p>调用链，应用/服务监控，方法栈追踪，性能剖析</p><p>Java 应用：无侵入式埋点无需代码改造，支持边缘诊断、无损统计、精准采样</p><p>查看最大线程数、当前线程数、活跃线程数</p><p>在线调试：Maven 依赖多版本冲突，不同环境动态配置参数不一致，不同环境依赖组件差异</p><p>一个比较完整的全链路监控系统，通常会包括几个部分。</p><ul><li>第一，数据埋点和采集。</li><li>第二，指标计算。</li><li>第三，指标存储、查询、展现。</li><li>第四，调用链的存储、查询、展现。</li><li>第五，告警、问题定位。</li><li>第六，自监控。</li><li>第七，治理。</li><li></li></ul><h2 id="价值"><a class="markdownIt-Anchor" href="#价值"></a> 价值</h2><p>端到端问题诊断，系统间依赖梳理，自定义标记透传</p><p>Trace 产品必须提供更加全面、有效的数据诊断能力，比如代码级诊断、内存分析、线程池分析</p><p>提供动态采样、无损统计、接口名称自动收敛</p><h2 id="评价标准"><a class="markdownIt-Anchor" href="#评价标准"></a> 评价标准</h2><p><strong>探针的性能消耗</strong></p><p><strong>代码的侵入性</strong></p><p><strong>可扩展性</strong></p><p><strong>数据的分析</strong></p><p><strong>1、低侵入性</strong></p><p>监控系统应尽可能减少对业务系统的侵入，保持对使用方的透明性，减少开发人员的负担，降低接入门槛和难度。</p><p><strong>2、低性能影响</strong></p><p>由于全链路监控系统需要对各种应用中间件进行日志数据采集，大多都需要在业务系统内进行“埋点”或放置agent，一般都是在核心业务流程。</p><p>因此应尽可能降低对业务系统造成的性能影响，一般来说，对CPU的耗用低于2%可以作为一个参考阈值。</p><p><strong>3、灵活全面的接入策略</strong></p><p>为了尽可能降低接入成本，应该提供灵活的监控配置策略，让业务方决定是否接入，以及收集数据的范围和粒度，并提供对应的技术方案保障监控策略生效。</p><p><strong>4、时效性</strong></p><p>实时有效的监控数据展示功能，帮助相关人员理解系统行为，为流程、架构、代码优化，以及扩容缩容、服务限流降级提供正确客观的数据参考。</p><h2 id="阿里云arms"><a class="markdownIt-Anchor" href="#阿里云arms"></a> 阿里云ARMS</h2><p>贯穿前端、网关、服务端、容器和云组件的完整可观测系统</p><h3 id="字节码增强"><a class="markdownIt-Anchor" href="#字节码增强"></a> <strong>字节码增强</strong></h3><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247504737&amp;idx=1&amp;sn=2de2fb0e0656c702fa4d2546a9cdd2e5&amp;scene=21#wechat_redirect">《开源自建/托管与商业化自研 Trace，如何选择》</a></p><p>《前后端、多语言、跨云部署，全链路追踪到底有多难？》<a href="https://mp.weixin.qq.com/s/riRAS56VeWE3oHcuzorQyA">https://mp.weixin.qq.com/s/riRAS56VeWE3oHcuzorQyA</a><br>全链路监控（一）：方案概述与比较 <a href="https://www.jianshu.com/p/92a12de11f18">https://www.jianshu.com/p/92a12de11f18</a><br>全链路监控（一）：方案概述 <a href="https://blog.csdn.net/weixin_34290096/article/details/91378380">https://blog.csdn.net/weixin_34290096/article/details/91378380</a><br>使用Skywalking实现全链路监控  <a href="http://www.upyun.com/opentalk/334.html">http://www.upyun.com/opentalk/334.html</a><br>轻松玩转全链路监控  <a href="http://www.360doc.com/content/20/1231/09/99071_954500186.shtml">http://www.360doc.com/content/20/1231/09/99071_954500186.shtml</a></p><p>dapper 的学习 <a href="https://blog.csdn.net/whx750702272/article/details/51105628">https://blog.csdn.net/whx750702272/article/details/51105628</a></p><p><a href="https://www.splunk.com/en_us/observability/resources/log-strategy-for-the-cloud-native-era.html">https://www.splunk.com/en_us/observability/resources/log-strategy-for-the-cloud-native-era.html</a></p><p><a href="https://www.splunk.com/en_us/observability/resources/a-better-approach-to-kubernetes-log-monitoring.html">https://www.splunk.com/en_us/observability/resources/a-better-approach-to-kubernetes-log-monitoring.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持续更新 </tag>
            
            <tag> 全链路监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉课程笔记（4）</title>
      <link href="/2021/10/09/unsw/comp9517/ji-suan-ji-shi-jue-ke-cheng-bi-ji-4/"/>
      <url>/2021/10/09/unsw/comp9517/ji-suan-ji-shi-jue-ke-cheng-bi-ji-4/</url>
      
        <content type="html"><![CDATA[<h2 id="pattern-recognition-模式识别"><a class="markdownIt-Anchor" href="#pattern-recognition-模式识别"></a> Pattern Recognition 模式识别</h2><h3 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> <strong>Introduction</strong></h3><p><strong>Pattern recognition</strong>：The scientific discipline whose goal is to automatically recognise patterns and regularities in the data (e.g. images)</p><p><strong>模式识别</strong>:旨在自动识别数据(如图像)中的模式和规律的科学学科。</p><p><strong>例子</strong><br>-物体识别(例如图像分类)<br>-文字分类(例如滥发/非滥发电邮)<br>-语音识别(例如自动字幕)<br>-事件检测(例如监视)<br>-推荐系统(例如网上商店)</p><h4 id="pattern-recognition-categories-模式识别分类"><a class="markdownIt-Anchor" href="#pattern-recognition-categories-模式识别分类"></a> **Pattern Recognition Categories **模式识别分类</h4><p>基于不同的学习模式<br>•监督学习<br>一组具有可用标签的数据中的学习模式(基本事实)<br>•无监督学习<br>在一组没有任何可用标签的数据中寻找模式<br>•Semi-supervised学习<br>使用有标记和无标记数据的组合来学习模式<br>•弱监督学习<br>在模式的监督学习中使用噪声/有限/不精确的数据标签</p><h4 id="applications-in-computer-vision-在计算机视觉中的应用"><a class="markdownIt-Anchor" href="#applications-in-computer-vision-在计算机视觉中的应用"></a> Applications in Computer Vision 在计算机视觉中的应用</h4><ul><li>关于图像内容的决策</li><li>对图像中的对象进行分类</li><li>识别活动</li><li>字符识别</li><li>人类活动识别</li><li>人脸检测和识别</li><li>基于图像的医疗诊断</li><li>生物认证</li></ul><h4 id="pattern-recognition-overview-模式识别的概述"><a class="markdownIt-Anchor" href="#pattern-recognition-overview-模式识别的概述"></a> <strong>Pattern Recognition Overview 模式识别的概述</strong></h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009105920232.png" alt="image-20211009105920232"></p><h2 id="pattern-recognition-concepts-模式识别的概念"><a class="markdownIt-Anchor" href="#pattern-recognition-concepts-模式识别的概念"></a> <strong>Pattern Recognition Concepts</strong>  模式识别的概念</h2><p>• <strong>Objects</strong> are (identifiable) physical entities of which images are taken <strong>对象</strong>是拍摄图像的(可识别的)物理实体</p><p>• <strong>Regions</strong> (ideally) correspond to objects after image segmentation <strong>区域</strong>(理想情况下)对应于图像分割后的目标</p><p>• <strong>Classes</strong> are disjoint subsets of objects sharing common features <strong>类</strong>是共享共同特性的不相交的对象子集</p><p>• <strong>Labels</strong> are associated with objects and indicate to which class they belong <strong>标签</strong>与对象相关联，并指出它们属于哪个类</p><p>• <strong>Classification</strong> is the process of assigning labels to objects based on features <strong>分类</strong>是基于特征给对象分配标签的过程</p><p>• <strong>Classifiers</strong> are algorithms/methods performing the classification task <strong>分类器</strong>是执行分类任务的算法/方法</p><p>• <strong>Patterns</strong> are regularities in object features and are used by classifiers <strong>模式</strong>是对象特征的规则性，被分类器使用</p><h4 id="pattern-recognition-systems-模式识别系统"><a class="markdownIt-Anchor" href="#pattern-recognition-systems-模式识别系统"></a> <strong>Pattern Recognition Systems 模式识别系统</strong></h4><p>设计分类系统所涉及的基本阶段</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009110610482.png" alt="image-20211009110610482"></p><h4 id="more-pattern-recognition-concepts-更多模式识别概念"><a class="markdownIt-Anchor" href="#more-pattern-recognition-concepts-更多模式识别概念"></a> <strong>More Pattern Recognition Concepts 更多模式识别概念</strong></h4><p>• <strong>Pre-processing</strong> aims to enhance images for further processing <strong>预处理</strong>旨在增强图像进行进一步处理</p><p>• <strong>Feature extraction</strong> reduces the data by measuring certain properties <strong>特征提取</strong>通过测量某些属性来减少数据</p><p>• <strong>Feature descriptors</strong> represent scalar properties of objects <strong>特征描述符</strong>表示对象的标量属性</p><p>• <strong>Feature vectors</strong> capture all the properties measured from the data <strong>特征向量</strong>从数据中获取测量到的所有属性</p><p>• <strong>Feature selection</strong> aims to keep only the most descriptive features <strong>特征选择</strong>旨在只保留最有描述性的特征</p><p>• <strong>Models</strong> are (mathematical or statistical) descriptions of classes <strong>模型</strong>是对类的(数学或统计)描述</p><p>• <strong>Training samples</strong> are objects with known labels used to build models <strong>训练样本</strong>是用于构建模型的具有已知标签的对象</p><p>• <strong>Cost</strong> is the consequence of making an incorrect decision/assignment <strong>成本</strong>是做出错误决定/分配的结果</p><p>• <strong>Decision boundary</strong> is the demarcation between regions in feature space <strong>决策边界</strong>是特征空间中区域之间的分界</p><h4 id="pattern-recognition-example-模式识别的例子"><a class="markdownIt-Anchor" href="#pattern-recognition-example-模式识别的例子"></a> <strong>Pattern Recognition Example 模式识别的例子</strong></h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009112104376.png" alt="image-20211009112104376"></p><h4 id="feature-vector-representation-特征向量表示"><a class="markdownIt-Anchor" href="#feature-vector-representation-特征向量表示"></a> <strong>Feature Vector Representation 特征向量表示</strong></h4><p>向量 𝑥 = [𝑥1, 𝑥2, … , 𝑥𝑑] ，其中每个 𝑥𝑗 是一个特征</p><ul><li>测量对象</li><li>对象部件的计数</li><li>物体的颜色</li></ul><p>特征代表了关于对象的知识，还有其他的名称，如预测者、描述者、协变量、自变量……</p><p><strong>Feature vector examples 特征向量的例子</strong></p><p>‒ 对于鱼识别: [长度, 颜色, 亮度, …]</p><p>‒ 对应字母/数字识别: [holes, moments, SIFT, …]</p><h4 id="feature-extraction-特征提取"><a class="markdownIt-Anchor" href="#feature-extraction-特征提取"></a> <strong>Feature Extraction 特征提取</strong></h4><p>通过测量（<strong>measurements</strong>）来确定物体的特征</p><ul><li>类似的对象在相同的类/类别</li><li>不同类中的对象不同</li></ul><p>使用<strong>鲜明特点 （distinguishing features）</strong></p><ul><li>物体位置不变(平移)</li><li>物体方向不变(旋转)</li><li>不变的…(取决于应用程序)</li><li>好的例子是形状，颜色，纹理</li></ul><p>功能设计通常基于<strong>先前的经验</strong>（<strong>prior experience</strong>）或<strong>直觉（intuition）</strong></p><p>选择<strong>健壮的</strong>（<strong>robust to</strong>）特性</p><ul><li>刚性转换（平移和旋转）</li><li>遮挡和其他3d - 2d投影畸变</li><li>非刚性/铰接物体变形（例如手指围绕杯子）</li><li>光照和阴影的变化</li></ul><p>特征选择是问题和领域相关的，<strong>需要领域知识</strong> <strong>requires domain knowledge</strong></p><p>分类技术可以帮助<strong>使特征值的噪声更小</strong> <strong>敏感</strong>，并从更大的集合中<strong>选择有价值的特征</strong></p><p><strong>分类技术Classification techniques</strong>可以帮助降低特征值的噪声<strong>敏感性sensitive</strong>，并从更大的集合中选择<strong>有价值的特征valuable features</strong></p><h3 id="supervised-learning-overview-监督学习概述"><a class="markdownIt-Anchor" href="#supervised-learning-overview-监督学习概述"></a> <strong>Supervised Learning Overview 监督学习概述</strong></h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009155118983.png" alt="image-20211009155118983"></p><h4 id="pattern-recognition-models-模式识别模型"><a class="markdownIt-Anchor" href="#pattern-recognition-models-模式识别模型"></a> Pattern Recognition Models 模式识别模型</h4><p><strong>Generative models 生成模型</strong></p><ul><li>为生成数据的“机制”建模</li><li>代表了每个类的概率“模型”𝑝(𝑥|𝑦)和𝑝(𝑦)</li><li>获取数据的联合概率𝑝(𝑥,𝑦)=𝑝(𝑥|𝑦)𝑝(𝑦)</li><li>通过最可能的𝑝(𝑦|𝑥)隐式地找到决策边界</li><li>适用于无监督学习任务（无标记数据）</li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009155700815.png" alt="image-20211009155700815"></p><p><strong>Discriminative models 有识别力的模型</strong></p><ul><li>关注决策边界的明确建模</li><li>适用于监督学习任务（有标签的数据）</li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009155709533.png" alt="image-20211009155709533"></p><h3 id="classification-分类"><a class="markdownIt-Anchor" href="#classification-分类"></a> <strong>Classification</strong> 分类</h3><p>分类器通过使用特征形式的对象描述，<strong>为对象分配类标签来实现对象识别</strong> <strong>assigning a class label to an object</strong></p><p>完美的分类往往是不可能的，相反，<strong>要确定每个可能类别的概率</strong>  <strong>instead determine the probability for each possible class</strong></p><p>困难是由<strong>相同类别中的对象与不同类别中的对象的特征值的变化造成的</strong> <strong>variability in feature values for objects in the same class versus objects in different classes</strong></p><ul><li>变化可能是由于<strong>复杂性</strong> <strong>complexity</strong>，但也可能是由于<strong>噪声</strong> <strong>noise</strong></li><li>嘈杂的功能和缺失的功能是主要问题</li><li>不总是可能确定一个对象的所有特征的值</li></ul><h3 id="binary-classification-二元分类"><a class="markdownIt-Anchor" href="#binary-classification-二元分类"></a> <strong>Binary Classification 二元分类</strong></h3><p>给出𝑁观察的训练集：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009160337613.png" alt="image-20211009160337613"></p><p>分类是估计的问题：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009160429816.png" alt="image-20211009160429816"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009160436550.png" alt="image-20211009160436550"></p><h3 id="nearest-class-mean-classifier-最近邻类均值分类器"><a class="markdownIt-Anchor" href="#nearest-class-mean-classifier-最近邻类均值分类器"></a> <strong>Nearest Class Mean Classifier</strong>  最近邻类均值分类器</h3><p>基于<strong>最小距离原则minimum distance principle</strong>，其中类示例就是类的质心(或方法)</p><p><strong>训练集 Training</strong>: Given training sample pairs { (𝑥1, 𝑦1 , 𝑥2, 𝑦2 , … , 𝑥𝑁, 𝑦𝑁 }, 每个类𝑘的质心为</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009160655709.png" alt="image-20211009160655709"></p><p><strong>测试集 Testing</strong>：如果𝑥比任何其他类的质心更接近于𝑘类的质心，则每个具有特征向量𝑥的未知对象被分类为𝑘类</p><ul><li><p>计算特征向量𝑥与各类质心之间的欧氏距离</p></li><li><p>选择最接近的类，如果足够接近(否则拒绝)</p></li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009161026185.png" alt="image-20211009161026185"></p><p>第二类有两种模式，那它的质心在哪里?<br>如果检测到模式，可以使用两个子类的质心</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009161647650.png" alt="image-20211009161647650"></p><ul><li>优点 Pros<ul><li>简单</li><li>快速</li><li>在类紧密且彼此距离较远时很有效</li></ul></li><li>缺点 Cons<ul><li>复杂类的结果较差(多模态，非球形)</li><li>不能很好地处理异常值和噪声数据</li><li>不能处理丢失的数据</li></ul></li></ul><h3 id="k-nearest-neighbours-classifier-k近邻分类器"><a class="markdownIt-Anchor" href="#k-nearest-neighbours-classifier-k近邻分类器"></a> <strong>K-Nearest Neighbours Classifier K近邻分类器</strong></h3><p>K-nn是一种分类器，它根据数据集中最接近的K个<strong>based on the K nearest samples</strong>样本来决定样本的类别标签<br>对于每一个新的测试样本，计算测试样本与所有训练样本之间的距离，以及K个最近邻的训练<br>样本将被分配到邻居中成员最多的类中<br>从已知类的一组训练样本中选择邻居</p><p>欧几里得距离<strong>Euclidean distance</strong>通常用于连续变量 <strong>continuous variables</strong><br>汉明距离<strong>Hamming distance</strong> 通常用于离散变量<strong>discrete variables</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009163725588.png" alt="image-20211009163725588"></p><p><strong>优点</strong></p><ul><li>非常简单直观</li><li>易于实现</li><li>没有先验假设</li><li>没有训练步骤</li><li>决策曲面是非线性的</li></ul><p><strong>缺点</strong><br>×  大数据集的慢算法<br>× 需要同质(相似性质)特征类型和尺度<br>× 在变量数量增加时表现不佳(维度的诅咒)<br>× 寻找最优的K(邻居数量)是很有挑战性的</p><h3 id="bayesian-decision-theory-贝叶斯决策理论"><a class="markdownIt-Anchor" href="#bayesian-decision-theory-贝叶斯决策理论"></a> <strong>Bayesian Decision Theory 贝叶斯决策理论</strong></h3><p>分类器的决策可能正确，也可能不正确，所以它们应该是概率性的(软决策而不是硬决策)<br>概率分布可用于做出错误率最低的分类决策</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009164810543.png" alt="image-20211009164810543"></p><p><strong>Bayesian classification 贝叶斯分类</strong> assigns an object into the class to which it most likely belongs based on observed features</p><p>假设已知以下内容:</p><ul><li>先验概率𝑝(𝑐𝑖)为每个类𝑐𝑖</li><li>无条件分配𝑝(𝑥)</li><li>类条件分布𝑝(𝑥|𝑐𝑖)</li></ul><p>计算后验概率𝑝(𝑐𝑖|𝑥):<br>如果所有的类都是不相交的，根据贝叶斯规则，后验概率为</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009165310594.png" alt="image-20211009165310594"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009165317947.png" alt="image-20211009165317947"></p><h3 id="bayesian-decision-theory-贝叶斯决策理论-2"><a class="markdownIt-Anchor" href="#bayesian-decision-theory-贝叶斯决策理论-2"></a> <strong>Bayesian Decision Theory 贝叶斯决策理论</strong></h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009165530474.png" alt="image-20211009165530474"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009165608754.png" alt="image-20211009165608754"></p><p>错误率<br><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009165632732.png" alt="image-20211009165632732"></p><p><strong>贝叶斯决策规则 Bayes decision rule</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009165916936.png" alt="image-20211009165916936"></p><h4 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子：</h4><p>对于捕捞的一种鱼，假设各类型的概率是：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009170052285.png" alt="image-20211009170052285"></p><p>基于先验的决策规则 <strong>decision rule based on prior</strong></p><p>由于Sea bass概率最高，总是假定是Sea bass</p><p>假设依据长度length，有类条件<strong>class conditionals</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009170326131.png" alt="image-20211009170326131"></p><p><strong>后验概率</strong> <strong>posterior probability</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009170509096.png" alt="image-20211009170509096"></p><p>如果一只鱼的长度是70cm，那么</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009170629668.png" alt="image-20211009170629668"></p><p>根据这些概率，我们预测其类型为<strong>海鲈鱼 sea bass</strong></p><h4 id="bayesian-decision-risk-贝叶斯决策风险"><a class="markdownIt-Anchor" href="#bayesian-decision-risk-贝叶斯决策风险"></a> <strong>Bayesian Decision Risk 贝叶斯决策风险</strong></h4><p>后验概率最大化 <strong>maximizing the posterior probability</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009171022966.png" alt="image-20211009171022966"></p><p>𝑅(𝛼𝑖|𝑥) is also called <strong>有条件的风险conditional risk</strong></p><p>最优贝叶斯决策策略是<strong>条件风险最小化 minimize the conditional risk</strong></p><p>假设损失函数为</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009171355432.png" alt="image-20211009171355432"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009171504049.png" alt="image-20211009171504049"></p><p>• 优点</p><ul><li>简单直观</li><li>考虑不确定性</li><li>允许将新信息与现有知识相结合<br>• 缺点<br>× 计算昂贵<br>× 先验的选择可以是主观的</li></ul><h3 id="decision-trees-introduction-决策树介绍"><a class="markdownIt-Anchor" href="#decision-trees-introduction-决策树介绍"></a> <strong>Decision Trees: Introduction 决策树:介绍</strong></h3><p>• 大多数模式识别方法处理特征的问题<br>向量是实值的，并且存在一些度规的概念<br>• 一些分类问题涉及离散数据的标称数据描述符，没有相似或顺序的自然概念<br>—示例:{high, medium, low}， {red, green, blue}<br>-标称数据<strong>Nominal data</strong>也称为分类数据<strong>categorical data</strong><br>可以使用基于规则的方法<strong>rule-based methods</strong>对标称数据进行分类</p><p><strong>方法</strong></p><ul><li>通过一系列问题对样本进行分类</li><li>下一个问题取决于当前问题的答案</li><li>在有向决策树或简单树中显示的问题序列</li></ul><p><strong>结构</strong></p><ul><li>树中的节点表示特征</li><li>叶节点包含类标签</li><li>一次一个(或几个)功能来分割搜索空间</li><li>每个分支节点对于父特性的每个可能值都有一个子特性</li></ul><p><strong>分类</strong></p><ul><li>从根节点开始，按照适当的链接到叶节点</li><li>将叶节点的类标签分配给测试样本</li></ul><h4 id="decision-trees-construction-决策树构造"><a class="markdownIt-Anchor" href="#decision-trees-construction-决策树构造"></a> <strong>Decision Trees Construction</strong> 决策树构造</h4><p>•二叉决策树<strong>Binary decision tree</strong>:具有决策功能的二叉树结构与每个节点相关联<br>•简单情况<strong>Simple case</strong>:数值特征值和决策函数选择左/右分支，如果一个特性的值低于/高于一个阈值<br>•优点:每个节点只使用一个特性和一个阈值<br>•对于任何给定的训练样本集，可能有一个以上的可能决策树根据特征顺序对它们进行分类<br>•我们必须根据某种标准选择能够给出“最佳”树的特性<br>•计算上最小的树优先  <strong>smallest tree is preferred</strong></p><p><strong>use measures from information theory 使用信息论中的度量</strong></p><p><strong>Entropy</strong> and <strong>Information Gain</strong> <strong>熵</strong>与信息增益</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009173155769.png" alt="image-20211009173155769"></p><p><strong>Information gain 信息增益</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009173925175.png" alt="image-20211009173925175"></p><p>•优点<br>易解读<br>可以同时处理数字和分类数据<br>对异常值和缺失值的鲁棒性<br>提供关于功能重要性的信息(功能选择)<br>•缺点<br>×倾向于过度拟合<br>×仅轴对齐的分割<br>×贪心算法(可能找不到最优树)</p><h3 id="ensemble-learning-整体学习"><a class="markdownIt-Anchor" href="#ensemble-learning-整体学习"></a> <strong>Ensemble Learning 整体学习</strong></h3><p><strong>集成学习</strong>将多个模型结合在一起，与从任何一个组成模型获得的预测性能相比，提高了预测性能</p><h4 id="random-forests-随机森林"><a class="markdownIt-Anchor" href="#random-forests-随机森林"></a> <strong>Random Forests 随机森林</strong></h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009175750961.png" alt="image-20211009175750961"></p><p>优点</p><ul><li><p>在传统分类算法中准确率高，解决了许多问题</p></li><li><p>在大型数据集上高效工作</p></li><li><p>处理数千个输入特性而不选择特性</p></li><li><p>有效处理缺失值</p></li></ul><p>缺点<br>× 比单个决策树更难以解释<br>× 构建决策树比构建决策树更复杂、更耗时</p><h4 id="separability-可分性"><a class="markdownIt-Anchor" href="#separability-可分性"></a> <strong>Separability 可分性</strong></h4><p><strong>Separable classes 可分的类</strong>：如果存在一个区分子空间，它将特征空间分隔开来，使得每个区域中只有来自一类的对象，那么该识别任务就称为具有可分离类</p><p><strong>Linearly separable 线性可分</strong>：如果可以用超平面作为判别子空间来分离对象类，则称特征空间是线性可分的</p><p>![image-20211009231822764](/Users/yinkejian/Library/Application Support/typora-user-images/image-20211009231822764.png)</p><p>线性分类器具有的形式：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009231925423.png" alt="image-20211009231925423"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009232016368.png" alt="image-20211009232016368"></p><h3 id="support-vector-machines-支持向量机"><a class="markdownIt-Anchor" href="#support-vector-machines-支持向量机"></a> <strong>Support Vector Machines 支持向量机</strong></h3><p>Support Vector Machines (SVM)</p><p><strong>hard margin SVM</strong>：do not allows some degree of misclassification</p><p><strong>soft margin SVM</strong>：allows some degree of misclassification</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009232714510.png" alt="image-20211009232714510"></p><h3 id="nonlinear-support-vector-machines-非线性支持向量机"><a class="markdownIt-Anchor" href="#nonlinear-support-vector-machines-非线性支持向量机"></a> <strong>Nonlinear Support Vector Machines</strong> 非线性支持向量机</h3><p>优点<br>在高维特征空间中非常有效<br>当特征个数大于训练数据量时有效<br>是类(很好地)可分离时的最佳算法之一<br>在数据稀疏的情况下工作得很好<br>可以通过核技巧扩展到非线性分类<br>•缺点<br>×对于较大的数据集，它需要更多的时间来处理<br>×在重叠的类中表现不佳<br>×充分泛化所需的超参数调谐</p><h3 id="multiclass-classification-多类分类"><a class="markdownIt-Anchor" href="#multiclass-classification-多类分类"></a> <strong>Multiclass Classification 多类分类</strong></h3><h3 id="evaluation-of-classification-error-评估分类错误"><a class="markdownIt-Anchor" href="#evaluation-of-classification-error-评估分类错误"></a> <strong>Evaluation of Classification Error</strong> 评估分类错误</h3><p><strong>Error rate 错误率</strong></p><p>– Measures how well/poor the system solves the problem it was designed for</p><p>• <strong>Reject class 拒绝类</strong></p><p>– Generic class for objects that cannot be placed in any of the known classes</p><p>• <strong>Performance</strong> 表现</p><p>– Performance determined by both errors and rejections made</p><p>– Classifying all inputs into reject class means system makes no errors but is useless!</p><p>• <strong>Classification error 分类错误</strong></p><p>– The classifier makes a classification error whenever it classifies an input object as</p><p>class 𝐶𝑖 when the true class is 𝐶𝑗, 𝑖 ≠ 𝑗, and 𝐶𝑖 ≠ 𝐶𝑟 (the reject class)</p><p>• <strong>Empirical error rate 实证错误率</strong></p><p>– Number of errors on independent test data divided by number of classifications attempted</p><p>• <strong>Empirical reject rate 实证拒绝率</strong></p><p>– Number of rejects on independent test data divided by number of classifications attempted</p><p>• <strong>Independent test data 独立测试数据</strong></p><p>– Sample objects with true class (labels) known, including objects from the reject class, and that were not used in designing the feature extraction and classification algorithms</p><p>• <strong>Samples used for training and testing should be representative 用于训练和测试的样品应具有代表性</strong></p><p>– Available data is split for example in 80% training and 20% test data</p><h4 id="false-alarms-and-false-dismissals-虚假警报和虚假驳回"><a class="markdownIt-Anchor" href="#false-alarms-and-false-dismissals-虚假警报和虚假驳回"></a> <strong>False Alarms and False Dismissals 虚假警报和虚假驳回</strong></h4><p><strong>type I error</strong>： <strong>false alarm</strong> or <strong>false positive</strong></p><p><strong>type II error</strong> <strong>：false dismissal</strong> or <strong>false negative</strong></p><p><strong>Receiver Operating Curve (ROC) 接收机操作曲线</strong></p><h4 id="confusion-matrix-混淆矩阵"><a class="markdownIt-Anchor" href="#confusion-matrix-混淆矩阵"></a> <strong>Confusion Matrix 混淆矩阵</strong></h4><p>used to report the results of classification experiments</p><h4 id="binary-confusion-matrix-二进制混淆矩阵"><a class="markdownIt-Anchor" href="#binary-confusion-matrix-二进制混淆矩阵"></a> <strong>Binary Confusion Matrix 二进制混淆矩阵</strong></h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009234743275.png" alt="image-20211009234743275"></p><p>Accuracy 精确度<br><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009234801972.png" alt="image-20211009234801972"></p><h4 id="precision-versus-recall-精度和召回"><a class="markdownIt-Anchor" href="#precision-versus-recall-精度和召回"></a> <strong>Precision versus Recall</strong>  精度和召回</h4><p><strong>Precision / correctness 精密/正确性</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009234950747.png" alt="image-20211009234950747"></p><p>**Recall / sensitivity / completeness 召回/灵敏度/完整性 **</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009235027917.png" alt="image-20211009235027917"></p><p><strong>F1 score</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009235043547.png" alt="image-20211009235043547"></p><p><strong>More Terminology and Metrics</strong></p><p>![image-20211009235156148](/Users/yinkejian/Library/Application Support/typora-user-images/image-20211009235156148.png)</p><h3 id="regression-回归"><a class="markdownIt-Anchor" href="#regression-回归"></a> <strong>Regression 回归</strong></h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211010001717987.png" alt="image-20211010001717987"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211010001725339.png" alt="image-20211010001725339"></p><p><strong>Linear Regression 线性回归</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211010001929148.png" alt="image-20211010001929148"></p><p><strong>least squares fitting 最小二乘拟合</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211010001944479.png" alt="image-20211010001944479"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211010001958519.png" alt="image-20211010001958519"></p><p><strong>Least Squares Regression 最小二乘回归</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211010002127594.png" alt="image-20211010002127594"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211010002055215.png" alt="image-20211010002055215"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211010002418733.png" alt="image-20211010002418733"></p><p><strong>Regression Evaluation Metrics 回归评价指标</strong></p><p><strong>Root Mean Square Error (RMSE)</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211010002947403.png" alt="image-20211010002947403"></p><p><strong>Mean Absolute Error (MAE)</strong></p><p>![image-20211010003043068](/Users/yinkejian/Library/Application Support/typora-user-images/image-20211010003043068.png)</p><p><strong>Smaller values of RMSE and MAE are more desirable</strong></p><p><strong>R-Squared (<strong>𝑹^𝟐</strong>)</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211010003147051.png" alt="image-20211010003147051"></p><p><strong>Adjusted R-Squared (Adjusted</strong> 𝑹^𝟐**)**</p><p>![image-20211010003251741](/Users/yinkejian/Library/Application Support/typora-user-images/image-20211010003251741.png)</p><p><strong>Larger values of R-Squared and Adjusted R-Squared are more desirable</strong></p><h3 id="normalization-归一化"><a class="markdownIt-Anchor" href="#normalization-归一化"></a> <strong>Normalization 归一化</strong></h3><p>Goal: to change the scale of numeric values to a common scale</p><p>目标:将数值的比例改为普通比例</p><p><strong>Z-score:</strong> <img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211010003550123.png" alt="image-20211010003550123"></p><p><strong>Min-max normalization:</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211010003618922.png" alt="image-20211010003618922"></p><h3 id="cross-validation-交叉验证"><a class="markdownIt-Anchor" href="#cross-validation-交叉验证"></a> <strong>Cross Validation 交叉验证</strong></h3><p>Cross validation (CV) is a technique to assess model performance across all data</p><p>交叉验证(CV)是一种通过所有数据评估模型性能的技术</p><p>**Train-test split:**80/20</p><p>**K-fold cross validation K-fold交叉验证:**数据被分成K个子集(折叠)，在每次迭代中，我们保留一个折叠用于测试，其余的用于训练</p><p>![image-20211010004126113](/Users/yinkejian/Library/Application Support/typora-user-images/image-20211010004126113.png)</p><p><em><strong>covariance matrix</strong></em> 协方差矩阵</p><p><em><strong>homogeneous</strong></em>  adj. 均匀的</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> COMP9517 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉课程笔记（3）</title>
      <link href="/2021/10/09/unsw/comp9517/ji-suan-ji-shi-jue-ke-cheng-bi-ji-3/"/>
      <url>/2021/10/09/unsw/comp9517/ji-suan-ji-shi-jue-ke-cheng-bi-ji-3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> COMP9517 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程决策结构（4）</title>
      <link href="/2021/10/08/unsw/gsoe9210/gong-cheng-jue-ce-jie-gou-4/"/>
      <url>/2021/10/08/unsw/gsoe9210/gong-cheng-jue-ce-jie-gou-4/</url>
      
        <content type="html"><![CDATA[<h2 id="bayes-decisions-贝叶斯决策"><a class="markdownIt-Anchor" href="#bayes-decisions-贝叶斯决策"></a> Bayes decisions 贝叶斯决策</h2><h3 id="decisions-with-likelihoods-决策与可能"><a class="markdownIt-Anchor" href="#decisions-with-likelihoods-决策与可能"></a> Decisions with likelihoods 决策与可能</h3><h4 id="decision-problem-classes-决策问题分类"><a class="markdownIt-Anchor" href="#decision-problem-classes-决策问题分类"></a> Decision problem classes 决策问题分类</h4><p>决策问题可以根据agent的认知状态（agent’s epistemic state）进行分类：</p><ul><li>Decisions under <em>certainty</em>: the agent knows the unique actual state</li><li>Decisions under <em>uncertainty</em>:<ul><li>Decisions under <em>ignorance</em> (full uncertainty): the agent believes multiple states/outcomes are possible; likelihoods unknown</li><li>Decisions under <em>risk</em>: the agent believes multiple states/outcomes are possible; likelihood information available</li></ul></li></ul><h4 id="river-example"><a class="markdownIt-Anchor" href="#river-example"></a> River example</h4><p>Suppose that Alice has to deliver one package to C every day. Her records show that out of the last 100 days, the ferry was operating on 75.</p><p>Alice considers three possible ways to get to C (from starting point X):</p><p>A:  via A, by flfloating down the river</p><p>B:  via B, by travelling up-stream to B</p><p>C:  by travelling all the way to C</p><p>Let <em>w</em> : Ω <em>→</em> R denote fuel consumption in litres. What transformation <em>f</em> : R <em>→</em> R is responsible for the values <em>v</em> : Ω <em>→</em> R in the decision table?</p><h4 id="single-decision-multiple-trials-一个决定多个试验"><a class="markdownIt-Anchor" href="#single-decision-multiple-trials-一个决定多个试验"></a> Single decision; multiple trials 一个决定;多个试验</h4><p>Long term fuel savings:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008225652796.png" alt="image-20211008225652796"></p><p>Short-term outcome horizon (one/a few days):</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008225827096.png" alt="image-20211008225827096"></p><p>简化假设：</p><p>Assume long sequence of days and <em>maximum likelihood</em> probability</p><p>Infer probability that ferry operates on any given day <em>p</em> = 75 / 100 = 3 / 4</p><p>![image-20211008230049975](/Users/yinkejian/Library/Application Support/typora-user-images/image-20211008230049975.png)</p><h4 id="likelihood-and-decisions-可能性和决定"><a class="markdownIt-Anchor" href="#likelihood-and-decisions-可能性和决定"></a> Likelihood and decisions 可能性和决定</h4><h4 id="probabilistic-lotteries-概率彩票"><a class="markdownIt-Anchor" href="#probabilistic-lotteries-概率彩票"></a> Probabilistic lotteries 概率彩票</h4><p><strong>Definition (Probabilistic lottery)</strong> : A <em>probabilistic lottery</em> over a finite set of outcomes, or prizes, Ω, is a pair <em>l</em> = (Ω, P), where <em>P</em> : Ω <em>→</em> R is a probability function. The lottery <em>l</em>  is written:</p><p>![image-20211008230623090](/Users/yinkejian/Library/Application Support/typora-user-images/image-20211008230623090.png)</p><p><em>s_i</em> <em>∈ S ⊆</em> P(Ω), <em>p_i</em> = <em>P</em>(<em>s_i</em> ) = <em>P</em>(<em>c_i</em>)</p><p><strong>Definition (Value of a lottery):</strong> The value of a probabilistic lottery (Ω*, P, v*) is the expected value over its</p><p>outcomes:</p><p>![image-20211008230954219](/Users/yinkejian/Library/Application Support/typora-user-images/image-20211008230954219.png)</p><p>For strategy A:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008231024497.png" alt="image-20211008231024497"></p><p>频率解释: V (’ A)是A在许多天内的平均值</p><h3 id="bayes-decisions-贝叶斯决策-2"><a class="markdownIt-Anchor" href="#bayes-decisions-贝叶斯决策-2"></a> Bayes decisions 贝叶斯决策</h3><p>在风险下，决策问题中的每个策略都对应于概率抽奖</p><p><strong>Definition (Bayes value)</strong>: Given a probability distribution over states, the <em>Bayes value</em>, <em>V_B</em>, of a strategy is the expected value of its outcomes.</p><p>给定状态的概率分布，策略的贝叶斯值V_B就是其结果的期望值。</p><p><strong>Definition (Bayes strategy)</strong>: A <em>Bayes strategy</em> is a strategy with maximal <em>Bayes</em> value.</p><p>定义(Bayes策略):Bayes策略是指Bayes值最大的策略。</p><p><strong>Definition (Bayes decision rule)</strong>: The <em>Bayes decision rule</em> is the rule which selects all the <em>Bayes</em> strategies.</p><p>贝叶斯决策规则是选择所有贝叶斯策略的规则。</p><h3 id="bayes-strategies-river-problem"><a class="markdownIt-Anchor" href="#bayes-strategies-river-problem"></a> <em>Bayes</em> strategies: River problem</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008231744679.png" alt="image-20211008231744679"></p><h3 id="indifffference-curves-maximin-无差异曲线极大极小"><a class="markdownIt-Anchor" href="#indifffference-curves-maximin-无差异曲线极大极小"></a> Indifffference curves: <em>Maximin</em> 无差异曲线:极大极小</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008232016474.png" alt="image-20211008232016474"></p><p>Indifffference curves: <em>Bayes</em> 无差异曲线:贝叶斯</p><p>What do <em>Bayes</em> indifffference curves look like?</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008232103998.png" alt="image-20211008232103998"></p><p>Indifffference curves: <em>V_B</em>(<em>a</em>) = *pv_1 + (1 - <em>p</em>) <em>v</em>2 = <em>u</em></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008232151102.png" alt="image-20211008232151102"></p><p>gradient-intercept form 梯度截距式</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008232351102.png" alt="image-20211008232351102"></p><p><strong>m = -p/(1-p) = ∆y/∆x</strong></p><p><strong>p = m/ (m-1) = ∆y / (∆x + ∆y)</strong></p><p>p∝-m</p><h4 id="indifference-curves-bayes-无差异曲线贝叶斯"><a class="markdownIt-Anchor" href="#indifference-curves-bayes-无差异曲线贝叶斯"></a> Indifference curves: <em>Bayes</em> 无差异曲线:贝叶斯</h4><p>一般来说，对于两个动作:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008232646329.png" alt="image-20211008232646329"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008232854200.png" alt="image-20211008232854200"></p><h4 id="indifffference-classes-and-bayes-decisions-无差异类和贝叶斯决策"><a class="markdownIt-Anchor" href="#indifffference-classes-and-bayes-decisions-无差异类和贝叶斯决策"></a> Indifffference classes and <em>Bayes</em> decisions 无差异类和贝叶斯决策</h4><h3 id="bayes-strategies-贝叶斯策略"><a class="markdownIt-Anchor" href="#bayes-strategies-贝叶斯策略"></a> <em>Bayes</em> strategies 贝叶斯策略</h3><p>For the pure actions below with P(s_1 ) = <em>p</em>:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008233128198.png" alt="image-20211008233128198"></p><h3 id="bayes-strategies-probability-plots"><a class="markdownIt-Anchor" href="#bayes-strategies-probability-plots"></a> <em>Bayes</em> strategies: probability plots</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008234914604.png" alt="image-20211008234914604"></p><p><strong>Defifinition</strong>:  The least favourable probability distribution on the states/outcomes is the probability distribution for which Bayes strategies have minimal values.</p><p>状态/结果的最不利概率分布是贝叶斯策略具有最小值的概率分布。</p><h3 id="bayes-solutions-贝叶斯方法"><a class="markdownIt-Anchor" href="#bayes-solutions-贝叶斯方法"></a> <em>Bayes</em> solutions 贝叶斯方法</h3><p>For the pure actions below with <em>P</em>(<em>s</em>1 ) = <em>p</em>:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008235357837.png" alt="image-20211008235357837"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008235404276.png" alt="image-20211008235404276"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008235357837.png" alt=""></p><h4 id="bayes-strategies-贝叶斯策略-2"><a class="markdownIt-Anchor" href="#bayes-strategies-贝叶斯策略-2"></a> <em>Bayes</em> strategies 贝叶斯策略</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211008235512969.png" alt="image-20211008235512969"></p><p>The <em>Maximin</em> action is a <em>Bayes</em> action when p = 3/4</p><p>Mixed strategy <em>a</em> <em>∼</em> 0*.<em>5A0</em>.<em>3B0</em>.*2C is not <em>Bayes</em></p><h2 id="bayes-summary"><a class="markdownIt-Anchor" href="#bayes-summary"></a> <em>Bayes</em> summary</h2><p><strong>Theorem 定理</strong></p><p>*Mixing can improve upon the Maximin value of pure strategies, but it *<em>does not improve upon the Bayes value of pure strategies</em></p><p>混合可以提高纯策略的Maximin值，但不能提高纯策略的Bayes值</p><p><em>Bayes strategies are invariant/preserved under regret; i.e., the same</em> <em>strategy is chosen under regret as otherwise</em></p><p>贝叶斯策略不变/保留遗憾；也就是说，在遗憾和非遗憾情况下选择的策略是相同的</p><h3 id="bayes-maximin-and-admissibility-贝叶斯maximin和可采性"><a class="markdownIt-Anchor" href="#bayes-maximin-and-admissibility-贝叶斯maximin和可采性"></a> <em>Bayes</em>, <em>Maximin</em>, and admissibility 贝叶斯，Maximin和可采性</h3><p>Which mixed strategies above are admissible?</p><p>Are <em>Maximin</em> mixed strategies always admissible?</p><p>Are <em>Bayes</em> mixed strategies always admissible?</p><p>Are <em>Maximin</em> mixed strategies always <em>Bayes</em> for some <em>p</em>?</p><p>Are admissible mixed strategies <em>Bayes</em> for some <em>p</em>?</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> GSOE9210 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac安装OpenCV</title>
      <link href="/2021/10/02/zui-jia-shi-jian/mac-an-zhuang-opencv/"/>
      <url>/2021/10/02/zui-jia-shi-jian/mac-an-zhuang-opencv/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 先卸载OpenCVpip uninstall opencv-pythonpip uninstall opencv-contrib-python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 安装对应的版本pip install opencv_python==3.4.2.16pip install opencv-contrib-python==3.4.2.16# 使用国内清华源安装pip install -i https://pypi.tuna.tsinghua.edu.cn/simple opencv_python==3.4.2.16pip install -i https://pypi.tuna.tsinghua.edu.cn/simple opencv-contrib-python==3.4.2.16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>参考文档</p><p>【解决问题】ATTRIBUTEERROR:MODULE CV2.CV2 HAS NO ATTRIBUTE XFEATURES2<br><a href="https://www.freesion.com/article/7729770941/">https://www.freesion.com/article/7729770941/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 最佳实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Mac </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV使用手册</title>
      <link href="/2021/10/01/ji-zhu-xue-xi/ai/opencv-shi-yong-shou-ce/"/>
      <url>/2021/10/01/ji-zhu-xue-xi/ai/opencv-shi-yong-shou-ce/</url>
      
        <content type="html"><![CDATA[<h2 id="matplotlib-pyplot"><a class="markdownIt-Anchor" href="#matplotlib-pyplot"></a> Matplotlib Pyplot</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import matplotlib.pyplot as pltimport numpy as npxpoints = np.array([0, 6])ypoints = np.array([0, 100])plt.plot(xpoints, ypoints) # 根据X轴和y轴的值画连接线plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="plt"><a class="markdownIt-Anchor" href="#plt"></a> plt</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 基本使用方法import matplotlib.pyplot as pltplt.figure(figsize=(12,8), dpi=80)plt.plot([1,2,6,4],[4,5,6,9])plt.savefig('./plt_png/test1.png') #必须要放在show()前面，show()之后会自动释放图表内存plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 创建数据，画一个标准的带背景网格的图import random#创建一个小时内温度随时间变化的曲线（以分钟计算，温度在15到20之间）#1.准备数据x = range(60)y = [random.uniform(15,20)for i in x]#2.创建画布plt.figure( figsize=(12,8), dpi=80 )plt.plot(x,y)#3 设置刻度及步长z = range(40)x_label = ['11:{}'.format(i) for i in x]plt.xticks( x[::5], x_label[::5])plt.yticks(z[::5])  #5是步长#4 添加网格信息plt.grid(True, linestyle='--', alpha=0.5) #默认是True，风格设置为虚线，alpha为透明度#5 添加标题（中文在plt中默认乱码，不乱码的方法在本文最后说明）plt.xlabel('Time')plt.ylabel('Temperature')plt.title('Curve of Temperature Change with Time')#6 保存图片，并展示plt.savefig('./plt_png/test1.2.png')plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 画两条曲线的图#3 创建另一个曲线的数据y_another = [random.uniform(5,10)for i in x]#输入两个曲线的信息plt.figure( figsize=(12,8), dpi=80 )plt.plot(x, y, color='r', linestyle='--', label = 'ShangHai')plt.plot(x, y_another, color='g', linestyle='-.', label = 'BeiJing')#显示图例plt.legend() #默认loc=Best#设置刻度及步长z = range(40)x_label = ['11:{}'.format(i) for i in x]plt.xticks( x[::5], x_label[::5])plt.yticks(z[::5])  #5是步长#添加网格信息plt.grid(True, linestyle='--', alpha=0.5) #默认是True，风格设置为虚线，alpha为透明度#添加标题plt.xlabel('Time')plt.ylabel('Temperature')plt.title('Curve of Temperature Change with Time')plt.savefig('./plt_png/test1.3.png')plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 多个绘图区域画不同的图#4 创建多个绘图区#输入两个曲线的信息#plt.figure( figsize=(12,8), dpi=80 )figure, axes = plt.subplots( nrows=1, ncols=2, figsize=(12,8), dpi=80 )axes[0].plot(x, y, color='r', linestyle='--', label = 'ShangHai')axes[1].plot(x, y_another, color='g', linestyle='-.', label = 'BeiJing')#显示图例axes[0].legend() #默认loc=Bestaxes[1].legend()#设置刻度及步长z = range(40)x_label = ['11:{}'.format(i) for i in x]#axes[0].set_xticks( x[::5], x_label[::5]) #set_xticks()不支持字符串，只支持布尔值#axes[1].set_yticks(z[::5])  #5是步长 #set_yticks()不支持字符串，只支持布尔值axes[0].set_xticks( x[::10]) #设置步长axes[0].set_xticklabels(x_label[::5]) #设置字符串名axes[0].set_yticks(z[::5])axes[1].set_xticks( x[::10]) #设置步长axes[1].set_xticklabels(x_label[::5]) #设置字符串名axes[1].set_yticks(z[::5])#添加网格信息axes[0].grid(True, linestyle='--', alpha=0.5) #默认是True，风格设置为虚线，alpha为透明度axes[1].grid(True, linestyle='--', alpha=0.5)#添加标题axes[0].set_xlabel('Time')axes[0].set_ylabel('Temperature')axes[0].set_title("Curve of ShangHai's Temperature Change with Time")axes[1].set_xlabel('Time')axes[1].set_ylabel('Temperature')axes[1].set_title("Curve of BeiJing's Temperature Change with Time")plt.savefig('./plt_png/test1.4.png')plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">@ 绘制数学函数图像import numpy as np#准备数据x = np.linspace(-1,1,1000) #在-1至1之间等距生成1000个数y = 2*x*x#绘制画布#折线图plotplt.figure(figsize=(12,8), dpi=80)plt.plot( x, y, color='b', label='Y=2*X^2' )plt.legend()plt.grid(True, linestyle='--', alpha=0.5)plt.savefig('./plt_png/test1.5.png')plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="plot"><a class="markdownIt-Anchor" href="#plot"></a> plot</h4><p><strong>画单条线</strong><br>plt.plot([x], y, [fmt], *, data=None, **kwargs)<br><strong>画多条线</strong><br>plt.plot([x], y, [fmt], [x2], y2, [fmt2], …, **kwargs)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plot(x, y)        # 创建 y 中数据与 x 中对应值的二维线图，使用默认样式plot(x, y, 'bo')  # 创建 y 中数据与 x 中对应值的二维线图，使用蓝色实心圈绘制plot(y)           # x 的值为 0..N-1plot(y, 'r+')     # 使用红色 + 号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>颜色字符：</strong>‘b’ 蓝色，‘m’ 洋红色，‘g’ 绿色，‘y’ 黄色，‘r’ 红色，‘k’ 黑色，‘w’ 白色，‘c’ 青绿色，’#008000’ RGB 颜色符串。多条曲线不指定颜色时，会自动选择不同颜色。</p><p><strong>线型参数：</strong>’‐’ 实线，’‐‐’ 破折线，’‐.’ 点划线，’:’ 虚线。</p><p><strong>标记字符：</strong>’.’ 点标记，’,’ 像素标记(极小点)，‘o’ 实心圈标记，‘v’ 倒三角标记，’^’ 上三角标记，’&gt;’ 右三角标记，’&lt;’ 左三角标记…等等。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import matplotlib.pyplot as pltimport numpy as np# 绘制正弦 余弦曲线x = np.arange(0,4*np.pi,0.1)   # start,stop,stepy = np.sin(x)z = np.cos(x)plt.plot(x,y,x,z)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>红蓝颜色反转问题</strong></p><p>原因在于[ skimage.io.imread ](<a href="http://scikit-image.org/docs/dev/api/skimage.io.html">http://scikit-image.org/docs/dev/api/skimage.io.html</a> #skimage.io.imread)将图像加载为RGB(或RGBA)，但是OpenCV假定图像为[ BGR或BGRA ]( <a href="http://docs.opencv.org">http://docs.opencv.org</a> /trunk/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce)(BGR是默认的OpenCV颜色格式).这意味着蓝色和红色飞机会翻转</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 出现问题的读取-保存方法import skimage.ioimport cv2img = skimage.io.imread('sample.png')cv2.imwrite('sample_out_1.png', img)# 解决办法1 - 保存图片时转换格式import skimage.ioimport cv2img = skimage.io.imread('sample.png')cv2.imwrite('sample_out_2.png', cv2.cvtColor(img, cv2.COLOR_RGB2BGR))  # 解决办法2 - 使用cv读写文件import cv2img = cv2.imread('sample.png')cv2.imwrite('sample_out_3.png', img)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="画直方图"><a class="markdownIt-Anchor" href="#画直方图"></a> 画直方图</h3><p><strong>灰度直方图</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npimport matplotlib.pyplot as pltimg=np.array(array）    #array是自己的一维数组，用np.array()将此数组变为numpy下的数组plt.figure("lena")           #定义了画板arr=img.flatten()          #若上面的array不是一维数组，flatten()将其变为一维数组，是numpy中的函数#hist函数可以直接绘制直方图#参数有四个，第一个必选#arr: 需要计算直方图的一维数组#bins: 直方图的柱数，可选项，默认为10#normed: 是否将得到的直方图向量归一化。默认为0#facecolor: 直方图颜色#alpha: 透明度#返回值为n: 直方图向量，是否归一化由参数设定；bins: 返回各个bin的区间范围；patches: 返回每个bin里面包含的数据，是一个listn, bins, patches = plt.hist(arr, bins=256, normed=1, facecolor='green', alpha=0.75)  plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>彩色直方图</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">src = Image.open("./testImg/1.jpg")r,g,b=src.split()plt.figure("lena")ar=np.array(r).flatten()plt.hist(ar, bins=256, normed=1,facecolor='r',edgecolor='r',hold=1)ag=np.array(g).flatten()plt.hist(ag, bins=256, normed=1, facecolor='g',edgecolor='g',hold=1)ab=np.array(b).flatten()plt.hist(ab, bins=256, normed=1, facecolor='b',edgecolor='b')plt.show()————————————————版权声明：本文为CSDN博主「disasters」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/disasters/article/details/85017315<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图像识别"><a class="markdownIt-Anchor" href="#图像识别"></a> 图像识别</h2><p>查看像素RGB值，灰度值，HSV值</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding:utf-8 -*-import cv2img = cv2.imread('11_13/120002.jpg')gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)def mouse_click(event, x, y, flags, para):  if event == cv2.EVENT_LBUTTONDOWN:  # 左边鼠标点击    print('PIX:', x, y)    print("BGR:", img[y, x])    print("GRAY:", gray[y, x])    print("HSV:", hsv[y, x])    if __name__ == '__main__':      cv2.namedWindow("img")      cv2.setMouseCallback("img", mouse_click)      while True:        cv2.imshow('img', img)        if cv2.waitKey() == ord('q'):          break          cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高斯滤波"><a class="markdownIt-Anchor" href="#高斯滤波"></a> 高斯滤波</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODE0NTMxNw==,size_16,color_FFFFFF,t_70.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from scipy.ndimage import gaussian_filterimport cv2import matplotlib.pyplot as plta =cv2.imread('./test_images/33.jpeg')result = gaussian_filter(a, sigma=5)plt.subplot(1,2,1)plt.imshow(a)plt.subplot(1,2,2)plt.imshow(result)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="bfmatcher匹配特征点"><a class="markdownIt-Anchor" href="#bfmatcher匹配特征点"></a> BFMatcher匹配特征点</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2from matplotlib import pyplot as plt  #读取需要特征匹配的两张照片，格式为灰度图。img1=cv2.imread("water1.jpg",0)img2=cv2.imread("water2.jpg",0) #BFMatcher匹配orb=cv2.ORB_create()#建立orb特征检测器kp1,des1=orb.detectAndCompute(img1,None)#计算img1中的特征点和描述子kp2,des2=orb.detectAndCompute(img2,None) #计算img2中的 bf = cv2.BFMatcher(cv2.NORM_HAMMING,crossCheck=True) #建立匹配关系mathces=bf.match(des1,des2) #匹配描述子mathces=sorted(mathces,key=lambda x:x.distance) #据距离来排序 outImg = Noneimg3 = cv2.drawMatches(img1=img1,                       keypoints1=kp1,                       img2=img2,                       keypoints2=kp2,                       matches1to2=mathces[:40],                       outImg = None) #画出匹配关系 plt.imshow(img3)plt.show() <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/dd203d6a29c42a6fa1892439ee41d5f9.png" alt="dd203d6a29c42a6fa1892439ee41d5f9.png"></p><h3 id="sift"><a class="markdownIt-Anchor" href="#sift"></a> SIFT</h3><p>图像缩放、旋转保持不变性的图像局部特征描述算子</p><p><strong>示例使用方法</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-from pylab import *from PIL import Imagefrom PCV.localdescriptors import siftfrom PCV.tools import imtoolsimport pydot""" This is the example graph illustration of matching images from Figure 2-10.To download the images, see ch2_download_panoramio.py."""#download_path = "panoimages"  # set this to the path where you downloaded the panoramio images#path = "/FULLPATH/panoimages/"  # path to save thumbnails (pydot needs the full system path)#download_path = "F:\\dropbox\\Dropbox\\translation\\pcv-notebook\\data\\panoimages"  # set this to the path where you downloaded the panoramio images#path = "F:\\dropbox\\Dropbox\\translation\\pcv-notebook\\data\\panoimages\\"  # path to save thumbnails (pydot needs the full system path)download_path = "D:/new"path = "D:/new"# list of downloaded filenamesimlist = imtools.get_imlist(download_path)nbr_images = len(imlist)# extract featuresfeatlist = [imname[:-3] + 'sift' for imname in imlist]for i, imname in enumerate(imlist):    sift.process_image(imname, featlist[i])matchscores = zeros((nbr_images, nbr_images))for i in range(nbr_images):    for j in range(i, nbr_images):  # only compute upper triangle        print 'comparing ', imlist[i], imlist[j]        l1, d1 = sift.read_features_from_file(featlist[i])        l2, d2 = sift.read_features_from_file(featlist[j])        matches = sift.match_twosided(d1, d2)        nbr_matches = sum(matches &gt; 0)        print 'number of matches = ', nbr_matches        matchscores[i, j] = nbr_matchesprint "The match scores is: %d", matchscores#np.savetxt(("../data/panoimages/panoramio_matches.txt",matchscores)# copy valuesfor i in range(nbr_images):    for j in range(i + 1, nbr_images):  # no need to copy diagonal        matchscores[j, i] = matchscores[i, j]threshold = 2  # min number of matches needed to create linkg = pydot.Dot(graph_type='graph')  # don't want the default directed graphfor i in range(nbr_images):    for j in range(i + 1, nbr_images):        if matchscores[i, j] &gt; threshold:            # first image in pair            im = Image.open(imlist[i])            im.thumbnail((100, 100))            filename = path + str(i) + '.png'            im.save(filename)  # need temporary files of the right size            g.add_node(pydot.Node(str(i), fontcolor='transparent', shape='rectangle', image=filename))            # second image in pair            im = Image.open(imlist[j])            im.thumbnail((100, 100))            filename = path + str(j) + '.png'            im.save(filename)  # need temporary files of the right size            g.add_node(pydot.Node(str(j), fontcolor='transparent', shape='rectangle', image=filename))            g.add_edge(pydot.Edge(str(i), str(j)))g.write_png('protect2.png')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SIFT算法代码实现</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-from PIL import Imagefrom pylab import *from PCV.localdescriptors import siftfrom PCV.localdescriptors import harris# 添加中文字体支持from matplotlib.font_manager import FontPropertiesfont = FontProperties(fname=r"c:\windows\fonts\SimSun.ttc", size=14)imname = 'siftt/24.jpg'im = array(Image.open(imname).convert('L'))sift.process_image(imname, '24.sift')l1, d1 = sift.read_features_from_file('24.sift')figure()gray()subplot(131)sift.plot_features(im, l1, circle=False)title(u'SIFT特征',fontproperties=font)subplot(132)sift.plot_features(im, l1, circle=True)title(u'用圆圈表示SIFT特征尺度',fontproperties=font)# 检测harris角点harrisim = harris.compute_harris_response(im)subplot(133)filtered_coords = harris.get_harris_points(harrisim, 6, 0.1)imshow(im)plot([p[1] for p in filtered_coords], [p[0] for p in filtered_coords], '*')axis('off')title(u'Harris角点',fontproperties=font)show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图像集里的所有图像的sift特征提取</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-from PIL import Imagefrom pylab import *from PCV.localdescriptors import siftfrom PCV.localdescriptors import harrisfrom PCV.tools.imtools import get_imlist # 导入原书的PCV模块# 添加中文字体支持from matplotlib.font_manager import FontPropertiesfont = FontProperties(fname=r"c:\windows\fonts\SimSun.ttc", size=14)# 获取project2_data文件夹下的图片文件名(包括后缀名)filelist = get_imlist('siftt/')for infile in filelist: # 对文件夹下的每张图片进行如下操作    print(infile) # 输出文件名    im = array(Image.open(infile).convert('L'))    sift.process_image(infile, 'infile.sift')    l1, d1 = sift.read_features_from_file('infile.sift')    i=1    figure(i)    i=i+1    gray()    subplot(131)    sift.plot_features(im, l1, circle=False)    title(u'SIFT特征',fontproperties=font)    subplot(132)    sift.plot_features(im, l1, circle=True)    title(u'用圆圈表示SIFT特征尺度',fontproperties=font)    # 检测harris角点    harrisim = harris.compute_harris_response(im)    subplot(133)    filtered_coords = harris.get_harris_points(harrisim, 6, 0.1)    imshow(im)    plot([p[1] for p in filtered_coords], [p[0] for p in filtered_coords], '*')    axis('off')    title(u'Harris角点',fontproperties=font)    show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两张图片，计算sift特征匹配结果</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-from PIL import Imagefrom pylab import *from numpy import *import osdef process_image(imagename, resultname, params="--edge-thresh 10 --peak-thresh 5"):    """ 处理一幅图像，然后将结果保存在文件中"""    if imagename[-3:] != 'pgm':        #创建一个pgm文件        im = Image.open(imagename).convert('L')        im.save('tmp.pgm')        imagename ='tmp.pgm'    cmmd = str("sift "+imagename+" --output="+resultname+" "+params)    os.system(cmmd)    print 'processed', imagename, 'to', resultnamedef read_features_from_file(filename):    """读取特征属性值，然后将其以矩阵的形式返回"""    f = loadtxt(filename)    return f[:,:4], f[:,4:] #特征位置，描述子def write_featrues_to_file(filename, locs, desc):    """将特征位置和描述子保存到文件中"""    savetxt(filename, hstack((locs,desc)))def plot_features(im, locs, circle=False):    """显示带有特征的图像       输入：im（数组图像），locs（每个特征的行、列、尺度和朝向）"""    def draw_circle(c,r):        t = arange(0,1.01,.01)*2*pi        x = r*cos(t) + c[0]        y = r*sin(t) + c[1]        plot(x, y, 'b', linewidth=2)    imshow(im)    if circle:        for p in locs:            draw_circle(p[:2], p[2])    else:        plot(locs[:,0], locs[:,1], 'ob')    axis('off')def match(desc1, desc2):    """对于第一幅图像中的每个描述子，选取其在第二幅图像中的匹配    输入：desc1(第一幅图像中的描述子)，desc2(第二幅图像中的描述子)"""    desc1 = array([d/linalg.norm(d) for d in desc1])    desc2 = array([d/linalg.norm(d) for d in desc2])    dist_ratio = 0.6    desc1_size = desc1.shape    matchscores = zeros((desc1_size[0],1),'int')    desc2t = desc2.T #预先计算矩阵转置    for i in range(desc1_size[0]):        dotprods = dot(desc1[i,:],desc2t) #向量点乘        dotprods = 0.9999*dotprods        # 反余弦和反排序，返回第二幅图像中特征的索引        indx = argsort(arccos(dotprods))        #检查最近邻的角度是否小于dist_ratio乘以第二近邻的角度        if arccos(dotprods)[indx[0]] &lt; dist_ratio * arccos(dotprods)[indx[1]]:            matchscores[i] = int(indx[0])    return matchscoresdef match_twosided(desc1, desc2):    """双向对称版本的match()"""    matches_12 = match(desc1, desc2)    matches_21 = match(desc2, desc1)    ndx_12 = matches_12.nonzero()[0]    # 去除不对称的匹配    for n in ndx_12:        if matches_21[int(matches_12[n])] != n:            matches_12[n] = 0    return matches_12def appendimages(im1, im2):    """返回将两幅图像并排拼接成的一幅新图像"""    #选取具有最少行数的图像，然后填充足够的空行    rows1 = im1.shape[0]    rows2 = im2.shape[0]    if rows1 &lt; rows2:        im1 = concatenate((im1, zeros((rows2-rows1,im1.shape[1]))),axis=0)    elif rows1 &gt;rows2:        im2 = concatenate((im2, zeros((rows1-rows2,im2.shape[1]))),axis=0)    return concatenate((im1,im2), axis=1)def plot_matches(im1,im2,locs1,locs2,matchscores,show_below=True):    """ 显示一幅带有连接匹配之间连线的图片        输入：im1, im2(数组图像), locs1,locs2（特征位置）,matchscores(match()的输出)，        show_below（如果图像应该显示在匹配的下方）    """    im3=appendimages(im1, im2)    if show_below:        im3=vstack((im3, im3))    imshow(im3)    cols1 = im1.shape[1]    for i in range(len(matchscores)):        if matchscores[i]&gt;0:            plot([locs1[i,0],locs2[matchscores[i,0],0]+cols1], [locs1[i,1],locs2[matchscores[i,0],1]],'c')    axis('off')im1f = 'siftt/25.jpg'im2f = 'siftt/26.jpg'im1 = array(Image.open(im1f))im2 = array(Image.open(im2f))process_image(im1f, 'out_sift_1.txt')l1,d1 = read_features_from_file('out_sift_1.txt')figure()gray()subplot(121)plot_features(im1, l1, circle=False)process_image(im2f, 'out_sift_2.txt')l2,d2 = read_features_from_file('out_sift_2.txt')subplot(122)plot_features(im2, l2, circle=False)matches = match_twosided(d1, d2)print '{} matches'.format(len(matches.nonzero()[0]))figure()gray()plot_matches(im1, im2, l1, l2, matches, show_below=True)show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给定一张图片，输出匹配度最高的三张图片</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-from PIL import Imagefrom pylab import *from numpy import *import osfrom PCV.tools.imtools import get_imlist # 导入原书的PCV模块import matplotlib.pyplot as plt # plt 用于显示图片import matplotlib.image as mpimg # mpimg 用于读取图片def process_image(imagename, resultname, params="--edge-thresh 10 --peak-thresh 5"):    """ 处理一幅图像，然后将结果保存在文件中"""    if imagename[-3:] != 'pgm':        #创建一个pgm文件        im = Image.open(imagename).convert('L')        im.save('tmp.pgm')        imagename ='tmp.pgm'    cmmd = str("sift "+imagename+" --output="+resultname+" "+params)    os.system(cmmd)    print 'processed', imagename, 'to', resultnamedef read_features_from_file(filename):    """读取特征属性值，然后将其以矩阵的形式返回"""    f = loadtxt(filename)    return f[:,:4], f[:,4:] #特征位置，描述子def write_featrues_to_file(filename, locs, desc):    """将特征位置和描述子保存到文件中"""    savetxt(filename, hstack((locs,desc)))def plot_features(im, locs, circle=False):    """显示带有特征的图像       输入：im（数组图像），locs（每个特征的行、列、尺度和朝向）"""    def draw_circle(c,r):        t = arange(0,1.01,.01)*2*pi        x = r*cos(t) + c[0]        y = r*sin(t) + c[1]        plot(x, y, 'b', linewidth=2)    imshow(im)    if circle:        for p in locs:            draw_circle(p[:2], p[2])    else:        plot(locs[:,0], locs[:,1], 'ob')    axis('off')def match(desc1, desc2):    """对于第一幅图像中的每个描述子，选取其在第二幅图像中的匹配    输入：desc1(第一幅图像中的描述子)，desc2(第二幅图像中的描述子)"""    desc1 = array([d/linalg.norm(d) for d in desc1])    desc2 = array([d/linalg.norm(d) for d in desc2])    dist_ratio = 0.6    desc1_size = desc1.shape    matchscores = zeros((desc1_size[0],1),'int')    desc2t = desc2.T #预先计算矩阵转置    for i in range(desc1_size[0]):        dotprods = dot(desc1[i,:],desc2t) #向量点乘        dotprods = 0.9999*dotprods        # 反余弦和反排序，返回第二幅图像中特征的索引        indx = argsort(arccos(dotprods))        #检查最近邻的角度是否小于dist_ratio乘以第二近邻的角度        if arccos(dotprods)[indx[0]] &lt; dist_ratio * arccos(dotprods)[indx[1]]:            matchscores[i] = int(indx[0])    return matchscoresdef match_twosided(desc1, desc2):    """双向对称版本的match()"""    matches_12 = match(desc1, desc2)    matches_21 = match(desc2, desc1)    ndx_12 = matches_12.nonzero()[0]    # 去除不对称的匹配    for n in ndx_12:        if matches_21[int(matches_12[n])] != n:            matches_12[n] = 0    return matches_12def appendimages(im1, im2):    """返回将两幅图像并排拼接成的一幅新图像"""    #选取具有最少行数的图像，然后填充足够的空行    rows1 = im1.shape[0]    rows2 = im2.shape[0]    if rows1 &lt; rows2:        im1 = concatenate((im1, zeros((rows2-rows1,im1.shape[1]))),axis=0)    elif rows1 &gt;rows2:        im2 = concatenate((im2, zeros((rows1-rows2,im2.shape[1]))),axis=0)    return concatenate((im1,im2), axis=1)def plot_matches(im1,im2,locs1,locs2,matchscores,show_below=True):    """ 显示一幅带有连接匹配之间连线的图片        输入：im1, im2(数组图像), locs1,locs2（特征位置）,matchscores(match()的输出)，        show_below（如果图像应该显示在匹配的下方）    """    im3=appendimages(im1, im2)    if show_below:        im3=vstack((im3, im3))    imshow(im3)    cols1 = im1.shape[1]    for i in range(len(matchscores)):        if matchscores[i]&gt;0:            plot([locs1[i,0],locs2[matchscores[i,0],0]+cols1], [locs1[i,1],locs2[matchscores[i,0],1]],'c')    axis('off')# 获取project2_data文件夹下的图片文件名(包括后缀名)filelist = get_imlist('project2_data/')# 输入的图片im1f = '23.jpg'im1 = array(Image.open(im1f))process_image(im1f, 'out_sift_1.txt')l1, d1 = read_features_from_file('out_sift_1.txt')i=0num = [0]*30    #存放匹配值for infile in filelist: # 对文件夹下的每张图片进行如下操作    im2 = array(Image.open(infile))    process_image(infile, 'out_sift_2.txt')    l2, d2 = read_features_from_file('out_sift_2.txt')    matches = match_twosided(d1, d2)    num[i] = len(matches.nonzero()[0])    i=i+1    print '{} matches'.format(num[i-1])  #输出匹配值i=1figure()while i&lt;4: #循环三次，输出匹配最多的三张图片    index=num.index(max(num))    print index, filelist[index]    lena = mpimg.imread(filelist[index])  # 读取当前匹配最大值的图片    # 此时 lena 就已经是一个 np.array 了，可以对它进行任意处理    # lena.shape  # (512, 512, 3)    subplot(1,3,i)    plt.imshow(lena)  # 显示图片    plt.axis('off')  # 不显示坐标轴    num[index] = 0  #将当前最大值清零    i=i+1show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>本文参考链接</strong></p><p><a href="http://RUNOOB.COM">RUNOOB.COM</a> Matplotlib Pyplot<br><a href="https://www.runoob.com/matplotlib/matplotlib-pyplot.html">https://www.runoob.com/matplotlib/matplotlib-pyplot.html</a></p><p>「机器学习_9」 Backpropagation<br><a href="https://blog.csdn.net/qq_36098284/article/details/105891937">https://blog.csdn.net/qq_36098284/article/details/105891937</a></p><p>python opencv查看图片中任一点的像素 BGR值 灰度值 HSV值<br><a href="https://blog.csdn.net/sinat_36811967/article/details/84347290">https://blog.csdn.net/sinat_36811967/article/details/84347290</a></p><p>Python深度学习入门之plt画图工具基础使用（注释详细，超级简单）<br><a href="https://blog.csdn.net/weixin_44414948/article/details/109703153?utm_term=Pythonplt%E6%96%B0%E7%94%BB%E5%9B%BE&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2">https://blog.csdn.net/weixin_44414948/article/details/109703153?utm_term=Pythonplt新画图&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2</a><sub>all</sub>sobaiduweb~default-2-109703153&amp;spm=3001.4430</p><p>matplotlib画直线图的基本用法<br><a href="https://www.cnblogs.com/heguihui/p/12181529.html">https://www.cnblogs.com/heguihui/p/12181529.html</a></p><p>用matplotlib根据一维数组画直方图<br><a href="https://blog.csdn.net/disasters/article/details/85017315">https://blog.csdn.net/disasters/article/details/85017315</a></p><p>Python-OpenCV中的filter2D()函数实现图像变化<br><a href="https://zhuanlan.zhihu.com/p/288718974">https://zhuanlan.zhihu.com/p/288718974</a></p><p>高斯滤波gaussian_filter()<br><a href="https://blog.csdn.net/weixin_38145317/article/details/103734342">https://blog.csdn.net/weixin_38145317/article/details/103734342</a></p><p>numpy之数组的赋值<br><a href="https://blog.csdn.net/PJCKR/article/details/95453642">https://blog.csdn.net/PJCKR/article/details/95453642</a></p><p>BFMatcher匹配特征点<br><a href="https://blog.csdn.net/weixin_42388898/article/details/113090103">https://blog.csdn.net/weixin_42388898/article/details/113090103</a></p><p>OpenCV学习笔记-brute_force特征匹配<br><a href="https://blog.csdn.net/qq_36387683/article/details/80577737">https://blog.csdn.net/qq_36387683/article/details/80577737</a></p><p>python—sift特征提取<br><a href="https://www.cnblogs.com/wyf-1999-1--6/p/12455251.html">https://www.cnblogs.com/wyf-1999-1--6/p/12455251.html</a></p><p>高斯滤波gaussian_filter()<br><a href="https://blog.csdn.net/weixin_38145317/article/details/103734342">https://blog.csdn.net/weixin_38145317/article/details/103734342</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持续更新 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程决策结构（3）</title>
      <link href="/2021/10/01/unsw/gsoe9210/gong-cheng-jue-ce-jie-gou-3/"/>
      <url>/2021/10/01/unsw/gsoe9210/gong-cheng-jue-ce-jie-gou-3/</url>
      
        <content type="html"><![CDATA[<h2 id="week-3"><a class="markdownIt-Anchor" href="#week-3"></a> Week 3</h2><h3 id="lesson-1-visualisation-可视化"><a class="markdownIt-Anchor" href="#lesson-1-visualisation-可视化"></a> Lesson 1: Visualisation 可视化</h3><h4 id="visualisation-state-space-可视化状态空间"><a class="markdownIt-Anchor" href="#visualisation-state-space-可视化状态空间"></a> Visualisation: state space 可视化:状态空间</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211001141956047.png" alt="image-20211001141956047"></p><h4 id="indifference-curves-maximin-无差异曲线极大极小"><a class="markdownIt-Anchor" href="#indifference-curves-maximin-无差异曲线极大极小"></a> Indifference curves: <em>Maximin</em>  无差异曲线:极大极小</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211001142441143.png" alt="image-20211001142441143"></p><h4 id="visualising-regret-想象后悔"><a class="markdownIt-Anchor" href="#visualising-regret-想象后悔"></a> Visualising regret 想象后悔</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211001142556905.png" alt="image-20211001142556905"></p><h3 id="lesson-2-introduction-to-mixed-actions-混合动作的介绍"><a class="markdownIt-Anchor" href="#lesson-2-introduction-to-mixed-actions-混合动作的介绍"></a> Lesson 2: Introduction to mixed actions 混合动作的介绍</h3><h4 id="river-delivery-河流交付问题"><a class="markdownIt-Anchor" href="#river-delivery-河流交付问题"></a> River delivery 河流交付问题</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211001143223508.png" alt="image-20211001143223508"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211001143237460.png" alt="image-20211001143237460"></p><p><img src="/Users/yinkejian/Pictures/typora//Users/yinkejian/Pictures/typora.png" alt="/Users/yinkejian/Pictures/typora"></p><h4 id="multiple-deliveries-多个交付"><a class="markdownIt-Anchor" href="#multiple-deliveries-多个交付"></a> Multiple deliveries 多个交付</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211001143451025.png" alt="image-20211001143451025"></p><h3 id="lesson-3-mixture-analysis-混合物的分析"><a class="markdownIt-Anchor" href="#lesson-3-mixture-analysis-混合物的分析"></a> Lesson 3: Mixture analysis 混合物的分析</h3><h4 id="mixtures-and-maximin-混合物和极大极小"><a class="markdownIt-Anchor" href="#mixtures-and-maximin-混合物和极大极小"></a> Mixtures and Maximin 混合物和极大极小</h4><p>Mixtures:</p><p><em>M</em>(<em>µ</em>) = <em>µ</em>A + (1 -<em>µ</em>)B</p><p><em>M</em>(1) = A; <em>M</em>(0) = B</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211001145050274.png" alt="image-20211001145050274"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211001145129784.png" alt="image-20211001145129784"></p><h4 id="many-action-mixtures-许多动作混合物"><a class="markdownIt-Anchor" href="#many-action-mixtures-许多动作混合物"></a> Many-action mixtures 许多动作混合物</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211001145258264.png" alt="image-20211001145258264"></p><h4 id="mixed-strategy-dominance-混合策略优势"><a class="markdownIt-Anchor" href="#mixed-strategy-dominance-混合策略优势"></a> Mixed strategy dominance 混合策略优势</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211001145357385.png" alt="image-20211001145357385"></p><h2 id="week-4"><a class="markdownIt-Anchor" href="#week-4"></a> Week 4</h2><h3 id="lesson-1-introducing-likelihoods"><a class="markdownIt-Anchor" href="#lesson-1-introducing-likelihoods"></a> Lesson 1: Introducing likelihoods</h3><p>Uncertainty vs likelihoods 不确定性和可能性</p><p>‘One shot’ decision</p><p>Future period = one day (fuel consumed):</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009002030235.png" alt="image-20211009002030235"></p><p>Fuel <em>saved</em> (4L tank):</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009002054994.png" alt="image-20211009002054994"></p><p>Short to long term</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009002117224.png" alt="image-20211009002117224"></p><h3 id="lesson-2-bayes-decisions"><a class="markdownIt-Anchor" href="#lesson-2-bayes-decisions"></a> Lesson 2: Bayes decisions</h3><p><em>Bayes</em> decision rule</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009002308942.png" alt="image-20211009002308942"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009002318852.png" alt="image-20211009002318852"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009002326484.png" alt="image-20211009002326484"></p><h3 id="bayes-indifffference-curves-贝叶斯无差异曲线"><a class="markdownIt-Anchor" href="#bayes-indifffference-curves-贝叶斯无差异曲线"></a> <em>Bayes</em> indifffference curves 贝叶斯无差异曲线</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009002456359.png" alt="image-20211009002456359"></p><h3 id="lesson-3-bayesian-decision-analysis"><a class="markdownIt-Anchor" href="#lesson-3-bayesian-decision-analysis"></a> Lesson 3: Bayesian decision analysis</h3><p>mixtures possible</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009003231318.png" alt="image-20211009003231318"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009003241618.png" alt="image-20211009003241618"></p><p>probability plot</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20211009003355440.png" alt="image-20211009003355440"></p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> GSOE9210 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉课程笔记（2）</title>
      <link href="/2021/09/27/unsw/comp9517/ji-suan-ji-shi-jue-ke-cheng-bi-ji-2/"/>
      <url>/2021/09/27/unsw/comp9517/ji-suan-ji-shi-jue-ke-cheng-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<h2 id="image-processing-ii-图像处理二"><a class="markdownIt-Anchor" href="#image-processing-ii-图像处理二"></a> Image Processing II 图像处理二</h2><h3 id="types-of-image-processing-recap-图像处理的类型概述"><a class="markdownIt-Anchor" href="#types-of-image-processing-recap-图像处理的类型概述"></a> Types of image processing (recap) 图像处理的类型(概述)</h3><ul><li>Two main types of image processing operations:</li></ul><p>– Spatial domain operations (in image space) 空间域操作(图像空间)</p><p>– Frequency domain operations (mainly in Fourier space) 频域操作(主要在傅里叶空间)</p><ul><li>Two main types of spatial domain operations:</li></ul><p>– Point operations (intensity transformations on individual pixels) 点操作(对单个像素的强度转换)</p><p>– Neighbourhood operations (spatial filtering on groups of pixels) 邻域操作(对像素组进行空间滤波)</p><p><strong>Point operations 点操作</strong></p><p><strong>Neighbourhood operations 临接点操作</strong></p><h3 id="recap-回顾"><a class="markdownIt-Anchor" href="#recap-回顾"></a> Recap 回顾</h3><p>Spatial domain, intensity transformations (on single pixels)</p><p>• Image thresholding</p><p>​• Otsu’s method</p><p>​• Histogram thresholding</p><p>​• Multiband thresholding</p><p>• Image inversion</p><p>• Log transform</p><p>• Power-law</p><p>• Averaging</p><p>• Piecewise-linear transformation 分段线性变换</p><p>​• Contrast stretching 对比度拉伸</p><p>​• Gray-level slicing 灰度分割</p><p>​• Bit-plane slicing 位平面切片</p><p>• Histogram processing 直方图处理</p><p>​• Histogram equalization 直方图均衡化</p><p>​• Histogram matching 直方图匹配</p><h3 id="spatial-filtering-空间滤波"><a class="markdownIt-Anchor" href="#spatial-filtering-空间滤波"></a> Spatial Filtering 空间滤波</h3><p>These methods use a small <strong>neighbourhood</strong> of a pixel in the input image to produce a new brightness value for that pixel</p><p>Also called <strong>filtering</strong> techniques</p><p>Neighbourhood of (𝑥, 𝑦) is usually a square or rectangular subimage centred at (𝑥, 𝑦) called <strong>filter</strong> <em>/</em> <strong>mask</strong> <em>/</em> <strong>kernel</strong> <em>/</em> <strong>template</strong> <em>/</em> <strong>window</strong></p><p>A <strong>linear transformation</strong> calculates a value in the output image 𝑔(𝑖,𝑗) as a linear combination of brightnesses in a local neighbourhood of the pixel in the input image 𝑓(𝑖,𝑗) weighted by coefficients ℎ:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927105527427.png" alt="image-20210927105527427"></p><p>This is called a <strong>discrete convolution</strong> with a convolution mask ℎ 这被称为带有卷积掩码ℎ的离散卷积</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927110137240.png" alt="image-20210927110137240"></p><h3 id="smoothing-spatial-filters-平滑空间过滤器"><a class="markdownIt-Anchor" href="#smoothing-spatial-filters-平滑空间过滤器"></a> Smoothing Spatial Filters 平滑空间过滤器</h3><p>Used for image blurring and noise reduction 用于图像模糊和降噪</p><p><strong>Neighbourhood Averaging (Mean Filter) 邻域平均(均值滤波)</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927110250463.png" alt="image-20210927110250463"></p><p>Replace intensity at pixel (𝑥𝑥, 𝑦𝑦) with the <strong>average</strong> of the intensities in a neighbourhood of (𝑥𝑥, 𝑦𝑦)</p><p>We can also use a <strong>weighted average</strong>, giving more importance to some pixels over others in the neighbourhood- reduces blurring</p><p>Neighbourhood averaging blurs edges</p><h3 id="chapter-3-image-enhancement-in-the-spatial-domain-空间域图像增强"><a class="markdownIt-Anchor" href="#chapter-3-image-enhancement-in-the-spatial-domain-空间域图像增强"></a> Chapter 3 Image Enhancement in the Spatial Domain 空间域图像增强</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927111145905.png" alt="image-20210927111145905"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927111221584.png" alt="image-20210927111221584"></p><h4 id="another-example"><a class="markdownIt-Anchor" href="#another-example"></a> Another Example</h4><p>考虑一幅强度恒定的图像，与背景强度不同的像素被广泛隔离。我们希望检测这些像素。</p><p><strong>Smoothing Spatial Filters 平滑空间过滤器</strong></p><p>• <strong>Aim:</strong> To suppress noise, other small fluctuations in image- may be result of sampling, quantization, transmission, environment disturbances during acquisition</p><p>•**目的：**为了抑制噪声，图像中的其他小波动——可能是采集过程中采样、量化、传输、环境干扰的结果</p><p>• Uses redundancy in the image data</p><p>• May blur sharp edges, so care is needed</p><h3 id="gaussian-filter-高斯滤波器"><a class="markdownIt-Anchor" href="#gaussian-filter-高斯滤波器"></a> Gaussian Filter 高斯滤波器</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927113428777.png" alt="image-20210927113428777"></p><p>Replace intensity at pixel (𝑥, 𝑦) with the <strong>weighted average</strong> of the intensities in a neighbourhood of (𝑥, 𝑦)</p><p>将像素(𝑥，𝑦)的强度替换为(𝑥，𝑦)附近强度的<strong>加权平均</strong></p><p>It is a set of weights that approximate the profile of a Gaussian function 它是一组近似高斯函数轮廓的权值</p><p>It is very effective in reducing noise and also reducing details (image blurring) 它在降低噪声和细节（图像模糊）方面非常有效。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927114123358.png" alt="image-20210927114123358"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927114123358.png" alt="image-20210927114123358"></p><p><strong>Many nice properties motivate the use of the Gaussian filter</strong></p><p>• It is the only filter that is both separable and circularly symmetric</p><p>• It has optimal space-frequency localization</p><p>• The Fourier transform of a Gaussian is also a Gaussian function</p><p>• The <em>n</em>-fold convolution of <em>any</em> low-pass filter converges to a Gaussian</p><p>• It is infinitely smooth so it can be differentiated to any desired degree</p><p>• It scales naturally (sigma) and allows for consistent scale-space theory</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927114304663.png" alt="image-20210927114304663"></p><h4 id="nonlinear-spatial-filters-非线性空间过滤器"><a class="markdownIt-Anchor" href="#nonlinear-spatial-filters-非线性空间过滤器"></a> Nonlinear Spatial Filters 非线性空间过滤器</h4><p>Also called order-statistics filters, response based on ordering the pixels in the neighbourhood and replacing centre pixel with the ranking result</p><p>也称为顺序统计过滤器，基于邻域像素的排序和用排序结果替换中心像素的响应</p><p><strong>Median Filter 中值滤波器</strong></p><p>• intensity of each pixel is replaced by the <em>median</em> of the intensities in neighbourhood of that pixel</p><p>• Median M of a set of values is the middle value such that half the values in the set are less than M and the other half greater than M</p><p>• Median filtering forces points with distinct intensities to be more like their neighbours, thus eliminating isolated intensity spikes</p><p>• Also, isolated pixel clusters (light or dark), whose area is ≤ 𝑛^2 / 2 are eliminated by an 𝑛 × 𝑛 median filter</p><p>• Good for impulse noise (salt-and-pepper noise)</p><p>• Other examples of order-statistics filters are max and min filters</p><h3 id="chapter-3-image-enhancement-in-the-spatial-domain-空间域图像增强-2"><a class="markdownIt-Anchor" href="#chapter-3-image-enhancement-in-the-spatial-domain-空间域图像增强-2"></a> Chapter 3 Image Enhancement in the Spatial Domain 空间域图像增强</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927142351484.png" alt="image-20210927142351484"></p><h3 id="pooling-联营合并"><a class="markdownIt-Anchor" href="#pooling-联营合并"></a> pooling 联营，合并</h3><p>Max / average / median pooling 最大/平均/中值池</p><p>− Provides translation invariance 提供平移不变性</p><p>− Reduces computations 减少计算</p><p>− Popular in deep convolutional neural networks (deep learning) 在深度卷积神经网络(深度学习)中流行</p><h4 id="sharpening-spatial-filters-edge-detection-锐化空间滤波器边缘检测"><a class="markdownIt-Anchor" href="#sharpening-spatial-filters-edge-detection-锐化空间滤波器边缘检测"></a> Sharpening Spatial Filters Edge Detection 锐化空间滤波器边缘检测</h4><p>Goal is to highlight fine detail, or enhance detail that has been blurred</p><p>Spatial differentiation is the tool; strength of response of derivative operator is proportional to degree of discontinuity of the image at the point where operator is applied</p><p>Image differentiation enhances edges, and de-emphasizes slowly varying gray-level values.</p><h4 id="derivative-definitions-导数的定义"><a class="markdownIt-Anchor" href="#derivative-definitions-导数的定义"></a> Derivative Definitions 导数的定义</h4><p>For 1-D function f(x), the first order derivative is approximated as:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/i/image-20210927162732530.png" alt="image-20210927162732530"></p><p>The second-order derivative is approximated as:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927162756879.png" alt="image-20210927162756879"></p><h4 id="image-enhancement-in-the-spatial-domain-空间域图像增强"><a class="markdownIt-Anchor" href="#image-enhancement-in-the-spatial-domain-空间域图像增强"></a> Image Enhancement in the Spatial Domain 空间域图像增强</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927172230005.png" alt="image-20210927172230005"></p><h4 id="basic-idea-基本想法"><a class="markdownIt-Anchor" href="#basic-idea-基本想法"></a> Basic Idea 基本想法</h4><p>Thus, magnitude of first derivative can be used to detect the presence of an edge, and sign of second derivative to determine whether a pixel lies on dark or light side of an edge.</p><p>因此，一阶导数的大小可以用来检测边缘的存在，二阶导数的符号可以用来确定一个像素是位于边缘的暗面还是亮面。</p><h3 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h3><p>First-order derivatives produce thicker edges, have stronger response to gray-level step</p><p>一阶导数边缘较厚，对灰度阶跃有较强的响应</p><p>Second-order derivatives produce stronger response to fine detail (thin lines, isolated points), produce double response at step changes in gray level</p><p>二阶导数对精细细节（细线、孤立点）产生更强的响应，在灰度阶跃变化时产生双重响应</p><h3 id="gradient-operator-梯度算子"><a class="markdownIt-Anchor" href="#gradient-operator-梯度算子"></a> Gradient Operator 梯度算子</h3><p>First-order derivatives implemented using magnitude of the gradient 利用梯度的大小实现的一阶导数</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927174358869.png" alt="image-20210927174358869"></p><p>有时简化为</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927174457840.png" alt="image-20210927174457840"></p><p>We use numerical techniques to compute these, giving rise to different masks, e.g. Roberts’ 2 x 2 cross-gradient operators, Sobel’s 3 x 3 masks</p><h4 id="image-enhancement-in-the-spatial-domain-空间域图像增强-2"><a class="markdownIt-Anchor" href="#image-enhancement-in-the-spatial-domain-空间域图像增强-2"></a> Image Enhancement in the Spatial Domain 空间域图像增强</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927191337950.png" alt="image-20210927191337950"></p><h4 id="laplacian-operator-拉普拉斯算符"><a class="markdownIt-Anchor" href="#laplacian-operator-拉普拉斯算符"></a> Laplacian Operator 拉普拉斯算符</h4><p>Second order derivatives based on the Laplacian. 基于拉普拉斯的二阶导数。</p><p>For a function 𝑓(𝑥, 𝑦) the Laplacian is defined by</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927191454333.png" alt="image-20210927191454333"></p><p>This is a linear operator, as all derivative operators are.</p><p>In discrete form 离散形式:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927191606952.png" alt="image-20210927191606952"></p><p>y方向相似。所以，总结起来看是：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927191825702.png" alt="image-20210927191825702"></p><h4 id="image-enhancement-in-the-spatial-domain-空间域图像增强-3"><a class="markdownIt-Anchor" href="#image-enhancement-in-the-spatial-domain-空间域图像增强-3"></a> Image Enhancement in the Spatial Domain 空间域图像增强</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927192306256.png" alt="image-20210927192306256"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927192327566.png" alt="image-20210927192327566"></p><h4 id="gradient-versus-laplacian-edge-detection-梯度与拉普拉斯边缘检测"><a class="markdownIt-Anchor" href="#gradient-versus-laplacian-edge-detection-梯度与拉普拉斯边缘检测"></a> Gradient Versus Laplacian Edge Detection 梯度与拉普拉斯边缘检测</h4><p>Edges from thresholding local maxima of the gradient magnitude image 对梯度幅值图像进行阈值局部极大值提取</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927192433991.png" alt="image-20210927192433991"></p><p>Edges from finding the zero-crossings of the Laplacian image 寻找拉普拉斯图像的零交叉的边缘</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927192508386.png" alt="image-20210927192508386"></p><h4 id="the-laplacian-拉普拉斯算子"><a class="markdownIt-Anchor" href="#the-laplacian-拉普拉斯算子"></a> The Laplacian 拉普拉斯算子</h4><p>There are other forms of the Laplacian, which can include diagonal directions, for example</p><p>Laplacian highlights grey-level discontinuities and produces dark featureless backgrounds</p><p>The background can be recovered by adding or subtracting the Laplacian image to the original image</p><h4 id="image-enhancement-in-the-spatial-domain-空间域图像增强-4"><a class="markdownIt-Anchor" href="#image-enhancement-in-the-spatial-domain-空间域图像增强-4"></a> Image Enhancement in the Spatial Domain 空间域图像增强</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927192854686.png" alt="image-20210927192854686"></p><h4 id="image-enhancement-in-the-spatial-domain-空间域图像增强-5"><a class="markdownIt-Anchor" href="#image-enhancement-in-the-spatial-domain-空间域图像增强-5"></a> Image Enhancement in the Spatial Domain 空间域图像增强</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927192921887.png" alt="image-20210927192921887"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927194316732.png" alt="image-20210927194316732"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927194249057.png" alt="image-20210927194249057"></p><h4 id="padding-填补"><a class="markdownIt-Anchor" href="#padding-填补"></a> Padding 填补</h4><p>在对图像边界上的像素使用空间滤波器时，会有临接点不足的情况出现。为了获取与输入图像大小相同的图像，可以：</p><ul><li><p><strong>Zero</strong>: set all pixels outside the source image to 0 设置源图像以外的所有像素为0</p></li><li><p><strong>Constant</strong>: set all pixels outside the source image to a specified border value 设置源图像外的所有像素为指定的边框值</p></li><li><p><strong>Clamp</strong>: repeat edge pixels indefinitely 无限重复边缘像素</p></li><li><p><strong>Wrap</strong>: copy pixels from opposite side of the image 从图像的对面复制像素</p></li><li><p><strong>Mirror</strong>: reflect pixels across the image edge 通过图像边缘反射像素</p></li></ul><h4 id="padding-example"><a class="markdownIt-Anchor" href="#padding-example"></a> Padding Example</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927195321964.png" alt="image-20210927195321964"></p><h2 id="image-processing-iii-图像处理三"><a class="markdownIt-Anchor" href="#image-processing-iii-图像处理三"></a> Image Processing III 图像处理三</h2><h3 id="frequency-domain-techniques-频域技术"><a class="markdownIt-Anchor" href="#frequency-domain-techniques-频域技术"></a> Frequency Domain Techniques 频域技术</h3><p><strong>Goal</strong>: to gain working knowledge of Fourier transform and frequency domain for use in Image Processing</p><p>focus on fundamentals and relevance to Image Processing</p><p><strong>not</strong> signal processing expertise!</p><p><strong>Any</strong> <em>univariate function can be</em> <em>rewritten as a weighted sum of</em> <em>sines and cosines of different</em> <em>frequencies.</em></p><h4 id="frequency-versus-spatial-domain-频率与空间域"><a class="markdownIt-Anchor" href="#frequency-versus-spatial-domain-频率与空间域"></a> Frequency Versus Spatial Domain 频率与空间域</h4><p><strong>Spatial domain</strong></p><ul><li><p>the image plane itself</p></li><li><p>direct manipulation of pixels</p></li><li><p>changes in pixel position correspond to changes in the scene</p></li></ul><p><strong>Frequency domain</strong></p><ul><li><p>Fourier transform of an image</p></li><li><p>directly related to rate of changes in the image</p></li><li><p>changes in pixel position correspond to changes in the spatial frequency</p></li></ul><h4 id="frequency-domain-overview-频域概述"><a class="markdownIt-Anchor" href="#frequency-domain-overview-频域概述"></a> Frequency Domain Overview 频域概述</h4><p><strong>Frequency in image</strong></p><ul><li><p>high frequencies correspond to pixel values that change rapidly across the image 高频率对应的像素值在整个图像中迅速变化</p></li><li><p>low frequency components correspond to large scale features in the image 低频分量对应于图像中的大尺度特征</p></li></ul><p><strong>Frequency domain</strong></p><ul><li>defined by values of the Fourier transform and its frequency variables (u, v) 由傅里叶变换的值及其频率变量(u, v)定义</li></ul><p><strong>Frequency domain processing</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927200935936.png" alt="image-20210927200935936"></p><p><strong>Fourier Series</strong></p><ul><li><p>Periodic function can be represented as a weighted sum of sines and cosines of different frequencies 周期函数可以表示为不同频率的正弦和余弦的加权和</p></li><li><p>Even functions that are not periodic (but whose area under the curve is finite) can be expressed as the integral of sines and/or cosines multiplied by a weight function 即使函数不是周期性的(但其曲线下面积是有限的)，也可以表示为sin和/或cos的积分乘以一个权函数</p></li></ul><h4 id="one-dim-fourier-transform-and-its-inverse-一维傅里叶变换及其反变换"><a class="markdownIt-Anchor" href="#one-dim-fourier-transform-and-its-inverse-一维傅里叶变换及其反变换"></a> One-Dim Fourier Transform and its Inverse  一维傅里叶变换及其反变换</h4><p>For a single variable continuous function f(x), the Fourier transform F(u) is defined by:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927201506977.png" alt="image-20210927201506977"></p><p>其中，j=√-1</p><p>Given F(u), we recover f(x) using the <em>inverse</em> Fourier transform:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927201652537.png" alt="image-20210927201652537"></p><p>(1)和(2)构成一个  <strong>傅里叶变换对 Fourier transform pair</strong></p><h4 id="two-dim-fourier-transform-and-inverse-二维傅里叶变换及其反变换"><a class="markdownIt-Anchor" href="#two-dim-fourier-transform-and-inverse-二维傅里叶变换及其反变换"></a> Two-Dim Fourier Transform and Inverse  二维傅里叶变换及其反变换</h4><p>In two dimensions, we have:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927201906373.png" alt="image-20210927201906373"></p><h4 id="discrete-fourier-transform-离散傅里叶变换"><a class="markdownIt-Anchor" href="#discrete-fourier-transform-离散傅里叶变换"></a> Discrete Fourier Transform 离散傅里叶变换</h4><p>在一维</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927202051752.png" alt="image-20210927202051752"></p><p>Note that the location of 1/M does not matter, so long as the product of the two multipliers is 1/M</p><p>Also in the discrete case, the Fourier transform and its inverse always exist</p><p>Consider Euler’s formula:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927202344785.png" alt="image-20210927202344785"></p><p>将这个表达式代入(5)，并注意cos(−𝜃) = cos(𝜃)，有</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927202455371.png" alt="image-20210927202455371"></p><p>F的每一项取决于F (x)的所有值，F (x)的值乘以不同频率的正弦和余弦。</p><p>F(u)范围的值所在的域称为<strong>频域 frequency domain</strong> ，因为u决定了变换分量的频率。</p><h4 id="2-d-discrete-fourier-transform-二维离散傅里叶变换"><a class="markdownIt-Anchor" href="#2-d-discrete-fourier-transform-二维离散傅里叶变换"></a> 2-D Discrete Fourier Transform 二维离散傅里叶变换</h4><p>Digital images are 2-D discrete functions:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927202722605.png" alt="image-20210927202722605"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927202739659.png" alt="image-20210927202739659"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927203136573.png" alt="image-20210927203136573"></p><h4 id="frequency-domain-filtering-频域滤波"><a class="markdownIt-Anchor" href="#frequency-domain-filtering-频域滤波"></a> Frequency Domain Filtering 频域滤波</h4><p>Frequency is directly related to <strong>rate of change</strong>, so frequencies in the Fourier transform may be related to <strong>patterns of intensity variations in the image</strong>.</p><p>频率与<strong>变化率</strong>直接相关，所以傅里叶变换中的频率可能与<strong>图像中强度变化的模式</strong>有关。</p><p>Slowest varying frequency at u = v = 0 corresponds to average gray level of the image.</p><p>最慢的变化频率在u = v = 0对应图像的平均灰度。</p><p>Low frequencies correspond to slowly varying components in the image- for example, large areas of similar gray levels.</p><p>低频率对应于图像中缓慢变化的成分——例如，灰度相似的大片区域。</p><p>Higher frequencies correspond to faster gray level changes- such as edges, noise etc.</p><p>更高的频率对应更快的灰度级变化-如边缘，噪声等。</p><h4 id="procedure-for-filtering-in-the-frequency-domain-频域滤波操作步骤"><a class="markdownIt-Anchor" href="#procedure-for-filtering-in-the-frequency-domain-频域滤波操作步骤"></a> Procedure for Filtering in the Frequency Domain 频域滤波操作步骤</h4><ol><li><p>Multiply the input image by (-1)^(x+y) to centre the transform at (M/2, N/2), which is the centre of the MxN area occupied by the 2D DFT</p></li><li><p>Compute the DFT F(u,v) of the resulting image</p></li><li><p>Multiply F(u,v) by a filter H(u,v)</p></li><li><p>Compute the inverse DFT transform g*(x,y)</p></li><li><p>Obtain the real part g(x,y)</p></li><li><p>Multiply the result by (-1)^(x+y)</p></li></ol><p><strong>Example: Notch Filter 陷波滤波器</strong></p><p>We wish to force the average value of an image to zero. We can achieve this by setting F(0, 0) =0, and then taking its inverse transform.</p><p>So choose the filter function as:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927204218958.png" alt="image-20210927204218958"></p><p>Called the <strong>notch filter-</strong> constant function with a hole (notch) at the origin. 称为**陷波滤波器-**常数函数，在原点有一个孔(陷波)。</p><ul><li><p>A filter that attenuates high frequencies while allowing low frequencies to pass through is called a <em>lowpass filter</em>. <em>衰减高频而允许低频通过的滤波器称为</em>低通滤波器。</p></li><li><p>A filter that attenuates low frequencies while allowing high frequencies to pass through is called a <em>highpass filter</em>一种衰减低频同时允许高频通过的滤波器叫做“高通滤波器”</p></li></ul><h4 id="convolution-theorem-correspondence-between-spatial-and-frequency-domain-filtering-卷积定理空域滤波和频域滤波的对应关系"><a class="markdownIt-Anchor" href="#convolution-theorem-correspondence-between-spatial-and-frequency-domain-filtering-卷积定理空域滤波和频域滤波的对应关系"></a> Convolution Theorem: correspondence between spatial and frequency domain filtering 卷积定理:空域滤波和频域滤波的对应关系</h4><p>Let F(u, v) and H( u, v) be the Fourier transforms of f(x, y) and h(x,y). Let * be spatial convolution, and multiplication be</p><p>element-by-element product. Then</p><ul><li><p>f(x, y) * h(x, y) and F(u, v) H(u, v) constitute a Fourier transform pair</p></li><li><p>Analogously, convolution in the frequency domain reduces to multiplication in the spatial domain, and vice versa.</p></li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927204726892.png" alt="image-20210927204726892"></p><p>Using this theorem, we can also show that filters in the spatial and frequency domains constitute a Fourier transform pair.</p><p>利用这个定理，我们还可以证明在空间域和频率域的滤波器构成一个傅里叶变换对。</p><h4 id="exploiting-the-correspondence-利用通信"><a class="markdownIt-Anchor" href="#exploiting-the-correspondence-利用通信"></a> Exploiting the correspondence 利用通信</h4><p>If filters in the spatial and frequency domains are of the same size, then filtering is more efficient computationally in frequency domain. 如果空间域和频域滤波器的大小相同，则频域滤波的计算效率更高。</p><p>However, spatial filters tend to be smaller in size. 然而，空间滤波器的尺寸往往较小。</p><p>Filtering is also more intuitive in frequency domain so design it there. 滤波也更直观的频域，所以设计它在那里。</p><p>Then, take the inverse transform, and use the resulting filter as a guide to design smaller filters in the spatial domain. 然后进行反变换，以得到的滤波器为指导，在空间域上设计更小的滤波器。</p><h4 id="example-of-smoothing-an-image-平滑图像的例子"><a class="markdownIt-Anchor" href="#example-of-smoothing-an-image-平滑图像的例子"></a> Example of Smoothing an Image 平滑图像的例子</h4><p>In spatial domain, we just convolve the image with a Gaussian kernel to smooth it 在空间域，我们只是用高斯核对图像进行卷积来平滑它</p><p>In frequency domain, we can multiply the image by a filter achieve the same effect 在频域，我们可以将图像乘以一个滤波器来达到同样的效果</p><ol><li>Multiply the input image by (-1)x+y to center the transform</li></ol><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927205245150.png" alt="image-20210927205245150"></p><ol start="2"><li>Compute the DFT F(u,v) of the resulting image</li></ol><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927205533644.png" alt="image-20210927205533644"></p><ol start="3"><li>Multiply F(u,v) by a filter G(u,v)</li></ol><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927205611004.png" alt="image-20210927205611004"></p><ol start="4"><li><p>Compute the inverse DFT transform h*(x,y)</p></li><li><p>Obtain the real part h(x,y)</p></li><li><p>Multiply the result by (-1)x+y</p></li></ol><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927205648347.png" alt="image-20210927205648347"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927205752932.png" alt="image-20210927205752932"></p><h4 id="gaussian-filter-高斯滤波器-2"><a class="markdownIt-Anchor" href="#gaussian-filter-高斯滤波器-2"></a> Gaussian Filter 高斯滤波器</h4><p>Gaussian filters are important because their shapes are easy to specify, and both the forward and inverse Fourier transforms of a Gaussian function are real Gaussian functions.</p><p>高斯滤波器很重要，因为它们的形状很容易指定，高斯函数的傅里叶正变换和反变换都是实高斯函数。</p><p>设H(u)为一维高斯滤波器，具体为:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927205927502.png" alt="image-20210927205927502"></p><p>其中，σ为高斯曲线的标准差。</p><p>对应的空间域滤波器为</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927205958077.png" alt="image-20210927205958077"></p><p>This is usually a lowpass filter. 这通常是低通滤波器。</p><h4 id="dog-filter-dog过滤器"><a class="markdownIt-Anchor" href="#dog-filter-dog过滤器"></a> DoG Filter  DoG过滤器</h4><p>Difference of Gaussians may be used to construct highpass filters 高斯差可以用来构造高通滤波器:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927210247358.png" alt="image-20210927210247358"></p><p>with <em>A</em> ≥ B and δ1 &gt; δ 2.</p><p>对应的空间域滤波器为</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927210333531.png" alt="image-20210927210333531"></p><h4 id="multiresolution-processing-多分辨率处理"><a class="markdownIt-Anchor" href="#multiresolution-processing-多分辨率处理"></a> Multiresolution Processing 多分辨率处理</h4><ul><li><p>Small objects, low contrast benefit from high resolution 小物体，低对比度得益于高分辨率</p></li><li><p>Large objects, high contrast, can make do with lower resolution 大的物体，高对比度，可以凑合低分辨率</p></li><li><p>If both present at the same time, multiple resolutions may be useful 如果两者同时出现，多个分辨率可能是有用的</p></li><li><p>Local statistics such as intensity averages can vary in different parts of an image 局部统计数据(如强度平均值)可能在图像的不同部分有所不同</p></li><li><p>Exploit this in multiresolution processing 在多分辨率处理中利用这一点</p></li></ul><h4 id="image-pyramids-图像金字塔"><a class="markdownIt-Anchor" href="#image-pyramids-图像金字塔"></a> Image Pyramids 图像金字塔</h4><p>An image pyramid is a collection of decreasing resolution images arranged in the shape of a pyramid. 图像金字塔是分辨率降低的图像按金字塔形状排列的集合。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927211109703.png" alt="image-20210927211109703"></p><p>System block diagram for creating image pyramids 用于创建图像金字塔的系统框图</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927211256261.png" alt="image-20210927211256261"></p><ol><li><p>Compute a reduced-resolution approximation of the input image by filtering and downsampling (mean, Gaussian, subsampling)  通过滤波和下采样(平均、高斯、子采样)计算输入图像的降低分辨率近似</p></li><li><p>Upsample the output of step 1 and filter the result (possibly with interpolation)  对步骤1的输出进行上采样并对结果进行滤波(可能使用插值)</p></li><li><p>Compute the difference between the prediction of step 2 and the input to step 1  计算步骤2的预测和步骤1的输入之间的差值</p></li></ol><p>重复，产生近似和预测残差金字塔</p><p>Two image pyramids and their statistics (Gaussian approx pyramid, Laplacian prediction residual pyramid)</p><p>两个图像金字塔及其统计量(高斯近似金字塔、拉普拉斯预测残差金字塔)</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210927211533099.png" alt="image-20210927211533099"></p><h4 id="to-recreate-image-重建图像"><a class="markdownIt-Anchor" href="#to-recreate-image-重建图像"></a> To recreate image 重建图像</h4><p>Upsample and filter the lowest resolution approximation image 上采样和滤波最低分辨率的近似图像</p><p>Add the 1-level higher Laplacian’s prediction residual 加上1级以上的拉普拉斯预测残差</p><p><em><strong>spatial</strong></em> adj. 空间的</p><p><em><strong>derivative</strong></em> n. 派生物, 导数</p><h4 id=""><a class="markdownIt-Anchor" href="#"></a> </h4>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> COMP9517 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程决策结构（2）</title>
      <link href="/2021/09/26/unsw/gsoe9210/gong-cheng-jue-ce-jie-gou-2/"/>
      <url>/2021/09/26/unsw/gsoe9210/gong-cheng-jue-ce-jie-gou-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Decisions-under-complete-uncertainty-ignorance-完全不确定-无知下的决定"><a href="#Decisions-under-complete-uncertainty-ignorance-完全不确定-无知下的决定" class="headerlink" title="Decisions under complete uncertainty/ignorance 完全不确定/无知下的决定"></a>Decisions under complete uncertainty/ignorance 完全不确定/无知下的决定</h2><h3 id="Ignorance-and-possibility-无知和可能性"><a href="#Ignorance-and-possibility-无知和可能性" class="headerlink" title="Ignorance and possibility 无知和可能性"></a>Ignorance and possibility 无知和可能性</h3><p>Ignorance = possibilities without probabilities </p><p>无知=没有可能性的可能性</p><p>行动可能不会决定一个独特的结果;“状态”是指一种情况的某些方面，当与可能的行动相结合时，就会区分出不同的结果。</p><p>选择/评估无知行为的理性决策规则</p><h3 id="Decisions-under-uncertainty-不确定性下的决策方法"><a href="#Decisions-under-uncertainty-不确定性下的决策方法" class="headerlink" title="Decisions under uncertainty 不确定性下的决策方法"></a>Decisions under uncertainty 不确定性下的决策方法</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926014644185.png" alt="image-20210926014644185"></p><p>How should <em>V</em> (S) and <em>V</em> (F) be defined?</p><p>How should <em>V</em> (over actions) depend on <em>v</em> (over outcomes)?</p><h3 id="Lotteries-彩票"><a href="#Lotteries-彩票" class="headerlink" title="Lotteries 彩票"></a>Lotteries 彩票</h3><p><strong>Definition (Lottery)</strong>: A <em>lottery</em> over a finite set of states <em>S</em>, and outcomes, or <em>prizes</em>, Ω, is a</p><p>function <em>`</em> : <em>S →</em> Ω. The lottery <em>`</em> is written:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926014656604.png" alt="image-20210926014656604"></p><p><strong>Corollary</strong>: The problem of evaluating actions amounts to the problem of determining how to compare and/or evaluate lotteries.</p><p>推论：评价行为的问题相当于决定如何比较和/或评价彩票的问题。</p><h3 id="Decisions-under-uncertainty-ignorance-不确定性下的决定-无知"><a href="#Decisions-under-uncertainty-ignorance-不确定性下的决定-无知" class="headerlink" title="Decisions under uncertainty: ignorance 不确定性下的决定:无知"></a>Decisions under uncertainty: ignorance 不确定性下的决定:无知</h3><h4 id="possibilities"><a href="#possibilities" class="headerlink" title="possibilities"></a>possibilities</h4><p><strong>Definition (Decision rule)</strong>: A <em>decision rule</em> is a way of choosing, for each decision problem, an action or set of actions.</p><p><strong>定义(决策规则)</strong>：一个<em>决策规则</em>是一种选择方法，对于每个决策问题，一个行动或一组行动。</p><p>A <em>decision rule</em> or <em>decision procedure</em> is a way of choosing, for each decision problem, a set of ‘preferred’ actions.</p><p>决策规则或决策程序是对每个决策问题选择一组“首选”行动的方法。</p><p>Rational decision rules under ignorance:</p><ul><li><p>Optimistic <em>MaxiMax</em> rule: “nothing ventured, nothing gained”</p></li><li><p>Wald’s pessimistic <em>Maximin</em> rule: “better to be safe than sorry”</p></li><li><p><em>Hurwicz</em>’s mixed optimistic-pessimistic rule: degree of optimism/pessimism</p></li><li><p>Savage’s <em>miniMax Regret</em> rule: least <em>regret</em></p></li><li><p>Laplace’s <em>principle of insuficient reason</em></p></li></ul><p><strong>Approach</strong>: assign values (<em>V</em> ) to actions based on preferences over outcomes (<em>v</em>)</p><p>方法: 根据偏好而非结果(<em>V</em>)为行动赋值(<em>V</em>)</p><h4 id="MaxiMax"><a href="#MaxiMax" class="headerlink" title="MaxiMax"></a>MaxiMax</h4><p><strong>MaxiMax(MM):</strong> associate with each action states which yields the most preferred outcome</p><p>将每个产生最优结果的行动状态联系起来</p><p>MaxiMax选择在这些行为中产生偏好最大结果的行为</p><ul><li><p>For each action find best possible outcome over all possible states;</p></li><li><p>Choose actions/rows with maximal value</p></li><li><p>Equivalently: find maximum value of entire table, choose row/action with this value</p></li><li><p>r_MM(ω) = arg max{M(A)| A ∈ A}</p></li></ul><h4 id="Risk-attitudes"><a href="#Risk-attitudes" class="headerlink" title="Risk attitudes"></a>Risk attitudes</h4><p><em>MaxiMax</em> is a decision rule for extreme <em>risk takers</em></p><p><em>MaxiMax</em> is ‘rational’ decision rule for decision-makers with risk-taking attitudes/preferences</p><p>In some cases it may be wise to be <em>risk averse</em></p><p>What might a risk averse decision rule look like?</p><h4 id="Maximin-Mm-best-in-the-worst-case"><a href="#Maximin-Mm-best-in-the-worst-case" class="headerlink" title="Maximin (Mm): best in the worst case"></a><em>Maximin</em> (Mm): best in the worst case</h4><ul><li><p>For each action find worst possible outcome under all possible cases/states</p></li><li><p><em>m</em>(A) sometimes called the <em>security level</em> of action A</p></li><li><p>Choose the action/row with the maximum of these</p></li><li>r_Mm(ω) = arg max{m(A) | A ∈ A}</li></ul><h3 id="Hurwicz’s-optimism-index-维奇的乐观指数"><a href="#Hurwicz’s-optimism-index-维奇的乐观指数" class="headerlink" title="Hurwicz’s optimism index 维奇的乐观指数"></a><em>Hurwicz</em>’s optimism index 维奇的乐观指数</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926021441355.png" alt="image-20210926021441355"></p><ul><li><p>For each action/row, find minima (<em>m</em>) and maxima (<em>M</em>)</p></li><li><p>Calculate weighted sum based on <em>optimism index</em> <em>α</em> <em>∈</em> [0<em>,</em> 1]</p></li><li><p>Choose the row/action that maximises this value</p></li></ul><h3 id="Best-response-actions"><a href="#Best-response-actions" class="headerlink" title="Best response actions"></a>Best response actions</h3><p><strong>Definition (Better actions)</strong>: An action A is <em>better</em> than action B in state <em>s</em> iff A’s outcome in <em>s</em> preferred to B’s.</p><p>定义(更好的行动):在A的结果优于B的情况下，行动A比行动B要好。</p><p>Definition (Best response): An action A is a best response in state s iff no other action is better than A in state s.</p><p>定义(最好的回应):如果在状态中没有其他行动优于A，则行动A是最佳响应。</p><h3 id="Regret-后悔"><a href="#Regret-后悔" class="headerlink" title="Regret 后悔"></a>Regret 后悔</h3><p><strong>Definition (Regret):</strong> The <em>regret</em>, or <em>opportunity loss</em>, of an action in a state is the difference between the action’s value and that of the best response for that state.</p><p><strong>定义(遗憾):</strong>一种状态下行为的“遗憾”或“机会损失”是该行为的价值与该状态的最佳对策之间的差异。</p><h3 id="miniMax-Regret-极小极大后悔"><a href="#miniMax-Regret-极小极大后悔" class="headerlink" title="miniMax Regret 极小极大后悔"></a>miniMax Regret 极小极大后悔</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926022438417.png" alt="image-20210926022438417"></p><ul><li><p>For each column/state <em>s</em>, find its maximum value (M_s)</p></li><li><p>Construct the regret table: <em>R</em>(<em>ω</em>) = <em>M</em>_s - <em>v</em>(<em>ω</em>)</p></li><li><p>For each action/row find the maximum regret: </p></li></ul><p><em>V</em> (A) = max<em>{R</em>(<em>ω</em>(A<em>, s</em>)) <em>|</em> <em>s</em> <em>∈ S}</em></p><ul><li>Choose the row/action that minimises the regret: A_3</li></ul><h3 id="Laplace’s-principle-of-insuficient-reason-拉普拉斯不充分推理原理"><a href="#Laplace’s-principle-of-insuficient-reason-拉普拉斯不充分推理原理" class="headerlink" title="Laplace’s principle of insuficient reason 拉普拉斯不充分推理原理"></a>Laplace’s principle of insuficient reason 拉普拉斯不充分推理原理</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926022959776.png" alt="image-20210926022959776"></p><ul><li><p><em>Assume</em> each state is equally likely</p></li><li><p>For each row/action calculate the mean value</p></li><li><p>Choose the row/action with maximum value</p></li></ul><h3 id="Decision-rules"><a href="#Decision-rules" class="headerlink" title="Decision rules"></a>Decision rules</h3><p>For a value function <em>V</em> on actions, a decision rule <em>r_V</em> is defined by:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926160811493.png" alt="image-20210926160811493"></p><h3 id="Summary-小结"><a href="#Summary-小结" class="headerlink" title="Summary 小结"></a>Summary 小结</h3><ul><li><p>Ignorance: more than one possible state; likelihoods unknown</p></li><li><p>Lotteries: uncertain situations</p></li><li><p>Risk attitudes</p></li><li><p>Best response/action</p></li><li><p>Some decision rules under complete uncertainty (ignorance):</p><ul><li><p>Optimistic <em>MaxiMax</em> rule: “nothing ventured, nothing gained”</p></li><li><p>Wald’s pessimistic <em>Maximin</em> rule: “its better to be safe than sorry”</p></li><li><p><em>Hurwicz</em>’s mixed optimistic-pessimistic rule: use an <em>optimism index</em> <em>α</em></p></li><li><p>Savage’s <em>miniMax Regret</em> rule; least <em>opportunity loss</em></p></li><li><p>Laplace’s <em>principle of insufficient reason</em> rule</p></li></ul></li></ul><h3 id="The-Maximin-principle-极大极小原则"><a href="#The-Maximin-principle-极大极小原则" class="headerlink" title="The Maximin principle 极大极小原则"></a>The <em>Maximin</em> principle 极大极小原则</h3><p><strong>Definition (The <em>Maximin</em> principle)</strong>: Assume only minimally preferred outcomes occur and choose actions that lead to most preferred among these.</p><p><strong>定义(<em>Maximin</em>原则)</strong>:假设只出现最小偏好的结果，并选择导致这些结果中最偏好的行动。</p><p><em>Maximin</em> and <em>miniMax Regret</em> follow <em>Maximin</em> principle: original values vs regrets</p><p><em>Maximin</em> principle is main decision principle used under complete uncertainty</p><p>We’ve seen <em>Maximin</em> and <em>miniMax Regret</em> on decision tables, but what about more complex decision problems (<em>e.g</em>., multiple decision points)?</p><h3 id="Multi-stage-decisions-多阶段决策"><a href="#Multi-stage-decisions-多阶段决策" class="headerlink" title="Multi-stage decisions 多阶段决策"></a>Multi-stage decisions 多阶段决策</h3><p>案例：保洁公司是否要研发新产品，要建立多大的工厂问题。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926162524220.png" alt="image-20210926162524220"></p><h4 id="Node-evaluation-节点评价"><a href="#Node-evaluation-节点评价" class="headerlink" title="Node evaluation 节点评价"></a>Node evaluation 节点评价</h4><p>Each decision problem is assigned a ‘value’ by a decision rule</p><p>The <em>Maximin</em> algorithm for decision trees:</p><ul><li><ol><li>Begin at leaves</li></ol></li><li><ol><li>At parent node:</li></ol><ul><li><p>2.1 if a chance node, prune all children except the minimally preferred</p></li><li><p>2.2 if a decision node, by <em>elimination principle</em>, prune all children except the maximally preferred</p></li><li><p>2.3 propagate (unique) value up to parent node</p></li></ul></li><li><ol><li>Repeat previous step until root is reached</li></ol></li></ul><p>Value of root is value of the problem (under <em>Maximin</em>)</p><h2 id="Normalisation-标准化"><a href="#Normalisation-标准化" class="headerlink" title="Normalisation 标准化"></a>Normalisation 标准化</h2><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926163751773.png" alt="image-20210926163751773"></p><p>Model as a 2-ary (dyadic) function: <em>ω</em> : <em>A × S →</em> Ω</p><p><strong>For Decision table:</strong></p><p>row = action  column = state</p><p>Interpretation: B = <em>ω</em>(D<em>, o</em>) means “B is the outcome of action D in state <em>o</em>”</p><h3 id="Trees-and-tables"><a href="#Trees-and-tables" class="headerlink" title="Trees and tables"></a>Trees and tables</h3><p>Multiple trees may correspond to the same table</p><p>Going from tables (<em>normal form</em>) to trees (<em>extensive form</em>) is straight forward, but the converse can be tricky</p><p><strong>Definition (Strategy):</strong> A <em>strategy</em> (or <em>policy</em> or <em>plan</em>) is a procedure that specifies the selection of an action at every <em>reachable</em> decision point.</p><p><strong>定义(策略)</strong>:一个<em>策略</em>(或<em>政策</em>或<em>计划</em>)是一个过程，它规定了在每个<em>可到达的</em>决策点选择一个行动。</p><p><strong>Encoding:</strong></p><p><em>α</em>/A says: <em>At the decision node reached via path</em> <em>α</em> <em>choose action A.</em></p><h4 id="Representing-information-代表信息"><a href="#Representing-information-代表信息" class="headerlink" title="Representing information 代表信息"></a>Representing information 代表信息</h4><h2 id="Preference-偏好"><a href="#Preference-偏好" class="headerlink" title="Preference 偏好"></a>Preference 偏好</h2><h3 id="Indifference-equal-preference-无差异-平等的偏好"><a href="#Indifference-equal-preference-无差异-平等的偏好" class="headerlink" title="Indifference: equal preference 无差异:平等的偏好"></a>Indifference: equal preference 无差异:平等的偏好</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926170320207.png" alt="image-20210926170320207"></p><p><strong>Definition (Indifference):</strong> If two actions A and B are <em>equally preferred</em> then the agent is said to be <em>indifferent</em> between A and B.</p><p><strong>定义(无差异)</strong>：如果两个行为A和B是“同等优先”的，那么代理在A和B之间是“无差异”的。</p><p><strong>Definition (Indifference class):</strong> An <em>indifference class</em> is a non-empty set of all actions/outcomes between which an agent is indifferent.</p><p><strong>定义(无差异类):</strong>一个<em>无差异类</em>是一个非空的集合，它包含所有的行为/结果，其中每一个代理是无差异的。</p><p>For a given action A <em>∈ A</em>, the indifference class of A is given by</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926170552892.png" alt="image-20210926170552892"></p><p>Indifference classes partition set of all actions<br>Different agents have different preferences over outcomes/actions, hence different indifference classes<br>Different decision rules evaluate actions differently; i.e., produce different indifference classes</p><h3 id="Graphical-representation-图形化表示"><a href="#Graphical-representation-图形化表示" class="headerlink" title="Graphical representation 图形化表示"></a>Graphical representation 图形化表示</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926170936199.png" alt="image-20210926170936199"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926170943728.png" alt="image-20210926170943728"></p><p>Let v_i(a) = v(a, s_i) be the value of action a in state s_i. Each action a corresponds to a point (v1, v2), where v_i = v(a, s_i). </p><h3 id="Indifference-curves-Maximin"><a href="#Indifference-curves-Maximin" class="headerlink" title="Indifference curves: Maximin"></a>Indifference curves: <em>Maximin</em></h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926171618217.png" alt="image-20210926171618217"></p><h3 id="Graphing-regret"><a href="#Graphing-regret" class="headerlink" title="Graphing regret"></a>Graphing regret</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926171650600.png" alt="image-20210926171650600"></p><h3 id="Generalised-dominance-全面主导地位"><a href="#Generalised-dominance-全面主导地位" class="headerlink" title="Generalised dominance 全面主导地位"></a>Generalised dominance 全面主导地位</h3><p><strong>Definition (Strict dominance)</strong>: Strategy A <em>strictly dominates</em> B iff every outcome of A is more preferred than the corresponding outcome of B.</p><p><strong>定义(严格优势)</strong>：策略A <em>严格优势</em> B，如果A的每个结果都比B的相应结果更优。</p><p><strong>Definition (Weak dominance)</strong>：Strategy A <em>weakly dominates</em> B iff every outcome of A is no less preferred than the corresponding outcome of B, and some outcome is more preferred.</p><p><strong>定义(弱优势)</strong>：策略A <em>弱优势</em> B，如果A的每个结果都不比B的相应结果更受欢迎，并且有一些结果更受欢迎。</p><h3 id="Dominance-and-best-response-显性和最佳反应"><a href="#Dominance-and-best-response-显性和最佳反应" class="headerlink" title="Dominance and best response 显性和最佳反应"></a>Dominance and best response 显性和最佳反应</h3><p><strong>Corollary</strong>: <em>Strategy A strictly dominates B iff A is a better response than B in each</em> <em>possible state.</em></p><p><strong>推论</strong>：策略A严格优于策略B，如果在每个可能的状态下，策略A都比策略B更好</p><p><strong>Corollary</strong>: Strategy A weakly dominates B iff A is a better response than B in some possible state and B is not a better response than A in any state.</p><p><strong>推论</strong>: 策略A弱于策略B, iff A在某些可能状态下比B更好，而B在任何状态下都不是比A更好的对策。</p><p><strong>Dominance principle</strong>: A rational agent should never choose a dominated strategy.</p><p><strong>优势原则</strong>：理性的行为人永远不应该选择劣势策略。</p><h4 id="Admissible-actions-容许的行为"><a href="#Admissible-actions-容许的行为" class="headerlink" title="Admissible actions 容许的行为"></a>Admissible actions 容许的行为</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926212337833.png" alt="image-20210926212337833"></p><p><strong>Definition (Admissible)</strong>: An action is <em>admissible</em> iff it is not dominated by any other action. An action which is not admissible is said to be <em>inadmissible</em>. The set of all admissible actions is called the <em>admissible frontier</em>.</p><p><strong>定义(可接受的)</strong>:如果一个行为不受其他行为的支配，那么这个行为就是“可接受的”。不可受理的行为被称为“不可受理”。所有可容许行为的集合称为<em>可容许边界</em>。</p><h4 id="Dominance-MaxiMax-and-Maximin"><a href="#Dominance-MaxiMax-and-Maximin" class="headerlink" title="Dominance: MaxiMax and Maximin"></a>Dominance: <em>MaxiMax</em> and <em>Maximin</em></h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926212610220.png" alt="image-20210926212610220"></p><p><strong>Definition (Dominance elimination)</strong>: A decision rule is said to satisfy (strict/weak) <em>dominance elimination</em> if it never chooses actions that are (strictly/weakly) dominated.</p><p><strong>定义(优势消除)</strong>：如果一个决策规则从未选择(严格/弱)劣势行为，那么它就被认为满足(严格/弱)劣势消除*。</p><p>Dominated actions can be discarded under any rule that satisfies dominance elimination</p><h4 id="Dominance-summary"><a href="#Dominance-summary" class="headerlink" title="Dominance summary"></a>Dominance summary</h4><p>Rules that satisfy strict/weak dominance elimination.</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926212749408.png" alt="image-20210926212749408"></p><h4 id="Rule-axioms-规则公理"><a href="#Rule-axioms-规则公理" class="headerlink" title="Rule axioms 规则公理"></a>Rule axioms 规则公理</h4><p>The following criteria can be used to assess the suitability of decision rules:</p><p><strong>Axiom of dominance</strong>: A decision rule should never choose a dominated action.</p><p><strong>支配原则</strong>:决策规则永远不应该选择支配行为。</p><p><strong>Axiom of invariance</strong>: A decision rule’s choices should be independent of representation.</p><p><strong>不变公理</strong>：决策规则的选择应该独立于表示。</p><p><strong>Axiom of solubility</strong>: A decision rule should always select at least one action.</p><p><strong>溶解度公理</strong>:决策规则应该总是选择至少一个行动。</p><p><strong>Axiom of independence</strong>: Adding a duplicate state should not affect a rule’s decision.</p><p><strong>独立原则</strong>：添加重复状态不应影响规则的决定。</p><h4 id="Contingency-plans-应急行动"><a href="#Contingency-plans-应急行动" class="headerlink" title="Contingency plans 应急行动"></a>Contingency plans 应急行动</h4><p><strong>Definition (Contingent action)</strong>: A <em>contingent action</em> or <em>conditional action</em> is an action that combines other actions depending on a contingency or condition. A contingent action is also called a <em>strategy</em> or <em>plan</em>.</p><p><strong>定义(偶然性行动)</strong>:偶然性行动或条件性行动是根据偶然性或条件结合其他行动的行动。应急行动也称为“战略”或“计划”。</p><h3 id="Summary-decisions-under-complete-uncertainty-总结-完全不确定性下的决策"><a href="#Summary-decisions-under-complete-uncertainty-总结-完全不确定性下的决策" class="headerlink" title="Summary: decisions under complete uncertainty 总结:完全不确定性下的决策"></a>Summary: decisions under complete uncertainty 总结:完全不确定性下的决策</h3><ul><li><p><em>Maximin</em> in extensive form</p></li><li><p>Multi-stage decisions</p></li><li><p>Extensive to normal form translation</p></li><li><p>Information in extensive form</p></li><li><p>Graphical visualisation</p></li><li><p>Indifference</p></li><li><p>Dominance and admissibility</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> GSOE9210 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程决策结构（1）</title>
      <link href="/2021/09/25/unsw/gsoe9210/gong-cheng-jue-ce-jie-gou-1/"/>
      <url>/2021/09/25/unsw/gsoe9210/gong-cheng-jue-ce-jie-gou-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Why-study-decision-making"><a href="#Why-study-decision-making" class="headerlink" title="Why study decision-making?"></a>Why study decision-making?</h2><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>High stakes decisions: War</p><p>Decision problems: professional</p><h4 id="Course-overview"><a href="#Course-overview" class="headerlink" title="Course overview"></a>Course overview</h4><p><strong>Course aims</strong>: To prepare engineering graduates for decision-making roles.</p><p><strong>Course structure:</strong> </p><h6 id="Single-agent-decisions"><a href="#Single-agent-decisions" class="headerlink" title="Single-agent decisions"></a>Single-agent decisions</h6><p>1 Decision problems</p><p>2 Decision problem representations: trees and tables</p><p>3 Decisions under uncertainty (ignorance and risk)</p><p>4 Quantifying likelihood: probability</p><p>5 Preference and utility</p><p>6 Information and its value</p><h6 id="Multi-agent-decisions-games"><a href="#Multi-agent-decisions-games" class="headerlink" title="Multi-agent decisions: games"></a>Multi-agent decisions: games</h6><p><strong>Teaching methodology:</strong></p><p>Mix of theoretical and applied</p><p>Universal principles rather than domain specifific knowledge</p><h4 id="2-Decision-problems-representation-决策问题-表示"><a href="#2-Decision-problems-representation-决策问题-表示" class="headerlink" title="2. Decision problems: representation 决策问题:表示"></a>2. Decision problems: representation 决策问题:表示</h4><p>The basic elements common to <em>decision problems</em> are:</p><p><em>actions</em> (alternatives, strategies) (<em>A</em>)</p><p><em>possible states</em> (events, cases, scenarios) (<em>S</em>)</p><p><em>outcomes</em> (consequences) (Ω)</p><p>You’re the chief petroleum engineer of an oil company which owns a drilling option on an area of sea. Should you drill before the option expires?</p><p><strong><em>actions</em> (<em>A</em>)</strong>: Drill (D), Forfeit rights (F) (don’t drill (D))</p><p><strong><em>states</em> (<em>S</em>)</strong>: Oil present (<em>o</em>), no oil (<em>-o</em>)</p><p><strong><em>outcomes</em> (Ω)</strong>: Profifit ($30), loss (<em>(</em> $10), status quo ($0)</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926000450102.png" alt="image-20210926000450102"></p><h4 id="Decision-trees"><a href="#Decision-trees" class="headerlink" title="Decision trees"></a>Decision trees</h4><p>In a decision tree:</p><ul><li><p>leaf nodes represent outcomes</p></li><li><p>branches represent either actions or states/events</p></li><li><p>internal nodes can be <em>decision nodes</em> (boxes) or <em>chance nodes</em> (circles)</p></li></ul><h4 id="Decision-tables"><a href="#Decision-tables" class="headerlink" title="Decision tables"></a>Decision tables</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926000808665.png" alt="image-20210926000808665"></p><p><strong>Decision tables:</strong></p><ul><li><p>row = action</p></li><li><p>column = state</p></li><li><p>Interpretation: B = <em>ω</em>(D<em>, o</em>) means “B is the outcome of action D in state <em>o</em>”</p></li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926000938717.png" alt="image-20210926000938717"></p><p>A decision table represents the 2-ary function <em>ω</em> : <em>A × S →</em> Ω, where <em>A</em> = <em>{**A</em>_1<em>, . . . , A_m} and </em>S<em> = </em>{s_1<em>, . . . , s_n}; entry in </em>j<em>-th row and </em>k<em>-th column is ω_jk = </em>ω<em>(</em>A_j<em> </em>, s_k*) </p><p>Formally, a decision problem is a 4-tuple (A, Ω, S, ω)</p><h4 id="Decision-and-preference"><a href="#Decision-and-preference" class="headerlink" title="Decision and preference"></a>Decision and preference</h4><p>Outcomes are objective but agents have <em>subjective</em> (individual) <em>preferences</em> over them</p><p>Often assign each outcome a numerical <em>value</em>; <em>e.g</em>., money, distance,</p><p><em>etc</em>. <em>i.e.</em>, each agent has its own <em>value function</em>: <em>v</em> : Ω <em>→</em> R</p><p>Value functions/actions essentially are <em>random variables</em></p><p>A (subjective) decision problem is now: (<em>A**,</em> <em>S**,</em> Ω<em>, ω, v</em>)</p><p><strong>Convention</strong>: Value assignments usually assign higher values to more preferred (more desirable) outcomes.</p><p>公约：价值分配通常将更高的价值分配给更优先(更可取)的结果。</p><h4 id="Epistemic-state-认知状态"><a href="#Epistemic-state-认知状态" class="headerlink" title="Epistemic state 认知状态"></a>Epistemic state 认知状态</h4><p>Defifinition (Epistemic state) : An agent’s epistemic state is the knowledge (information) or belief it has about the actual state of the world.</p><p>个体的认知状态是它对世界的实际状态所拥有的知识(信息)或信念。</p><h4 id="Decision-problems-and-rules"><a href="#Decision-problems-and-rules" class="headerlink" title="Decision problems and rules"></a>Decision problems and rules</h4><p><strong>Fundamental problem of decision theory</strong>: For any given decision problem, to come up with a rational choice from among the possible actions.</p><p><strong>决策理论的基本问题</strong>：对于任何给定的决策问题，从可能的行动中提出一个理性的选择。</p><p><strong>Defifinition (Decision rule):</strong> A <em>decision rule</em> is a way of choosing, for each decision problem, an action or set of actions.</p><p><strong>定义(决策规则)：</strong>一个<em>决策规则</em>是一种选择方法，对于每个决策问题，一个行动或一组行动。</p><h3 id="3-Decision-problem-classes"><a href="#3-Decision-problem-classes" class="headerlink" title="3. Decision problem classes"></a>3. Decision problem classes</h3><p>Decision problems can be classifified based on an agent’s epistemic state:</p><ul><li><p>Decisions under <em>certainty</em>: the agent knows the unique actual state</p></li><li><p>Decisions under <em>uncertainty</em>:</p><ul><li><p>Decisions under <em>ignorance</em> (full uncertainty): the agent believes multiple states/outcomes are possible; likelihoods unknown</p></li><li><p>Decisions under <em>risk</em>: the agent believes multiple states/outcomes are possible; likelihood information available</p></li></ul></li></ul><h3 id="4-Decisions-under-certainty"><a href="#4-Decisions-under-certainty" class="headerlink" title="4. Decisions under certainty"></a>4. Decisions under certainty</h3><h4 id="Composite-outcomes-Net-Present-Value-NPV-综合结果-净现值-NPV"><a href="#Composite-outcomes-Net-Present-Value-NPV-综合结果-净现值-NPV" class="headerlink" title="Composite outcomes: Net Present Value (NPV) 综合结果:净现值(NPV)"></a>Composite outcomes: Net Present Value (NPV) 综合结果:净现值(NPV)</h4><p><strong>The Net Present Value (NPV)</strong>: value of the project in <em>present</em> terms</p><p>Future worth less than in the present</p><p>Model by a <em>discount rate</em> (<em>γ</em>); assume discount rate of 20%</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210926003032828.png" alt="image-20210926003032828"></p><h4 id="Decisions-under-certainty"><a href="#Decisions-under-certainty" class="headerlink" title="Decisions under certainty"></a>Decisions under certainty</h4><p><strong>value functions</strong></p><p>Value function over <em>outcomes</em>:  <em>v</em> : Ω <em>→</em> R</p><p>Value function over <em>actions</em></p><h6 id="Rational-decisions"><a href="#Rational-decisions" class="headerlink" title="Rational decisions"></a>Rational decisions</h6><p>A normative theory of decision-making: i.e., decisions ideal (rational) decision-makers ought to make</p><p><strong>Rationality Principle 1 (Elimination)</strong>: Faced with two possible alternatives, rational agents should never choose the less preferred one.</p><p><strong>理性原则1(消除)</strong>:面对两种可能的选择，理性的行动者永远不应该选择较不喜欢的那个。</p><p>It is irrational to choose a less preferred alternative. 选择一个不太受欢迎的替代品是不理性的。</p><p>Corollary: A rational agent should not choose any action which is not preference maximal.</p><p>推论：一个理性的行动者不应该选择任何非偏好最大的行为。</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> GSOE9210 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络与深度学习（2）</title>
      <link href="/2021/09/24/unsw/comp9444/shen-jing-wang-luo-yu-shen-du-xue-xi-2/"/>
      <url>/2021/09/24/unsw/comp9444/shen-jing-wang-luo-yu-shen-du-xue-xi-2/</url>
      
        <content type="html"><![CDATA[<h2 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h2><p>review certain topics from probability</p><p>the issue of generalization and overfitting in supervised learning.</p><p>classification tasks as alternatives to the sum squared error loss function</p><p>describe weight decay, momentum, and adaptive moment estimation</p><p>Maximum Likelihood Estimation (MLE) and Maximum A Posteriori (MAP) Estimation.</p><h2 id="probability-可能性"><a class="markdownIt-Anchor" href="#probability-可能性"></a> Probability 可能性</h2><h4 id="gaussian-distributions-高斯分布"><a class="markdownIt-Anchor" href="#gaussian-distributions-高斯分布"></a> Gaussian Distributions 高斯分布</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924144410079.png" alt="image-20210924144410079"></p><p>The <strong>Gaussian</strong> distribution with mean <em>μ</em> （均值）and standard deviation <em>σ</em> （标准差）is given by</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924144442805.png" alt="image-20210924144442805"></p><p>The d-dimensional <strong>multivariate Gaussian 多元高斯</strong> with mean <em>μ</em> and covariance 协方差 Σ is given by</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924154206729.png" alt="image-20210924154206729"></p><p>如果协方差 Σ是diagonal 对角的，那么多元高斯化简为一维高斯的乘积：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924154353687.png" alt="image-20210924154353687"></p><p>当 <em>μ</em>=0, Σ=I，时，称为<strong>Standard Normal</strong> distribution 标准正态分布</p><h4 id="conditional-probability-条件概率"><a class="markdownIt-Anchor" href="#conditional-probability-条件概率"></a> Conditional Probability 条件概率</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924154604108.png" alt="image-20210924154604108"></p><p>If P(B) ≠ 0, then the <strong>conditional probability</strong> of <em>A</em> given <em>B</em> is</p><h4 id="bayes-rule-贝叶斯规则"><a class="markdownIt-Anchor" href="#bayes-rule-贝叶斯规则"></a> Bayes’ Rule 贝叶斯规则</h4><p>当两个变量交换时，可以对条件概率公式进行操作，以找到它们之间的关系：</p><p><em>P</em>(<em>A</em>∩<em>B</em>)=<em>P</em>(<em>A</em>∣<em>B</em>)<em>P</em>(<em>B</em>)=<em>P</em>(<em>B</em>∣<em>A</em>)<em>P</em>(<em>A</em>)</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924154833728.png" alt="image-20210924154833728"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924154931403.png" alt="image-20210924154931403"></p><h4 id="example-light-bulb-defects"><a class="markdownIt-Anchor" href="#example-light-bulb-defects"></a> Example: Light Bulb Defects</h4><p>公司A，市场占有率60%，损坏率1%；公司B，市场占有率40%，损坏率2%。如果有一个灯泡坏了，是A公司生产的概率多大？</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924155346560.png" alt="image-20210924155346560"></p><h2 id="generalisation-and-overfitting-一般化和过度拟合"><a class="markdownIt-Anchor" href="#generalisation-and-overfitting-一般化和过度拟合"></a> Generalisation and Overfitting 一般化和过度拟合</h2><p>Supervised (Week 1-5, 7), Reinforcement (Week 8) and Unsupervised Learning (Week 9)</p><h3 id="supervised-learning-监督学习"><a class="markdownIt-Anchor" href="#supervised-learning-监督学习"></a> Supervised Learning 监督学习</h3><p>a <strong>training</strong> set and a <strong>test</strong> set 训练集和测试集</p><p>Supervised Learning learning paradigms: Decision Trees, K-Nearest-Neighbors, Support Vector Machine, Random Forest, etc.</p><h4 id="curve-fitting-example"><a class="markdownIt-Anchor" href="#curve-fitting-example"></a> Curve Fitting Example</h4><p>所谓过拟合<strong>overfitting</strong>，就是在训练集上预测性非常好，但是对测试集预测结果不佳。</p><p>好的泛化 good <strong>generalization</strong> 是在训练集和测试集上都达到了好的准确度 good accuracy</p><p>避免过拟合的方法有：</p><ul><li>limiting the number of neurons or connections in the network</li><li>early stopping, with a validation set</li><li>dropout</li><li>weight decay (this can avoid overfitting by limiting the size of the weights)</li></ul><h4 id="ockhams-razor-奥卡姆剃刀"><a class="markdownIt-Anchor" href="#ockhams-razor-奥卡姆剃刀"></a> Ockham’s Razor 奥卡姆剃刀</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924161433066.png" alt="image-20210924161433066"></p><h4 id="noise-in-the-training-data-训练数据中的噪声"><a class="markdownIt-Anchor" href="#noise-in-the-training-data-训练数据中的噪声"></a> Noise in the training data 训练数据中的噪声</h4><p>Outliers 离群值</p><h4 id="training-validation-and-test-error-训练-验证和测试错误"><a class="markdownIt-Anchor" href="#training-validation-and-test-error-训练-验证和测试错误"></a> Training, validation and test error 训练、验证和测试错误</h4><p>One way: limit the number of hidden nodes<br>divide the data into Training, Validation and Test sets</p><p>Construct a Huffmann tree<br>Compute Entropy  <strong>H§</strong> = Σ( - p log p )</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924191148625.png" alt="image-20210924191148625"></p><p>Compute KL-Divergence  D_KL(p||q) = Σ H(q)-H§</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924191248482.png" alt="image-20210924191248482"></p><h2 id="cross-entropy-and-softmax-交叉熵和softmax"><a class="markdownIt-Anchor" href="#cross-entropy-and-softmax-交叉熵和softmax"></a> Cross Entropy and Softmax 交叉熵和Softmax</h2><h4 id="loss-functions"><a class="markdownIt-Anchor" href="#loss-functions"></a> Loss Functions</h4><p><strong>sum squared error</strong> (<strong>SSE</strong>) 求和平方差</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924193723859.png" alt="image-20210924193723859"></p><p><strong>binary classification</strong>, use <strong>cross entropy</strong></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924193939597.png" alt="image-20210924193939597"></p><h4 id="maximum-likelihood"><a class="markdownIt-Anchor" href="#maximum-likelihood"></a> Maximum Likelihood</h4><p>Let H be a class of <strong>hypotheses</strong> for predicting certain <strong>data</strong> D</p><p>Let Prob(D∣<em>h</em>) be the probability of data D being generated under hypothesis h∈H.</p><p>The logarithm of this probability, log Prob(D∣<em>h</em>) is called the <strong>likelihood</strong>.</p><p><strong>Maximum Likelihood Principle</strong>: choose h∈H which maximizes this likelihood</p><p>the data D consist of a target value <em>t_i</em> for each set of input features <em>x_i</em> in a Supervised Learning task</p><p>each hypothesis <em>h</em> as a function<em>f</em>() or <em>y</em>-intercept</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924195406921.png" alt="image-20210924195406921"></p><h4 id="derivation-of-least-squares-最小二乘求导"><a class="markdownIt-Anchor" href="#derivation-of-least-squares-最小二乘求导"></a> Derivation of Least Squares 最小二乘求导</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924195854899.png" alt="image-20210924195854899"></p><p>we do not need to know the value of <em>σ</em></p><h4 id="derivation-of-cross-entropy-交叉熵的推导"><a class="markdownIt-Anchor" href="#derivation-of-cross-entropy-交叉熵的推导"></a> Derivation of Cross Entropy 交叉熵的推导</h4><p>For binary classification tasks,  the <strong>probability</strong> is:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924200126423.png" alt="image-20210924200126423"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924200133931.png" alt="image-20210924200133931"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924200610624.png" alt="image-20210924200610624"></p><p>SSE and cross entropy behave a bit differently when it comes to outliers:</p><p>SSE is more likely to allow outliers in the training set to be misclassified</p><p>Cross Entropy is more likely to keep outliers correctly classified</p><p>Cross Entropy works particularly well for classification tasks that are <strong>unbalanced</strong> in the sense of negative items vastly outnumbering positive ones</p><h4 id="log-softmax-对数softmax"><a class="markdownIt-Anchor" href="#log-softmax-对数softmax"></a> Log Softmax 对数Softmax</h4><p>assumption: the network’s estimate for the probability of class <em>j</em> is proportional to exp(<em>z_j</em>).</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924201222544.png" alt="image-20210924201222544"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924201615237.png" alt="image-20210924201615237"></p><p><em>δik</em> is the <a href="https://en.wikipedia.org/wiki/Kronecker_delta">Kronecker delta</a>.</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924202826098.png" alt="image-20210924202826098"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924203014255.png" alt="image-20210924203014255"></p><p>The first term pushes up the correct class i=k<em>i</em>=<em>k</em> in proportion to the distance of its assigned probability from 1, while the second term pushes down the incorrect classes i\neq k<em>i</em>\=<em>k</em> in proportion to the probabilities assigned to them.</p><h4 id="softmax-compared-to-boltzmann-distribution-and-sigmoid-softmax-玻尔兹曼分布和sigmoid分布的比较"><a class="markdownIt-Anchor" href="#softmax-compared-to-boltzmann-distribution-and-sigmoid-softmax-玻尔兹曼分布和sigmoid分布的比较"></a> Softmax compared to Boltzmann Distribution and Sigmoid   Softmax、玻尔兹曼分布和Sigmoid分布的比较</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924202401341.png" alt="image-20210924202401341"></p><h2 id="weight-decay-and-momentum-重量衰减和动量"><a class="markdownIt-Anchor" href="#weight-decay-and-momentum-重量衰减和动量"></a> Weight Decay and Momentum 重量衰减和动量</h2><h4 id="weight-decay"><a class="markdownIt-Anchor" href="#weight-decay"></a> Weight Decay</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924203840689.png" alt="image-20210924203840689"></p><h4 id="bayesian-inference-and-map-estimation-贝叶斯推理和map估计"><a class="markdownIt-Anchor" href="#bayesian-inference-and-map-estimation-贝叶斯推理和map估计"></a> Bayesian Inference and MAP estimation 贝叶斯推理和MAP估计</h4><p>Bayes’ Theorem:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924204131345.png" alt="image-20210924204131345"></p><p>Prob(<em>h</em>) : the <strong>prior</strong> probability of <em>h</em> 先验概率</p><p>Prob(<em>h</em>∣D) : the <strong>posterior</strong> probability  后验概率</p><p>maximizing Prob(<em>h</em>∣D): Maximum A Posteriori or <strong>MAP</strong> estimation</p><h4 id="weight-decay-as-map-estimation-权值衰减作为map估计"><a class="markdownIt-Anchor" href="#weight-decay-as-map-estimation-权值衰减作为map估计"></a> Weight Decay as MAP Estimation 权值衰减作为MAP估计</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924204553399.png" alt="image-20210924204553399"></p><p>four kind of Loss functions 四种成本函数：<br><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924211014258.png" alt="image-20210924211014258"></p><h4 id="momentum-动量"><a class="markdownIt-Anchor" href="#momentum-动量"></a> Momentum 动量</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924204816435.png" alt="image-20210924204816435"></p><p>The parameter <em>α</em>∈[0,1) is called the <strong>Momentum</strong>.</p><p>好处1：speed up the learning in a flat region</p><p>好处2：如果地形的形状像一个“雨水槽”，重量就会摆动，不会有太大的改善。</p><p>从理论上讲，动量会减弱横向振动，但会将下坡运动放大 1/(1-α)</p><p>当引入动量时，我们通常会同时降低学习率，以补偿 1/(1-α) 这一隐含因子。</p><h4 id="adaptive-moment-estimation-adam-自适应矩估计adam"><a class="markdownIt-Anchor" href="#adaptive-moment-estimation-adam-自适应矩估计adam"></a> Adaptive Moment Estimation (Adam) 自适应矩估计(Adam)</h4><p>Adaptive Moment Estimation or <strong>Adam</strong> maintains a running average of the gradients (<em>m_t</em>) and the squared gradients (<em>g_t</em>) for each weight in the network.</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924205552742.png" alt="image-20210924205552742"></p><p>To speed up the training in the early stages,</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924205641660.png" alt="image-20210924205641660"></p><p>最后，根据以下方法对各参数进行调整:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924205721653.png" alt="image-20210924205721653"></p><h4 id="second-order-methods-二阶方法"><a class="markdownIt-Anchor" href="#second-order-methods-二阶方法"></a> Second Order Methods 二阶方法</h4><p>smaller networks, optimisation methods have  <a href="https://en.wikipedia.org/wiki/Conjugate_gradient_method">Conjugate Gradients</a> or Natural Gradients</p><p><em><strong>parabola</strong></em> n.抛物线</p><p><em><strong>gradient</strong></em> n. 梯度，陡度;</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> COMP9444 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络与深度学习（1）</title>
      <link href="/2021/09/23/unsw/comp9444/shen-jing-wang-luo-yu-shen-du-xue-xi-1/"/>
      <url>/2021/09/23/unsw/comp9444/shen-jing-wang-luo-yu-shen-du-xue-xi-1/</url>
      
        <content type="html"><![CDATA[<h2 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h2><p>historical background of artificial intelligence and deep learning</p><p>Perceptron</p><p>Heaviside step funtion</p><p>learning rate  η</p><p>Backpropagation</p><h2 id="history-and-neuroanatomy-历史和神经解剖学"><a class="markdownIt-Anchor" href="#history-and-neuroanatomy-历史和神经解剖学"></a> History and Neuroanatomy 历史和神经解剖学</h2><p>Sub-Symbolic处理</p><p>Basic Neuroanatomy 基本的神经解剖学</p><p>Cerebral Cortex 大脑皮层</p><p>Brain Functions</p><p>Neurons 神经</p><p>Synapses, Neurotransmitter and Ion Channels 突触，神经递质和离子通道</p><h2 id="biological-vs-artificial-neurons"><a class="markdownIt-Anchor" href="#biological-vs-artificial-neurons"></a> Biological vs Artificial Neurons</h2><p>McCulloch and Pitts Neuron</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923210630469.png" alt="image-20210923210630469"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923210717727.png" alt="image-20210923210717727"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923210801043.png" alt="image-20210923210801043"></p><h3 id="transfer-function-传递函数"><a class="markdownIt-Anchor" href="#transfer-function-传递函数"></a> Transfer function  传递函数</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923210941590.png" alt="image-20210923210941590"></p><h3 id="linear-separability-线性可分性"><a class="markdownIt-Anchor" href="#linear-separability-线性可分性"></a> Linear separability 线性可分性</h3><p>Linearly Separable 线性可分的</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923211203749.png" alt="image-20210923211203749"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923211425314.png" alt="image-20210923211425314"></p><h2 id="perceptron-learning-algorithm-感知器学习算法"><a class="markdownIt-Anchor" href="#perceptron-learning-algorithm-感知器学习算法"></a> Perceptron Learning Algorithm 感知器学习算法</h2><p>Supervised Learning 监督式学习</p><p>Reinforcement Learning 强化学习</p><p>Unsupervised Learning 非监督学习</p><p><strong>Supervised Learning</strong>: The system is presented with training items consisting of an input and a target output. The aim is to predict the output, given the input (for the training set as well as an unseen test set).</p><p><strong>Reinforcement Learning</strong>: The system chooses actions in a simulated environment, observing its state and receiving rewards along the way. The aim is to maximize the cumulative reward.</p><p><strong>Unsupervised Learning</strong>: The system is presented with training items consisting of only an input (no target value). The aim is to extract hidden features or other structure from these data.</p><h3 id="rosenblatt-perceptron-rosenblatt感知器"><a class="markdownIt-Anchor" href="#rosenblatt-perceptron-rosenblatt感知器"></a> Rosenblatt Perceptron Rosenblatt感知器</h3><h3 id="perceptron-learning-algorithm"><a class="markdownIt-Anchor" href="#perceptron-learning-algorithm"></a> Perceptron Learning Algorithm</h3><p>learning rate 学习速率 η&gt;0</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923212058531.png" alt="image-20210923212058531"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923212138140.png" alt="image-20210923212138140"></p><p>Rosenblatt证明，只要训练数据是线性可分的，该算法总是能够成功地对训练数据进行分类。</p><h2 id="multi-layer-perceptronsmlp-多层感知器"><a class="markdownIt-Anchor" href="#multi-layer-perceptronsmlp-多层感知器"></a> Multi Layer Perceptrons(MLP) 多层感知器</h2><h3 id="limitations-of-perceptrons"><a class="markdownIt-Anchor" href="#limitations-of-perceptrons"></a> Limitations of Perceptrons</h3><p>not linearly separable</p><h3 id="multi-layer-perceptrons"><a class="markdownIt-Anchor" href="#multi-layer-perceptrons"></a> Multi Layer Perceptrons</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923232559332.png" alt="image-20210923232559332"></p><h2 id="gradient-descent-梯度下降法"><a class="markdownIt-Anchor" href="#gradient-descent-梯度下降法"></a> Gradient Descent 梯度下降法</h2><p><strong>loss</strong> function E 成本函数E</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923233556398.png" alt="image-20210923233556398"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923233606928.png" alt="image-20210923233606928"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923233647066.png" alt="image-20210923233647066"></p><p><em>η</em> : <strong>learning rate</strong> 学习率</p><h3 id="gradient-descent-for-neural-networks-神经网络的梯度下降"><a class="markdownIt-Anchor" href="#gradient-descent-for-neural-networks-神经网络的梯度下降"></a> Gradient Descent for Neural Networks 神经网络的梯度下降</h3><h3 id="continuous-activation-functions-连续的激活函数"><a class="markdownIt-Anchor" href="#continuous-activation-functions-连续的激活函数"></a> Continuous Activation Functions 连续的激活函数</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923233933880.png" alt="image-20210923233933880"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923233943366.png" alt="image-20210923233943366"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923234041581.png" alt="image-20210923234041581"></p><h3 id="backpropagation-反向传播"><a class="markdownIt-Anchor" href="#backpropagation-反向传播"></a> Backpropagation 反向传播</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923234530342.png" alt="image-20210923234530342"></p><h4 id="chain-rule-链式法则"><a class="markdownIt-Anchor" href="#chain-rule-链式法则"></a> Chain Rule 链式法则</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923234623652.png" alt="image-20210923234623652"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923234657994.png" alt="image-20210923234657994"></p><h4 id="forward-pass"><a class="markdownIt-Anchor" href="#forward-pass"></a> Forward Pass</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923235012611.png" alt="image-20210923235012611"></p><h4 id="backward-pass-向后传递"><a class="markdownIt-Anchor" href="#backward-pass-向后传递"></a> Backward Pass 向后传递</h4><p>Partial Derivatives</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923234916330.png" alt="image-20210923234916330"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923235115658.png" alt="image-20210923235115658"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210923235122179.png" alt="image-20210923235122179"></p><h2 id="neural-network-training-神经网络训练"><a class="markdownIt-Anchor" href="#neural-network-training-神经网络训练"></a> Neural Network Training 神经网络训练</h2><h3 id="example-pima-indians-diabetes-dataset-例如皮马印第安人糖尿病数据集"><a class="markdownIt-Anchor" href="#example-pima-indians-diabetes-dataset-例如皮马印第安人糖尿病数据集"></a> Example: Pima Indians Diabetes Dataset 例如:皮马印第安人糖尿病数据集</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924000154899.png" alt="image-20210924000154899"></p><p><strong>Batch Learning</strong> 批处理学习</p><p><strong>Online Learning</strong> 在线学习</p><p><strong>Minibatch Learning</strong> Minibatch学习</p><p><strong>Stochastic Gradient Descent</strong> (SGD) 随机梯度下降(SGD) 包括 Online Learning 和 Minibatch Learning</p><p><strong>temporal correlations</strong> 临时相关性</p><h3 id="autonomous-driving-and-hinton-diagrams-自动驾驶和欣顿图表"><a class="markdownIt-Anchor" href="#autonomous-driving-and-hinton-diagrams-自动驾驶和欣顿图表"></a> Autonomous Driving and Hinton Diagrams 自动驾驶和欣顿图表</h3><p>ALVINN (Autonomous Land Vehicle in a Neural Network)</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210924001106482.png" alt="image-20210924001106482"></p><h3 id="behavioral-cloning-data-augmentation-and-experience-replay-行为克隆-数据增强和经验重放"><a class="markdownIt-Anchor" href="#behavioral-cloning-data-augmentation-and-experience-replay-行为克隆-数据增强和经验重放"></a> Behavioral Cloning, Data Augmentation and Experience Replay 行为克隆、数据增强和经验重放</h3><p><strong>Data Augmentation</strong> Data上升</p><p><strong>Experience Replay</strong> 经验重播</p><p><em><strong>glia</strong></em> n. 神经胶质</p><p><em><strong>Perceptron</strong></em> n. 感知器</p><p><em><strong>threshold</strong></em> n. 门槛，门口；阈</p><p><em><strong>analogous</strong></em> adj. 类似的</p><p><em><strong>shorthand</strong></em> n. 速记 adj.速记的</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> COMP9444 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络与深度学习（0）</title>
      <link href="/2021/09/23/unsw/comp9444/shen-jing-wang-luo-yu-shen-du-xue-xi-0/"/>
      <url>/2021/09/23/unsw/comp9444/shen-jing-wang-luo-yu-shen-du-xue-xi-0/</url>
      
        <content type="html"><![CDATA[<h2 id="各周授课内容"><a href="#各周授课内容" class="headerlink" title="各周授课内容"></a>各周授课内容</h2><p><strong>Week 1</strong>: historical background, neuroanatomy, perceptrons, training of multi-layer neural networks by gradient descent.</p><p><strong>Week 2</strong>: probability, supervised learning, generalization and overfitting, dropout, cross entropy, softmax, weight decay and momentum.</p><p><strong>Week 3</strong>: introduction to PyTorch, analysis of hidden unit dynamics.</p><p><strong>Week 4</strong>: image processing and object recognition, including convolutional networks, weight initialization, batch normalization, skip connections and dense blocks.</p><p><strong>Week 5</strong>: recurrent neural networks, SRN, LSTM, GRU, hidden unit dynamics.</p><p><strong>Week 6</strong>: flexibility week</p><p><strong>Week 7</strong>: word vectors, sequence and language processing.</p><p><strong>Week 8</strong>: reinforcement learning, models of optimality, TD-learning, Q-learning, policy gradients, actor-critic, deep reinforcement learning.</p><p><strong>Week 9</strong>: unsupervised learning, autoencoders, artist-critic coevolution, generative adversarial networks.</p><p><strong>Week 10</strong>: generative adversarial networks.</p><p><strong>第1周</strong>:历史背景，神经解剖学，感知器，梯度下降的多层神经网络训练。</p><p><strong>第2周</strong>:概率、监督学习、泛化和过拟合、dropout、交叉熵、softmax、权值衰减和动量。</p><p><strong>第3周</strong>:介绍PyTorch，分析隐藏单元动态。</p><p><strong>第4周</strong>:图像处理和目标识别，包括卷积网络、权值初始化、批处理归一化、跳过连接和密集块。</p><p><strong>第5周</strong>:递归神经网络，SRN, LSTM, GRU，隐单元动力学。</p><p>**周:弹性周</p><p><strong>第7周</strong>:单词向量、序列和语言处理。</p><p><strong>第8周</strong>:强化学习、最优化模型、TD-learning、Q-learning、政策梯度、行动者-批评、深度强化学习。</p><p><strong>第9周</strong>:无监督学习，自动编码器，艺术家-评论家共同进化，生成式对抗网络。</p><p><strong>第10周</strong>:生成式对抗网络。</p><h2 id="Python-refresher"><a href="#Python-refresher" class="headerlink" title="Python refresher"></a>Python refresher</h2><p>print相关用法</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print('Hello')print('Hello' + ' ' + 'world')print('Hello', 'world')print('Hello' + ' ' + 'world')print('Hello' + '\t' + 'world')print('Hello' + '\n' + 'world')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文本中的用法</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(len('Hello'))print(len('  Hello '))print(len('  Hello '.strip()))print('Hello.'.strip())print('Hello.'.strip('.'))passage = "Hello. My name is Ben. I am 185cm tall."words = passage.split(' ')sentences = passage.split('.')print(words)print(sentences)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列表相关用法<br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">numbers = [1, 2, 3, 4, 5]print(numbers)print(len(numbers))# Print the first item:print(numbers[0])# Print the last item:print(numbers[-1])for n in numbers:    print(2 * n)    words = ['dog', 'cat', 'mouse', 'goat', 'python']words.sort()print(words)letters = ['h', 'e', 'l', 'l', 'o']print(''.join(letters))print('-'.join(letters))print('[ ]'.join(letters))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>字典相关用法<br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pet_frequencies = {'dog': 17, 'cat': 12}print(pet_frequencies['dog'])pet_frequencies['mouse'] = 3print(pet_frequencies['mouse'])pet_frequencies = {'dog': 17, 'cat': 12, 'mouse': 3}print(pet_frequencies.get('hare'))print(pet_frequencies.get('hare', 0))print(pet_frequencies.get('hare', 'No such pet'))pet_frequencies = {'dog': 17, 'cat': 12, 'mouse': 3}for key, value in pet_frequencies.items():    print(key, value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>类型转换<br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">word = 'Hello'number = 2print(word + number)word = 'Hello'number = 2print(word/number)word = 'Hello'number = 2print(word + str(number))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>Built-in functions 内置函数 Lambda functions 拉姆达函数<br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># max() takes two or more arguments and returns the maximum valueprint(max(3, 5, 0, 4))# max() can also take a list as argumentprint(max([3, 5, 0, 4]))# sum() takes a list as argument and returns the sum of its elementsprint(sum([3, 5, 0, 4]))add = lambda x, y: x + yprint(add(3, 4))words = ['dog', 'cat', 'mouse', 'goat', 'python']first_letters = map(lambda word: word[0], words)for letter in first_letters:    print(letter)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>Yielding values<br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def numbers():    return [1,2,3,4,5]for x in numbers():    print(x)    def numbers():    for x in [1,2,3,4,5]:        yield xfor x in numbers():    print(x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>定义类</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Person:    def __init__(self, firstName, lastName):        self.firstName = firstName        self.lastName = lastName    def fullName(self):        return self.firstName + ' ' + self.lastName    def reverseName(self, initialOnly = False):        if initialOnly:            return self.lastName + ', ' + self.firstName[0] + '.'        else:            return self.lastName + ', ' + self.firstNameperson = Person('Jacinda', 'Ardern')print(person.fullName())print(person.reverseName())print(person.reverseName(True))class Person:    def __init__(self, firstName, lastName):        self.firstName = firstName        self.lastName = lastName    def fullName(self):        return self.firstName + ' ' + self.lastNameclass Boy(Person):    def fullName(self):        return 'Master ' + self.firstName + ' ' + self.lastNameperson = Person('Jacinda', 'Ardern')print(person.fullName())boy = Boy('Stuart', 'Simpson')print(boy.fullName())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引用包<br></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import mathprint(math.floor(2.76))from math import floorprint(floor(2.76))def triple(x):    return x * 3if __name__ == '__main__':    print(triple(6))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>使用标准输入</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import sysfor line in sys.stdin:    line = line.strip()    if line == 'exit':        break    else:        print('You entered ' + line)print('Done')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><p>Arrays</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npa = np.array([1, 2, 3])   # Create a rank 1 arrayprint(type(a))            # Prints "&lt;class 'numpy.ndarray'&gt;"print(a.shape)            # Prints "(3,)"print(a[0], a[1], a[2])   # Prints "1 2 3"a[0] = 5                  # Change an element of the arrayprint(a)                  # Prints "[5, 2, 3]"b = np.array([[1,2,3],[4,5,6]])    # Create a rank 2 arrayprint(b.shape)                     # Prints "(2, 3)"print(b[0, 0], b[0, 1], b[1, 0])   # Prints "1 2 4"# 创建矩阵——带默认值import numpy as npa = np.zeros((2,2))   # Create an array of all zerosprint(a)              # Prints "[[ 0.  0.]                      #          [ 0.  0.]]"b = np.ones((1,2))    # Create an array of all onesprint(b)              # Prints "[[ 1.  1.]]"c = np.full((2,2), 7)  # Create a constant arrayprint(c)               # Prints "[[ 7.  7.]                       #          [ 7.  7.]]"d = np.eye(2)         # Create a 2x2 identity matrixprint(d)              # Prints "[[ 1.  0.]                      #          [ 0.  1.]]"e = np.random.random((2,2))  # Create an array filled with random valuesprint(e)                     # Might print "[[ 0.91940167  0.08143941]                             #               [ 0.68744134  0.87236687]]"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Array indexing</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as np# Create the following rank 2 array with shape (3, 4)# [[ 1  2  3  4]#  [ 5  6  7  8]#  [ 9 10 11 12]]a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])# Use slicing to pull out the subarray consisting of the first 2 rows# and columns 1 and 2; b is the following array of shape (2, 2):# [[2 3]#  [6 7]]b = a[:2, 1:3]# A slice of an array is a view into the same data, so modifying it# will modify the original array.print(a[0, 1])   # Prints "2"b[0, 0] = 77     # b[0, 0] is the same piece of data as a[0, 1]print(a[0, 1])   # Prints "77"import numpy as np# Create the following rank 2 array with shape (3, 4)# [[ 1  2  3  4]#  [ 5  6  7  8]#  [ 9 10 11 12]]a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])# Two ways of accessing the data in the middle row of the array.# Mixing integer indexing with slices yields an array of lower rank,# while using only slices yields an array of the same rank as the# original array:row_r1 = a[1, :]    # Rank 1 view of the second row of arow_r2 = a[1:2, :]  # Rank 2 view of the second row of aprint(row_r1, row_r1.shape)  # Prints "[5 6 7 8] (4,)"print(row_r2, row_r2.shape)  # Prints "[[5 6 7 8]] (1, 4)"# We can make the same distinction when accessing columns of an array:col_r1 = a[:, 1]col_r2 = a[:, 1:2]print(col_r1, col_r1.shape)  # Prints "[ 2  6 10] (3,)"print(col_r2, col_r2.shape)  # Prints "[[ 2]                             #          [ 6]                             #          [10]] (3, 1)"                                                          import numpy as npa = np.array([[1,2], [3, 4], [5, 6]])# An example of integer array indexing.# The returned array will have shape (3,) andprint(a[[0, 1, 2], [0, 1, 0]])  # Prints "[1 4 5]"# The above example of integer array indexing is equivalent to this:print(np.array([a[0, 0], a[1, 1], a[2, 0]]))  # Prints "[1 4 5]"# When using integer array indexing, you can reuse the same# element from the source array:print(a[[0, 0], [1, 1]])  # Prints "[2 2]"# Equivalent to the previous integer array indexing exampleprint(np.array([a[0, 1], a[0, 1]]))  # Prints "[2 2]"import numpy as np# Create a new array from which we will select elementsa = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])print(a)  # prints "array([[ 1,  2,  3],          #                [ 4,  5,  6],          #                [ 7,  8,  9],          #                [10, 11, 12]])"# Create an array of indicesb = np.array([0, 2, 0, 1])# Select one element from each row of a using the indices in bprint(a[np.arange(4), b])  # Prints "[ 1  6  7 11]"# Mutate one element from each row of a using the indices in ba[np.arange(4), b] += 10print(a)  # prints "array([[11,  2,  3],          #                [ 4,  5, 16],          #                [17,  8,  9],          #                [10, 21, 12]])                    # Boolean array indexingimport numpy as npa = np.array([[1,2], [3, 4], [5, 6]])bool_idx = (a &gt; 2)   # Find the elements of a that are bigger than 2;                     # this returns a numpy array of Booleans of the same                     # shape as a, where each slot of bool_idx tells                     # whether that element of a is &gt; 2.print(bool_idx)      # Prints "[[False False]                     #          [ True  True]                     #          [ True  True]]"# We use boolean array indexing to construct a rank 1 array# consisting of the elements of a corresponding to the True values# of bool_idxprint(a[bool_idx])  # Prints "[3 4 5 6]"# We can do all of the above in a single concise statement:print(a[a &gt; 2])     # Prints "[3 4 5 6]"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Datatypes</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npx = np.array([[1,2],[3,4]], dtype=np.float64)y = np.array([[5,6],[7,8]], dtype=np.float64)# Elementwise sum; both produce the array# [[ 6.0  8.0]#  [10.0 12.0]]print(x + y)print(np.add(x, y))# Elementwise difference; both produce the array# [[-4.0 -4.0]#  [-4.0 -4.0]]print(x - y)print(np.subtract(x, y))# Elementwise product; both produce the array# [[ 5.0 12.0]#  [21.0 32.0]]print(x * y)print(np.multiply(x, y))# Elementwise division; both produce the array# [[ 0.2         0.33333333]#  [ 0.42857143  0.5       ]]print(x / y)print(np.divide(x, y))# Elementwise square root; produces the array# [[ 1.          1.41421356]#  [ 1.73205081  2.        ]]print(np.sqrt(x))import numpy as npx = np.array([[1,2],[3,4]])y = np.array([[5,6],[7,8]])v = np.array([9,10])w = np.array([11, 12])# Inner product of vectors; both produce 219print(v.dot(w))print(np.dot(v, w))# Matrix / vector product; both produce the rank 1 array [29 67]print(x.dot(v))print(np.dot(x, v))# Matrix / matrix product; both produce the rank 2 array# [[19 22]#  [43 50]]print(x.dot(y))print(np.dot(x, y))import numpy as npx = np.array([[1,2],[3,4]])print(np.sum(x))  # Compute sum of all elements; prints "10"print(np.sum(x, axis=0))  # Compute sum of each column; prints "[4 6]"print(np.sum(x, axis=1))  # Compute sum of each row; prints "[3 7]"import numpy as npx = np.array([[1,2], [3,4]])print(x)    # Prints "[[1 2]            #          [3 4]]"print(x.T)  # Prints "[[1 3]            #          [2 4]]"# Note that taking the transpose of a rank 1 array does nothing:v = np.array([1,2,3])print(v)    # Prints "[1 2 3]"print(v.T)  # Prints "[1 2 3]"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>![numpy的函数]<a href="https://numpy.org/doc/stable/reference/routines.math.html">https://numpy.org/doc/stable/reference/routines.math.html</a></p><p>Broadcasting</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as np# We will add the vector v to each row of the matrix x,# storing the result in the matrix yx = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])v = np.array([1, 0, 1])y = np.empty_like(x)   # Create an empty matrix with the same shape as x# Add the vector v to each row of the matrix x with an explicit loopfor i in range(4):    y[i, :] = x[i, :] + v# Now y is the following# [[ 2  2  4]#  [ 5  5  7]#  [ 8  8 10]#  [11 11 13]]print(y)import numpy as np# We will add the vector v to each row of the matrix x,# storing the result in the matrix yx = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])v = np.array([1, 0, 1])vv = np.tile(v, (4, 1))   # Stack 4 copies of v on top of each otherprint(vv)                 # Prints "[[1 0 1]                          #          [1 0 1]                          #          [1 0 1]                          #          [1 0 1]]"y = x + vv  # Add x and vv elementwiseprint(y)  # Prints "[[ 2  2  4          #          [ 5  5  7]          #          [ 8  8 10]          #          [11 11 13]]"                    import numpy as np# We will add the vector v to each row of the matrix x,# storing the result in the matrix yx = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])v = np.array([1, 0, 1])y = x + v  # Add v to each row of x using broadcastingprint(y)  # Prints "[[ 2  2  4]          #          [ 5  5  7]          #          [ 8  8 10]          #          [11 11 13]]"                    import numpy as np# Compute outer product of vectorsv = np.array([1,2,3])  # v has shape (3,)w = np.array([4,5])    # w has shape (2,)# To compute an outer product, we first reshape v to be a column# vector of shape (3, 1); we can then broadcast it against w to yield# an output of shape (3, 2), which is the outer product of v and w:# [[ 4  5]#  [ 8 10]#  [12 15]]print(np.reshape(v, (3, 1)) * w)# Add a vector to each row of a matrixx = np.array([[1,2,3], [4,5,6]])# x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),# giving the following matrix:# [[2 4 6]#  [5 7 9]]print(x + v)# Add a vector to each column of a matrix# x has shape (2, 3) and w has shape (2,).# If we transpose x then it has shape (3, 2) and can be broadcast# against w to yield a result of shape (3, 2); transposing this result# yields the final result of shape (2, 3) which is the matrix x with# the vector w added to each column. Gives the following matrix:# [[ 5  6  7]#  [ 9 10 11]]print((x.T + w).T)# Another solution is to reshape w to be a column vector of shape (2, 1);# we can then broadcast it directly against x to produce the same# output.print(x + np.reshape(w, (2, 1)))# Multiply a matrix by a constant:# x has shape (2, 3). Numpy treats scalars as arrays of shape ();# these can be broadcast together to shape (2, 3), producing the# following array:# [[ 2  4  6]#  [ 8 10 12]]print(x * 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p>Plot</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npimport matplotlib.pyplot as plt# We plot the graph of y = x^2x = np.arange(-10, 10) # x coordinatey = x**2 # y coordinateplt.plot(x, y) # Plot the graphplt.show()  # You need to call plt.show() to show the plotted graph<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Multiple functions</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npimport matplotlib.pyplot as plt# Create the x and y coordinatesx = np.arange(-10, 10) y1 = x**2 y2 = x**3# Plot multiple functionsplt.plot(x, y1)plt.plot(x, y2)plt.xlabel('x axis')plt.ylabel('y axis')plt.title('introduction to matplotlib')plt.legend(['x^2', 'x^3'])plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Subplot</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npimport matplotlib.pyplot as plt# subplot(nrows, ncols, plot_number)# Arugments are number of rows and colums of the plot # and the active plot number# Create the x and y coordinatesx = np.arange(-10, 10) y1 = x**2 y2 = x**3# Create a subplot grid with 1 row and 2 colums# and set the active plot number to 1plt.subplot(1, 2, 1)# Make the first plot at the active plot plt.plot(x, y1)plt.title('x^2')# Set the active plot number and make the second plotplt.subplot(1, 2, 2)plt.plot(x, y2)plt.title('x^3')# Show the figure.plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Multiple functions</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npimport matplotlib.pyplot as plt# Create the x and y coordinatesx = np.arange(-10, 10) y1 = x**2 y2 = x**3# Plot multiple functionsplt.plot(x, y1)plt.plot(x, y2)plt.xlabel('x axis')plt.ylabel('y axis')plt.title('introduction to matplotlib')plt.legend(['x^2', 'x^3'])plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Subplot</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npimport matplotlib.pyplot as plt# subplot(nrows, ncols, plot_number)# Arugments are number of rows and colums of the plot # and the active plot number# Create the x and y coordinatesx = np.arange(-10, 10) y1 = x**2 y2 = x**3# Create a subplot grid with 1 row and 2 colums# and set the active plot number to 1plt.subplot(1, 2, 1)# Make the first plot at the active plot plt.plot(x, y1)plt.title('x^2')# Set the active plot number and make the second plotplt.subplot(1, 2, 2)plt.plot(x, y2)plt.title('x^3')# Show the figure.plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Imshow</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npfrom cv2 import imreadimport matplotlib.pyplot as pltimg = imread('cat.jpg')# Plot the imageplt.imshow(img)# Imshow works better if the data is with type unit8, here we # cast the image to uint8 explicitly.plt.imshow(np.uint8(img))# Show the imageplt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Google-Colab"><a href="#Google-Colab" class="headerlink" title="Google Colab"></a>Google Colab</h2>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> COMP9444 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉课程笔记（1）</title>
      <link href="/2021/09/19/unsw/comp9517/ji-suan-ji-shi-jue-ke-cheng-bi-ji-1/"/>
      <url>/2021/09/19/unsw/comp9517/ji-suan-ji-shi-jue-ke-cheng-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-computer-vision"><a href="#What-is-computer-vision" class="headerlink" title="What is computer vision?"></a>What is computer vision?</h2><p><strong>Computer science perspective</strong>：Computer vision is the interdisciplinary field that develops theories and methods to allow computers extract relevant information from digital images or videos</p><p><strong>Computer engineering perspective</strong>：Computer vision is the interdisciplinary field that develops algorithms and tools to automate perceptual tasks normally performed by the human visual system</p><h4 id="Human-vision-has-its-limitations"><a href="#Human-vision-has-its-limitations" class="headerlink" title="Human vision has its limitations"></a><strong>Human vision has its limitations</strong></h4><p>• Intensities, shapes, patterns, motions can be misinterpreted</p><p>• Is labor intensive, time-consuming, subjective, error-prone</p><h4 id="Computer-vision-can-potentially-improve-this"><a href="#Computer-vision-can-potentially-improve-this" class="headerlink" title="Computer vision can potentially improve this"></a><strong>Computer vision can potentially improve this</strong></h4><p>• Can work day and night without getting tired</p><p>• Analyses information quantitatively and objectively</p><p>• Is potentially more accurate, precise, reproducible</p><h3 id="Application-image-classification-and-captioning"><a href="#Application-image-classification-and-captioning" class="headerlink" title="Application: image classification and captioning"></a>Application: image classification and captioning</h3><h3 id="Goals-and-challenges-of-computer-vision"><a href="#Goals-and-challenges-of-computer-vision" class="headerlink" title="Goals and challenges of computer vision"></a>Goals and challenges of computer vision</h3><p>Extract useful information from images, both metric and semantic<br>• Data heterogeneity, ambiguity, and complexity are a big challenge<br>• Significant progress in recent years due to improvements in processing power, memory, storage capacity, data availability<br>• Computer vision workflow: images &gt; measurements &gt; models &gt; algorithms for learning and inference</p><p>Requires understanding of the <strong>physics of imaging</strong> and the use of <strong>mathematical and statistical models</strong> for information extraction</p><p>要求理解成像的物理原理，并使用数学和统计模型进行信息提取</p><h3 id="Critical-issues-in-computer-vision"><a href="#Critical-issues-in-computer-vision" class="headerlink" title="Critical issues in computer vision"></a>Critical issues in computer vision</h3><p>• <strong>Sensing</strong>: how do sensors obtain images of the world?</p><p>• <strong>Encoding</strong>: how do images encode information of the scene?</p><p>• <strong>Representation</strong>: what are appropriate representations of objects?</p><p>• <strong>Algorithmics</strong>: what are appropriate algorithms to process image information and construct scene descriptions?</p><h3 id="Low-level-computer-vision"><a href="#Low-level-computer-vision" class="headerlink" title="Low-level computer vision"></a>Low-level computer vision</h3><p>This is almost entirely <strong>digital image processing</strong> (image in &gt; image out)</p><p>• <strong>Sensing</strong>: image capture and digitisation</p><p>• <strong>Preprocessing</strong>: suppress noise and enhance object features</p><p>• <strong>Segmentation</strong>: separate objects from background and partition them</p><p>• <strong>Description</strong>: compute features which difffferentiate objects</p><p>• <strong>Classifification</strong>: assign labels to image segments (regions)</p><h3 id="High-level-computer-vision"><a href="#High-level-computer-vision" class="headerlink" title="High-level computer vision"></a>High-level computer vision</h3><p>This is about knowledge construction, representation, and inference</p><p>• <strong>Recognition</strong>: identify objects based on low-level information</p><p>• <strong>Interpretation</strong>: assign meaning to groups of recognized objects</p><p>• <strong>Scene analysis</strong>: complete understanding of the captured scene</p><h3 id="Assumed-knowledge"><a href="#Assumed-knowledge" class="headerlink" title="Assumed knowledge"></a>Assumed knowledge</h3><p>To do this course successfully you should:</p><p>• Be able to program well in <strong>Python</strong> or willing to learn it independently</p><p>• Be familiar with <strong>data structures and algorithms</strong> and basic <strong>statistics</strong></p><p>• Be able/learn to <strong>use and integrate software packages</strong> (OpenCV, Scikit-Learn, Keras)</p><p>• Be familiar with <strong>vector calculus and linear algebra</strong> or willing to learn it independently</p><h3 id="What-is-image-formation-什么是图像构成"><a href="#What-is-image-formation-什么是图像构成" class="headerlink" title="What is image formation? 什么是图像构成"></a>What is image formation? 什么是图像构成</h3><p>Image formation occurs when a <strong>sensor registers radiation</strong> that has <strong>interacted with physical objects</strong></p><h3 id="Geometry-of-image-formation-成像几何"><a href="#Geometry-of-image-formation-成像几何" class="headerlink" title="Geometry of image formation 成像几何"></a>Geometry of image formation 成像几何</h3><p>Mapping world coordinates (3D) to image coordinates (2D)</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210919224443766.png" alt="image-20210919224443766"></p><p>f = focal length    焦距</p><p>c = centre of the camera    相机的中心</p><h3 id="Dimensionality-reduction-machine"><a href="#Dimensionality-reduction-machine" class="headerlink" title="Dimensionality reduction machine"></a>Dimensionality reduction machine</h3><h3 id="Projective-geometry-摄影几何"><a href="#Projective-geometry-摄影几何" class="headerlink" title="Projective geometry 摄影几何"></a>Projective geometry 摄影几何</h3><p>Lost: Length and area are not preserved</p><p>Preserved: Straight lines are still straight</p><h3 id="Vanishing-points-and-lines"><a href="#Vanishing-points-and-lines" class="headerlink" title="Vanishing points and lines"></a>Vanishing points and lines</h3><p>Parallel lines in the world intersect in the image at a “vanishing point”</p><h3 id="Projection-maths"><a href="#Projection-maths" class="headerlink" title="Projection maths"></a>Projection maths</h3><p>world coordinates &gt; image coordinates</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210919225745745.png" alt="image-20210919225745745"></p><h3 id="Perspective-projection"><a href="#Perspective-projection" class="headerlink" title="Perspective projection"></a>Perspective projection</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210919230003328.png" alt="image-20210919230003328"></p><h3 id="Affine-projection-仿射投影"><a href="#Affine-projection-仿射投影" class="headerlink" title="Affine projection 仿射投影"></a>Affine projection 仿射投影</h3><p>Camera always remains at roughly constant distance from the scene</p><p>如果 m = -f’ / z0，z0是常数，那么 (x’, y’) = ( -mx, -my)</p><p>Orthographic projection when <em>m</em> is normalised to –1:</p><p>(x’, y’) = (x, y)</p><h3 id="Beyond-pinholes-radial-distortions-径向畸变"><a href="#Beyond-pinholes-radial-distortions-径向畸变" class="headerlink" title="Beyond pinholes: radial distortions 径向畸变"></a>Beyond pinholes: radial distortions 径向畸变</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210919231456088.png" alt="image-20210919231456088"></p><h3 id="Electromagnetic-spectrum"><a href="#Electromagnetic-spectrum" class="headerlink" title="Electromagnetic spectrum"></a>Electromagnetic spectrum</h3><p>Colour spaces: RGB</p><p>Colour spaces: HSV</p><p>Colour spaces: YCbCr</p><p>Colour spaces: L*a*b*</p><h3 id="Digitisation-by-spatial-sampling"><a href="#Digitisation-by-spatial-sampling" class="headerlink" title="Digitisation by spatial sampling"></a>Digitisation by spatial sampling</h3><p>– Spatial discretisation of a picture function <em>F</em>(<em>x</em>,<em>y</em>) </p><p>– Uses a (typically rectangular) grid of sampling points:</p><p><em>x</em> = <em>j</em>Δ<em>x</em>, <em>y</em> = <em>k</em>Δ<em>y | j</em> = 1…<em>M</em>, <em>k</em> = 1…<em>N</em> </p><p>– The Δ<em>x</em>, Δ<em>y</em> are called the <strong>sampling intervals</strong></p><h3 id="Spatial-resolution"><a href="#Spatial-resolution" class="headerlink" title="Spatial resolution"></a>Spatial resolution</h3><p>Human faces can be recognized at 64 x 64 pixels per face</p><h3 id="Quantisation-量子化"><a href="#Quantisation-量子化" class="headerlink" title="Quantisation 量子化"></a>Quantisation 量子化</h3><p><strong>Levels per pixel:</strong></p><p>8 bits = 2^8 = 256</p><p>12 bits = 2^12 = 4,096</p><p>16 bits = 2^16 = 65,536</p><p>24 bits = 2^24 = 16,777,216</p><p><strong>Image processing</strong> = image in &gt; image out</p><p><strong>Image analysis</strong> = image in &gt; features out</p><p><strong>Computer vision</strong> = image in &gt; interpretation out</p><h4 id="Two-main-types-of-image-processing-operations"><a href="#Two-main-types-of-image-processing-operations" class="headerlink" title="Two main types of image processing operations:"></a>Two main types of image processing operations:</h4><p>– Spatial domain operations (in image space) 空间域操作(图像空间)</p><p>– Transform domain operations (mainly in Fourier space) 变换域操作(主要在傅里叶空间)</p><h4 id="Two-main-types-of-spatial-domain-operations"><a href="#Two-main-types-of-spatial-domain-operations" class="headerlink" title="Two main types of spatial domain operations:"></a>Two main types of spatial domain operations:</h4><p>– Point operations (intensity transformations on individual pixels) 点操作(对单个像素的强度转换)</p><p>– Neighbourhood operations (spatial filtering on groups of pixels) 邻域操作(对像素组进行空间滤波)</p><h3 id="Spatial-domain-operations"><a href="#Spatial-domain-operations" class="headerlink" title="Spatial domain operations"></a>Spatial domain operations</h3><p>General form of spatial domain operations: 𝑔(𝑥, 𝑦) = 𝑇 [𝑓 (𝑥, 𝑦) ]</p><p>𝑓 (𝑥, 𝑦) is the input image</p><p>𝑔(𝑥, 𝑦) is the processed image</p><p>𝑇 [ . ] is the operator applied at (𝑥𝑥, 𝑦𝑦)</p><p>Point operations: 𝑇 operates on individual pixels</p><p>𝑇: ℝ ⟶ ℝ 𝑔(𝑥, 𝑦) = 𝑇 [𝑓 (𝑥, 𝑦) ]</p><p>Neighbourhood operations: 𝑇 operates on multiple pixels</p><p>𝑇: ℝ ^2⟶ ℝ 𝑔(𝑥, 𝑦) = 𝑇 [𝑓 (𝑥, 𝑦), 𝑓 (𝑥 + 1, 𝑦), 𝑓 (𝑥 -1 , 𝑦), … ]</p><p>Contrast stretching 对比度拉伸</p><p>Intensity thresholding 强度阈值</p><p>Automatic intensity thresholding</p><p>Otsu’s method for computing the threshold</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210920010917959.png" alt="image-20210920010917959"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210920011223098.png" alt="image-20210920011223098"></p><h4 id="Multi-level-thresholding"><a href="#Multi-level-thresholding" class="headerlink" title="Multi-level thresholding"></a>Multi-level thresholding</h4><h4 id="Intensity-inversion-强度反演"><a href="#Intensity-inversion-强度反演" class="headerlink" title="Intensity inversion 强度反演"></a>Intensity inversion 强度反演</h4><h4 id="Log-transformation"><a href="#Log-transformation" class="headerlink" title="Log transformation"></a>Log transformation</h4><p>𝑠 = 𝑐  log (1 + 𝑟)</p><p>where 𝑟 is the input intensity, 𝑠 is the output intensity, and 𝑐 is a constant</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210920011617283.png" alt="image-20210920011617283"></p><h4 id="Power-transformation-电源转换"><a href="#Power-transformation-电源转换" class="headerlink" title="Power transformation 电源转换"></a>Power transformation 电源转换</h4><p>𝑠 = 𝑐 𝑟 ^ γ</p><p>where 𝑐 and 𝛾 are constants</p><p>– Similar to log transformation</p><p>– Represents a whole family of transformations by varying 𝛾 </p><p>– Many devices respond according to a power law (gamma correction)</p><p>– Useful for general-purpose contrast manipulation</p><h4 id="Piecewise-linear-transformations"><a href="#Piecewise-linear-transformations" class="headerlink" title="Piecewise linear transformations"></a>Piecewise linear transformations</h4><h4 id="Piecewise-contrast-stretching-分段对比拉伸"><a href="#Piecewise-contrast-stretching-分段对比拉伸" class="headerlink" title="Piecewise contrast stretching 分段对比拉伸"></a>Piecewise contrast stretching 分段对比拉伸</h4><p>• One of the simplest piecewise linear transformations</p><p>• Increases the dynamic range of gray levels in images</p><p>• Used in display devices or recording media to span full range</p><h4 id="Gray-level-slicing-灰度分割"><a href="#Gray-level-slicing-灰度分割" class="headerlink" title="Gray-level slicing 灰度分割"></a>Gray-level slicing 灰度分割</h4><p>Two different slicing approaches:<br>1) High value for all gray levels in a range of interest and low value for all others (produces a binary image)<br>2) Brighten a desired range of gray levels while preserving background and other gray-scale tones of the image</p><h4 id="Bit-plane-slicing-位平面切片"><a href="#Bit-plane-slicing-位平面切片" class="headerlink" title="Bit-plane slicing 位平面切片"></a>Bit-plane slicing 位平面切片</h4><p> Highlights contribution to total image by specific bits</p><p>• An image with <em>n</em> bits/pixel has <em>n</em> bit-planes</p><p>• Slicing can be useful for image compression</p><h4 id="Histogram-of-pixel-intensities-像素强度直方图"><a href="#Histogram-of-pixel-intensities-像素强度直方图" class="headerlink" title="Histogram of pixel intensities 像素强度直方图"></a>Histogram of pixel intensities 像素强度直方图</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210920013014466.png" alt="image-20210920013014466"></p><h4 id="Histogram-processing-直方图处理"><a href="#Histogram-processing-直方图处理" class="headerlink" title="Histogram processing 直方图处理"></a>Histogram processing 直方图处理</h4><p><strong>Histogram equalization</strong></p><p>Aim: To get an image with equally distributed intensity levels over the full intensity range</p><p>目的:获得在全强度范围内均匀分布强度的图像</p><p>• <strong>Histogram specification</strong> (also called <strong>histogram matching</strong>)</p><p>Aim: To get an image with a specified intensity distribution, determined by the shape of the histogram</p><p>目的:根据直方图的形状，得到具有指定强度分布的图像</p><h4 id="Histogram-equalization-直方图均衡化"><a href="#Histogram-equalization-直方图均衡化" class="headerlink" title="Histogram equalization 直方图均衡化"></a>Histogram equalization 直方图均衡化</h4><p>Let 𝑟 ∈ [ 0, 𝐿 − 1 ] represent gray levels of the image</p><p>𝑟 = 0 represents black and 𝑟 = 𝐿 − 1 represents white</p><p>s=T(r)   0 &lt;= r &lt;= L-1</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210920014324947.png" alt="image-20210920014324947"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210920015247768.png" alt="image-20210920015247768"></p><h4 id="Arithmetic-and-logical-operations"><a href="#Arithmetic-and-logical-operations" class="headerlink" title="Arithmetic and logical operations"></a>Arithmetic and logical operations</h4><p>Defined on a pixel-by-pixel basis between two images</p><h4 id="Averaging"><a href="#Averaging" class="headerlink" title="Averaging"></a>Averaging</h4><p>Fi(x,y)=g(x,y) + ni(x,y)</p><p>E[fi(x,y)]=g(x,y)  VAR[fi(x,y)]=Var[ni(x,y)]=σ^2(x,y)</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/image-20210920020549436.png" alt="image-20210920020549436"></p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> COMP9517 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SSH配置Hexo连接Github</title>
      <link href="/2021/08/30/zui-jia-shi-jian/shi-yong-ssh-pei-zhi-hexo-lian-jie-github/"/>
      <url>/2021/08/30/zui-jia-shi-jian/shi-yong-ssh-pei-zhi-hexo-lian-jie-github/</url>
      
        <content type="html"><![CDATA[<h3 id="一、查看本地Github相关配置"><a href="#一、查看本地Github相关配置" class="headerlink" title="一、查看本地Github相关配置"></a>一、查看本地Github相关配置</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 查看Git环境配置git config --list# 配置 user.name 和 user.emailgit config --global user.name "用户名随意"git config --global user.email  "123456@qq.com" #填写github注册的邮箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、生成本地SSH-Key"><a href="#二、生成本地SSH-Key" class="headerlink" title="二、生成本地SSH Key"></a>二、生成本地SSH Key</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 进入SSH Key默认生成目录sudo sucd ~/.sshls# 生成秘钥ssh-keygen -t rsa -C "github登录邮箱"# 查看公钥cat id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、配置SSH-Key-至-Github"><a href="#三、配置SSH-Key-至-Github" class="headerlink" title="三、配置SSH Key 至 Github"></a>三、配置SSH Key 至 Github</h3><p>登录Github，点击setting</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210830233441.png" alt="image-20210830233039054"></p><p>点击 SSH and GPG keys，然后点击New SSH key</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210830233512.png" alt="image-20210830233505459"></p><p>取个名字，并粘贴密钥。</p><p>注意，一定要粘贴公钥，不要粘贴私钥！</p><h3 id="四、验证连接"><a href="#四、验证连接" class="headerlink" title="四、验证连接"></a>四、验证连接</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 输入此命令，显示successful表示成功ssh -T git@github.com <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210831000307.png" alt="image-20210830233840571"></p><h3 id="五、配置Hexo"><a href="#五、配置Hexo" class="headerlink" title="五、配置Hexo"></a>五、配置Hexo</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">deploy:   #部署部分的设置  type: git  repo: git@github.com:你的用户名/你的仓库名.git  #设置仓库为ssh格式  branch: master <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 执行此命令，推送hexohexo g -d <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><strong>参考资料</strong></p><p>Hexo使用SSH连接GitHub<br><a href="https://blog.csdn.net/weixin_42569846/article/details/105808683">https://blog.csdn.net/weixin_42569846/article/details/105808683</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 最佳实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 已完稿 </tag>
            
            <tag> Hexo </tag>
            
            <tag> 实践操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS系统搭建C语言开发环境</title>
      <link href="/2021/06/28/zui-jia-shi-jian/mac-xi-tong-da-jian-c-yu-yan-kai-fa-huan-jing/"/>
      <url>/2021/06/28/zui-jia-shi-jian/mac-xi-tong-da-jian-c-yu-yan-kai-fa-huan-jing/</url>
      
        <content type="html"><![CDATA[<h3 id="下载IDE"><a href="#下载IDE" class="headerlink" title="下载IDE"></a>下载IDE</h3><p>MacOS 自带C语言环境，因此可以直接执行gcc命令编译C语言文件</p><pre class="line-numbers language-C" data-language="C"><code class="language-C"># 编译gcc test.c -o test.o# 执行./test.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>MacOS可使用的C语言IDE有VSCode、CLion、Eclipse、Xcode等</p><p><a href="https://www.jetbrains.com/clion/download/#section=mac">Clion的官网下载地址</a></p><h3 id="编译运行单个C语言文件"><a href="#编译运行单个C语言文件" class="headerlink" title="编译运行单个C语言文件"></a>编译运行单个C语言文件</h3><p>在Clion的plugin中，安装 Single File Execution 插件即可。</p><p><a href="https://plugins.jetbrains.com/plugin/8352-c-c--single-file-execution">Single File Execution官方说明</a></p><blockquote><p><strong>参考资料</strong></p><p>Mac系统搭建C语言开发环境<br><a href="https://blog.csdn.net/weixin_45895753/article/details/104246986">https://blog.csdn.net/weixin_45895753/article/details/104246986</a></p><p>Mac上配置c/c++环境(例：CLion)<br><a href="https://blog.csdn.net/kevinmeanscool/article/details/87174823">https://blog.csdn.net/kevinmeanscool/article/details/87174823</a></p><p>【CLion】新手使用之编译运行单个文件</p><p><a href="https://blog.csdn.net/mukvintt/article/details/110770505">https://blog.csdn.net/mukvintt/article/details/110770505</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 最佳实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 已完稿 </tag>
            
            <tag> MacOS </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（3）</title>
      <link href="/2021/06/19/unsw/comp9024/shu-ju-jie-gou-yu-suan-fa-2-copy/"/>
      <url>/2021/06/19/unsw/comp9024/shu-ju-jie-gou-yu-suan-fa-2-copy/</url>
      
        <content type="html"><![CDATA[<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9024 </tag>
            
            <tag> 编辑中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（2）</title>
      <link href="/2021/06/19/unsw/comp9024/shu-ju-jie-gou-yu-suan-fa-2/"/>
      <url>/2021/06/19/unsw/comp9024/shu-ju-jie-gou-yu-suan-fa-2/</url>
      
        <content type="html"><![CDATA[<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9024 </tag>
            
            <tag> 编辑中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（1）</title>
      <link href="/2021/06/19/unsw/comp9024/shu-ju-jie-gou-yu-suan-fa-1/"/>
      <url>/2021/06/19/unsw/comp9024/shu-ju-jie-gou-yu-suan-fa-1/</url>
      
        <content type="html"><![CDATA[<h2 id="关于课程"><a href="#关于课程" class="headerlink" title="关于课程"></a>关于课程</h2><p><a href="https://www.cse.unsw.edu.au/~cs9024/21T2/">课程主页</a></p><p><a href="http://moodle.telt.unsw.edu.au/course/view.php?id=60162">moodle主页</a></p><p>教科书：</p><ul><li>Algorithms in C, Parts 1-4, Robert Sedgewick</li><li>Algorithms in C, Part 5, Robert Sedgewick</li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210619221842.png" alt="教科书封皮"></p><h3 id="每周测试-Weekly-Assessments"><a href="#每周测试-Weekly-Assessments" class="headerlink" title="每周测试 Weekly Assessments"></a>每周测试 Weekly Assessments</h3><p>第2-5，7-10周，每次2分，共计16分</p><h3 id="大作业-Large-Assignment"><a href="#大作业-Large-Assignment" class="headerlink" title="大作业 Large Assignment"></a>大作业 Large Assignment</h3><p>发布于期中测试后，截止与第10周，共计12分</p><h3 id="期中考试"><a href="#期中考试" class="headerlink" title="期中考试"></a>期中考试</h3><p>第六周，7月9日，1小时在线测试，共计12分</p><p>格式：一些多选题，一些开放问题</p><h3 id="期末考试"><a href="#期末考试" class="headerlink" title="期末考试"></a>期末考试</h3><p>在考试周，2小时在线测试，共计60分。期末成绩必须超过25分。</p><p>格式：一些多选题，一些开放问题</p><h3 id="最终成绩"><a href="#最终成绩" class="headerlink" title="最终成绩"></a>最终成绩</h3><p>如果平时成绩大于25分，则总分为 全部平时成绩+期末成绩</p><p>否则，按 期末成绩*100/60 计算</p><p>期末成绩必须超过25分，总成绩必须超过50分</p><h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h2><h3 id="C语言基本结构"><a href="#C语言基本结构" class="headerlink" title="C语言基本结构"></a>C语言基本结构</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">// include files// global definitions// function definitionsfunction_type f(arguments) {   // local variables   // body of function  return …;}.// main functionint main(arguments) {   // local variables   // body of main function   return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;int f(int m, int n) {   while (m != n) {      if (m &gt; n) { m = m-n;      } else { n = n-m;      }   }   return m;}int main(void) {   printf("%d\n", f(30,18));   return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt; // include standard I/O library defs and functions#define SIZE 6     // define a symbolic constantvoid insertionSort(int array[], int n) {  // function headers must provide types   int i;                                 // each variable must have a type   for (i = 1; i &lt; n; i++) {              // for-loop syntax      int element = array[i];                                                          int j = i-1;      while (j &gt;= 0 &amp;&amp; array[j] &gt; element) {  // logical AND         array[j+1] = array[j];         j--;                                 // abbreviated assignment j=j-1       }      array[j+1] = element;                   // statements terminated by ;   }                                          // code blocks enclosed in { } }int main(void) {                              // main: program starts here   int numbers[SIZE] = { 3, 6, 5, 2, 4, 1 };  /* array declaration                                                 and initialisation */   int i;   insertionSort(numbers, SIZE);   for (i = 0; i &lt; SIZE; i++)      printf("%d\n", numbers[i]);             // printf defined in &lt;stdio&gt;   return 0;           // return program status (here: no error) to environment}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用gcc编译"><a href="#使用gcc编译" class="headerlink" title="使用gcc编译"></a>使用gcc编译</h3><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">gcc prog.c./a.outgcc -Wall prog.c# 编译时给出详细提示gcc -o prog prog.c# 指定编译文件名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="printf-命令"><a href="#printf-命令" class="headerlink" title="printf()命令"></a>printf()命令</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">printf(format-string, expr1, expr2, …);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><div class="table-container"><table><thead><tr><th>字符</th><th>作用</th><th>字符</th><th>作用</th></tr></thead><tbody><tr><td><code>%d</code></td><td>十进制数</td><td><code>%f</code></td><td>浮点数</td></tr><tr><td><code>%c</code></td><td>字符</td><td><code>%s</code></td><td>字符串</td></tr><tr><td><code>\n</code></td><td>换行</td><td><code>\"</code></td><td>双引号</td></tr></tbody></table></div><p>使用样例</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">num = 3;printf("The cube of %d is %d.\n", num, num*num*num);// 显示结果为 The cube of 3 is 27.id  = 'z';num = 1234567;printf("Your \"login ID\" will be in the form of %c%d.\n", id, num);// 显示结果为 Your "login ID" will be in the form of z1234567.printf("%8.3f\n", 3.14159);// 显示结果为 3.142<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="C语言常用符号"><a href="#C语言常用符号" class="headerlink" title="C语言常用符号"></a>C语言常用符号</h3><p>; {} + - <em> / % = += -= </em>= /= %= ++ —</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">// 注意这两种用法的区别k++;n = k--;++k;n = --k;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">if (expression) {   some statements;}if (expression) {   some statements1;} else {   some statements2;}if (expression1) {   statements1;} else if (exp2) {   statements2;} else if (exp3) {   statements3;} else {   statements4;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断格式&gt; &gt;= &lt; &lt;= == != &amp;&amp; || !</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">while (expression) {    some statements; }do {   some statements;   } while (expression);for (expr1; expr2; expr3) {   some statements;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">return-type function-name(parameters) {    declarations    statements    return …;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数在执行到return后返回并终止</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">return expression;return;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>char 字符  int 整型  float 浮点   double 双精度浮点</p><h3 id="聚合数据类型"><a href="#聚合数据类型" class="headerlink" title="聚合数据类型"></a>聚合数据类型</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">char s[50];int v[100];struct student {char name[30]; nt zID;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">int  a[20];char b[10];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAX 20int i;int fact[MAX];fact[0] = 1;for (i = 1; i &lt; MAX; i++) {    fact[i] = i * fact[i-1];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义数组初始值的几种方法</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char s[6]   = {'h', 'e', 'l', 'l', 'o', '\0'};char t[6]   = "hello";int fib[20] = {1, 1}; // fib[2] fib[3] ... 未定义int vec[]   = {5, 4, 3, 2, 1};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="符号常量-symbolic-constant"><a href="#符号常量-symbolic-constant" class="headerlink" title="符号常量 symbolic constant"></a>符号常量 symbolic constant</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define NAME replacement_text#define SPEED_OF_LIGHT 299792458.0#define ERROR_MESSAGE "Out of memory.\n"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读取输入值"><a href="#读取输入值" class="headerlink" title="读取输入值"></a>读取输入值</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">scanf(format-string, expr1, expr2, …);int value = atoi(string);// 转换字符至整型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="定义新类型"><a href="#定义新类型" class="headerlink" title="定义新类型"></a>定义新类型</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef ExistingDataType NewTypeName;typedef float Temperature;typedef int Matrix[20][20];typedef float Real;Real complex_calculation(Real a, Real b) {Real c = log(a+b); … return c;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {       char name[30];       int  zID;} StudentT;typedef struct {int day, month;} DateT;typedef struct {int hour, minute;} TimeT;typedef struct {char   plate[7];   // e.g. "DSA42X"double speed;        DateT  d;TimeT  t;} TicketT;DateT christmas;christmas.day   =   25;christmas.month =   12;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抽象数据类型-ADT"><a href="#抽象数据类型-ADT" class="headerlink" title="抽象数据类型 ADT"></a>抽象数据类型 ADT</h3><ul><li>ADO = abstract data object  抽象的数据对象</li><li>ADT = abstract data type  抽象数据类型</li></ul><h3 id="栈和队列-Stack-vs-Queue"><a href="#栈和队列-Stack-vs-Queue" class="headerlink" title="栈和队列 Stack vs Queue"></a>栈和队列 Stack vs Queue</h3><p>堆栈 Stack </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">// Stack ADO header file#define MAXITEMS 10void StackInit();      // set up empty stackint  StackIsEmpty();   // check whether stack is emptyvoid StackPush(char);  // insert char on top of stackchar StackPop();       // remove char from top of stack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">gcc -c Stack.c// 产生 Stack.o，从Stack.c和Stack.hgcc -c brackets.c// 产生 brackets.c，从brackets.c和brackets.hgcc -o rbt brackets.o Stack.o// 连接 brackets.o Stack.o，生成RBT可执行程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9024 </tag>
            
            <tag> 已完稿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven命令</title>
      <link href="/2021/05/11/ji-zhu-xue-xi/java/maven-ming-ling/"/>
      <url>/2021/05/11/ji-zhu-xue-xi/java/maven-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven-Lifecycle-命令"><a href="#Maven-Lifecycle-命令" class="headerlink" title="Maven Lifecycle 命令"></a>Maven Lifecycle 命令</h2><p>mvn clean            清除编译产生的target文件夹内容</p><p>mvn validate        验证项目是否正确并且所有必要的信息均可用</p><p>mvn compile        对src/main/java目录的下的代码进行编译</p><p>mvn test                测试命令,或执行src/test/java/下所有junit的测试用例</p><p>mvn package        打包项目</p><p>mvn verify            对集成测试的结果进行任何检查，以确保符合质量标准</p><p>mvn install            打包后将其安装在本地仓库</p><p>mvn site                生成站点目录</p><p>mvn deploy        </p><h2 id="package-install-deploy三者关联"><a href="#package-install-deploy三者关联" class="headerlink" title="package,install,deploy三者关联"></a>package,install,deploy三者关联</h2><p>mvn clean package    依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)等７个阶段。<br>mvn clean install        依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install等8个阶段。<br>mvn clean deploy        依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install、deploy等９个阶段。</p><h2 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h2><p>mvn -version                     查看maven的版本及配置信息</p><p>mvn archetype:create       -DgroupId=    DartifactId=    构建java项目</p><p>mvn archetype:create       -DgroupId=    DartifactId=    -DarchetypeArtifactId=maven-archetype-webapp 创建web项目</p><p>mvn compile                    编译项目代码</p><p>mvn package                   打包项目</p><p>mvn package -Dmaven.test.skip=true   打包项目时跳过单元测试</p><p>mvn test                        运行单元测试</p><p>mvn clean                    清除编译产生的target文件夹内容，可以配合相应命令一起使用，如mvn clean package， mvn clean test</p><p>mvn install                    打包后将其安装在本地仓库</p><p>mvn deploy                    打包后将其安装到pom文件中配置的远程仓库</p><p>mvn eclipse:eclipse      将maven生成eclipse项目结构</p><p>mvn eclipse:clean         清除maven项目中eclipse的项目结构</p><p>mvn site                            生成站点目录</p><p>mvn dependency:list            显示所有已经解析的所有依赖</p><p>mvn dependency:tree            以树的结构展示项目中的依赖</p><p>mvn dependency:analyze    对项目中的依赖进行分析，依赖未使用，使用单未引入</p><p>mvn tomcat:run                    启动tomcat</p><blockquote><p><strong>参考资料</strong></p><p>maven命令<br><a href="https://blog.csdn.net/zflovecf/article/details/80831467">https://blog.csdn.net/zflovecf/article/details/80831467</a></p><p>Maven的常用命令 - clean compile test package install<br><a href="https://blog.csdn.net/u012887259/article/details/111570702">https://blog.csdn.net/u012887259/article/details/111570702</a></p><p>一篇文章学懂Maven（附带对idea中clean，validate，complie，test，package，verify，install，site，deploy用法）<br><a href="https://blog.csdn.net/qq_40547893/article/details/110091275">https://blog.csdn.net/qq_40547893/article/details/110091275</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑中 </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础期末要点复习</title>
      <link href="/2021/05/07/unsw/comp9311/shu-ju-ku-ji-chu-qi-mo-yao-dian-fu-xi/"/>
      <url>/2021/05/07/unsw/comp9311/shu-ju-ku-ji-chu-qi-mo-yao-dian-fu-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自 <a href="https://mubu.com/doc/1jff_OxSqV">9311数据库期末要点复习</a>——IF</p></blockquote><h2 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h2><h2 id="二、关系数据库"><a href="#二、关系数据库" class="headerlink" title="二、关系数据库"></a>二、关系数据库</h2><ul><li><p>关系模式</p><ul><li><p>关系模式：对关系的描述</p></li><li><p>关系：关系是一张表，一张二维表</p></li><li><p>关系中有哪些需要描述</p><ul><li><p>关系中的属性</p></li><li><p>属性来自哪些域</p></li><li><p>属性与域之间的映射关系</p></li><li><p>关系的表示 R（U, D, DOM, F）</p><ul><li><p>R：关系名</p></li><li><p>U：所有属性名</p></li><li><p>D：属性来自哪些域</p></li><li><p>DOM：属性和域的映射</p></li><li><p>F：属性间的依赖关系</p></li></ul></li></ul></li><li><p>关系数据库：关系数据库也有关系数据库模式</p></li></ul></li><li><p>关系操作</p><ul><li><p>插入、查询、删除、修改</p></li><li><p>查询：选择、投影、连接、除法（一般出现‘全部’时使用）、并、差、交、笛卡尔积</p></li><li><p>查询基本操作：选择、投影、并、差、笛卡尔积</p></li></ul></li><li><p>关系语言的分类</p><ul><li><p>！关系代数语言</p><ul><li><p>四种基本运算：并、差、交、笛卡尔积</p></li><li><p>专门的关系运算：选择、投影、连接、除法</p><ul><li>除法：用来表示全体的，比如说他全都包含了，就可以被留下来</li></ul></li><li><p>悬浮元组：R 和 S 在自然连接中，被舍弃的元组</p></li><li><p>特殊的连接（不同情况保留悬浮元组的自然连接）：外连接、左外连接、右外连接</p></li></ul></li><li><p>关系演算语言</p></li><li><p>具有关系代数和关系演算的SQL语言（详见第三章）</p></li></ul></li><li><p>关系的完整性</p><ul><li><p>实体完整性：主码唯一且非空</p></li><li><p>参照完整性：外码要么为空，要么就要对应另一个表的主码</p></li><li><p>用户定义完整性：自己定义的完整性，比如年龄在18-60岁，身高多少之类的</p></li></ul></li></ul><h2 id="三、SQL"><a href="#三、SQL" class="headerlink" title="三、SQL"></a>三、SQL</h2><ul><li><p>SQL特点</p><ul><li><p>SQL包括：数据查询、数据操作、数据定义、数据控制</p></li><li><p>非过程语言</p></li><li><p>SQL特点</p><ul><li><p>综合统一：把定义，修改，删除，连接，安全性，完整性，事务控制，动态SQL等统一起来</p></li><li><p>高度非过程化：层次模型和网络模型是过程化的，关系模型是非过程化的</p></li><li><p>面向集合的操作方式</p></li><li><p>以同一种语法结构提供多种使用方式：即可以独立，也可以嵌入到Java或者C++中</p></li><li><p>语言简洁，易学易用</p></li></ul></li></ul></li><li><p>SQL的基本概念</p><ul><li><p>外模式：视图、部分基本表</p></li><li><p>模式：若干基本表</p></li><li><p>内模式：若干存储文件</p></li><li><p>一个关系对应一张基本表，一个或多个基本表对应一个存储文件</p></li></ul></li><li><p>SQL的基本语法</p><ul><li><p>数据定义：包括模式定义、表定义、视图和索引的定义</p><ul><li><p>模式（create schema&lt;模式名&gt; authorization&lt;用户名&gt; / drop schema&lt;模式名&gt;）</p></li><li><p>表（create/drop table）</p></li><li><p>视图（create/drop view）</p></li><li><p>索引（create/drop index）</p></li><li><p>一个DBMS建立多个数据库，一个数据库建立多个模式，一个模式包含多个表、视图、索引</p></li></ul></li><li><p>数据查询</p><ul><li><p>数据查询（select(去重distinct，聚合函数(count、sum、avg、max、min))\\from\\where\\order by (DESC)\\group by\\having）</p></li><li><p>全体查询：包括 exists的查询，union、intersect（并、交）</p></li></ul></li><li><p>数据更新</p><ul><li><p>数据插入（insert into &lt;表名&gt; [列名] values()）</p></li><li><p>更新数据（update &lt;表名&gt; set &lt;列名&gt;=&lt;表达式&gt; [where…]）</p></li><li><p>删除数据（delete from &lt;表名&gt; [where…]）</p></li><li><p>空值判断（IS NULL / IS NOT NULL）</p></li></ul></li><li><p>视图</p><ul><li><p>建立视图（create view &lt;视图名&gt; as &lt;子查询&gt; [with check option] 行列子集视图）</p></li><li><p>删除视图（drop view &lt;视图名&gt; [CASCADE级联/RESTRICT限制]）</p></li><li><p>视图的作用</p><ul><li><p>视图能够简化用户操作</p></li><li><p>视图用多种角度看待同一数据</p></li><li><p>提供一定程度的数据独立性</p></li><li><p>提供安全保护</p></li><li><p>利用视图清晰地表达查询</p></li></ul></li></ul></li></ul></li></ul><h2 id="四、数据库安全性"><a href="#四、数据库安全性" class="headerlink" title="四、数据库安全性"></a>四、数据库安全性</h2><ul><li><p>数据库安全性概述</p><ul><li><p>不安全因素</p><ul><li><p>非授权对数据库的恶意存取和破坏</p></li><li><p>数据库中重要的数据泄露</p></li><li><p>安全环境的脆弱性</p></li></ul></li><li><p>自主存取控制方法</p><ul><li><p>grant (grant &lt;权限&gt; on table &lt;表名&gt; to &lt;用户&gt;) </p></li><li><p>revoke (revoke &lt;权限&gt; on table &lt;表名&gt; to &lt;用户&gt;)</p></li><li><p>创建用户（create user <username> with）</username></p></li></ul></li></ul></li><li><p>数据库安全性控制</p><ul><li><p>用户身份鉴别：静态口令、动态口令、生物特征、智能卡</p></li><li><p>存取控制</p></li><li><p>自主存取控制方法</p></li><li><p>授权：授予grant与回收revoke</p></li><li><p>数据库角色：角色指的是一类人，比如教师、学生、家长。可以给一类人授权</p></li></ul></li><li><p>视图机制：为不同的用户定义不同的视图，把不需要的数据隐藏，这样用户就不会进行误操作</p></li><li><p>审计：把对数据库的所有操作都记录到审计日志中，然后就可以通过日志审查这个里面是否存在非法行为</p></li><li><p>数据加密：通过一些加密算法，把明文变成密文</p></li></ul><h2 id="五、数据库完整性"><a href="#五、数据库完整性" class="headerlink" title="五、数据库完整性"></a>五、数据库完整性</h2><ul><li><p>正确性、相容性</p><ul><li><p>正确性：符合现实世界语义</p></li><li><p>相容性：同一对象在不同表中的数据符合逻辑的</p></li><li><p>为维护完整性，需要实现如下功能</p><ul><li><p>提供定义完整性约束条件的机制</p></li><li><p>提供完整性检查的方法</p></li><li><p>进行违约处理</p></li></ul></li></ul></li><li><p>三大完整性</p><ul><li><p>实体完整性：主码唯一且非空</p></li><li><p>参照完整性：外码的约束</p></li><li><p>用户定义完整性：属性上约束条件的定义</p><ul><li><p>非空 NOT NULL</p></li><li><p>列值为一 UNIQUE</p></li><li><p>满足某一条件表达式 check</p></li></ul></li><li><p>创建的时候用check进行约束</p></li><li><p>用constraint进行完整性约束</p></li><li><p>删除完整性</p></li></ul></li><li><p>断言</p><ul><li><p>创建断言（create assertion &lt;断言名&gt; <check子句>）</check子句></p><ul><li>只有符合check()里面的表达式才可以执行成功，否则就会执行失败</li></ul></li><li><p>删除断言（drop assertion &lt;断言名&gt;）</p></li></ul></li><li><p>触发器</p><ul><li><p>触发器：用户定义在关系表上的一类有时间驱动的特殊过程。由某个触发事件引发的事务</p></li><li><p>建立触发器（create trigger &lt;触发器名&gt; {BEFORE|AFTER} &lt;触发事件&gt; on &lt;表名&gt; Referencing new|old roe as &lt;变量&gt; for each {row|statement} [when &lt;触发条件&gt;] &lt;触发动作体&gt;）</p></li><li><p>触发器不能定义在视图上</p></li><li><p>触发器类型</p><ul><li><p>行级触发器 for each row</p></li><li><p>语句触发器 for each statement</p></li></ul></li><li><p>删除触发器（create trigger &lt;触发器名&gt; on &lt;表名&gt;）</p></li></ul></li></ul><h2 id="六、关系数据理论"><a href="#六、关系数据理论" class="headerlink" title="六、关系数据理论"></a>六、关系数据理论</h2><ul><li><p>存在的问题（数据冗余、更新异常、插入异常、删除异常）</p></li><li><p>补充概念</p><ul><li><p>函数依赖</p><ul><li><p>非平凡函数依赖 -&gt; 部分函数依赖</p></li><li><p>平凡函数依赖 -&gt; 完全函数依赖</p></li></ul></li><li><p>码</p><ul><li><p>候选码：这样一个集合，它可以推出所有的属性，但是他的任意一个真子集无法推出所有属性</p><ul><li><p>只出现在左边的一定是候选码</p></li><li><p>只出现在右边的一定不是候选码</p></li><li><p>左右都出现的不一定</p></li><li><p>左右都不出现的一定是候选码</p></li></ul></li><li><p>闭包：x的闭包是指由x能推出来的所有属性</p></li><li><p>超码：能推出所有属性的属性集，候选码是最小的超码</p></li><li><p>主码：从候选码中任意挑出一个为主码</p></li><li><p>主属性：包含在任意一个候选码中的属性</p></li><li><p>非主属性：不包含在候选码中的属性</p></li><li><p>码：主码、候选码都简称码</p></li><li><p>全码：所有属性都是码，称为全码</p></li></ul></li></ul></li><li><p>规范化-几个范式</p><ul><li><p>1NF：表中无表</p></li><li><p>2NF：在1NF的基础上，不存在非主属性对码的部分函数依赖</p></li><li><p>3NF：在2NF的基础上，不存在非主属性对码的传递函数依赖（全码一定是3NF，因为全码没有非主属性）</p></li><li><p>BCNF：在3NF的基础上，不存在主属性对码的部分和传递函数依赖</p></li></ul></li><li><p>！数据依赖的公理系统</p><ul><li><p>Armstrong公理系统：自反律、增广律、传递律</p></li><li><p>合并规则、伪传递规则、分解规则</p></li><li><p>最小函数依赖集（不唯一）</p><ul><li><p>F 中的每一个依赖，都不可以被其他的依赖推出，且右边一定是单元素</p></li><li><p>步骤</p><ul><li><p>把右边的元素拆分成单个的</p></li><li><p>对所有的依赖一一排查找出多余的（排查x-&gt;y：去掉x-&gt;y，求x闭包，如果包含y则多余，剔除；反之保留）</p></li><li><p>左部最小化</p></li></ul></li></ul></li></ul></li><li><p>！模式分解</p><ul><li><p>准则：无损连接性、保持函数依赖</p><ul><li><p>无损连接：画ab表。①题中R中已经存在的记a，不存在的记b。②遍历F中的依赖关系，如果两个R对同一个依赖关系的左边都是a，而其中一个R在依赖关系右边也是a，则另一个R在此依赖关系右边的b转换成a。③遍历结束，如果有任意一个R全a，则为无损连接</p></li><li><p>判断是否保持函数依赖：判断题中几个R在不下推的情况下，包含F的哪些依赖关系，如果F中全部满足则保持依赖，否则不保持</p></li></ul></li><li><p>分解成3NF步骤</p><ul><li><p>求出最小函数依赖集</p></li><li><p>把不在F中的属性全部找出来，单独分一类，并从这些属性删除</p></li><li><p>把每一个依赖左边的相同的分成一类</p></li><li><p>如果候选码没有出现在分类中，把任意一个候选码作为一类</p></li></ul></li></ul></li></ul><h2 id="七、数据库设计"><a href="#七、数据库设计" class="headerlink" title="七、数据库设计"></a>七、数据库设计</h2><ul><li><p>数据库设计的基本步骤</p><ul><li><p>需求分析</p></li><li><p>概念结构设计：ER图、数据字典（数据项、数据结构、数据流数据存储、处理过程）</p></li><li><p>逻辑结构设计：把ER图转换成逻辑模型</p></li><li><p>物理结构设计：逻辑模型转换为物理模型</p></li><li><p>数据库实施：写SQL代码</p></li><li><p>数据库运行和维护：性能检测、转储、恢复</p></li></ul></li><li><p>需求分析</p></li><li><p>！概念设计（ER图）</p><ul><li><p>矩形表示实体；椭圆表示属性（虚线为派生属性，双线为多值属性）；菱形表示联系<img src="https://api2.mubu.com/v3/document_image/734261ab-406c-42a4-9263-5dbecaa38ac2-9610017.jpg" alt="img"></p></li><li><p>联系：两个实体之间的联系（1：1，1：N，M：N），联系也可以拥有属性</p></li></ul></li><li><p>！逻辑结构设计（ER图转化为表结构）</p><ul><li><p>1：1 转换为主码</p></li><li><p>1：N 转换为外码（添加到N方）</p></li><li><p>M：N 转换为一张表</p></li><li><p>一个实体一张表；此外，一个多对多关系一张表两个主属性为主码，多值属性与主属性一张表为主码</p></li><li><p>部分参与为单实线，全部参与为双实线</p></li></ul></li><li><p>物理结构设计</p><ul><li><p>确定物理结构</p></li><li><p>对物理结构进行评价</p></li><li><p>实际关系模式的存取方法</p></li></ul></li><li><p>数据库的实施和维护</p></li></ul><h2 id="八、数据库编程"><a href="#八、数据库编程" class="headerlink" title="八、数据库编程"></a>八、数据库编程</h2><ul><li><p>嵌入式SQL：SQL语句写到其他编程Java，C++</p><ul><li><p>处理过程</p><ul><li><p>预编译转化为函数调用</p></li><li><p>主语言再编译</p></li><li><p>变成主语言所编译的内容</p></li></ul></li><li><p>与主语言之间的通信</p><ul><li><p>SQL给主语言传递状态</p></li><li><p>主语言给SQL提供参数</p></li><li><p>SQL把查询结构交给主语言处理，通常用主变量和游标实现</p></li></ul></li><li><p>主变量：SQL使用主语言的变量，前面加冒号，如：name</p></li><li><p>游标：一个缓冲区，存放SQL的执行结果</p></li><li><p>动态SQL：执行的时候才确定SQL子句，使用动态SQL</p></li></ul></li><li><p>过程SQL：基本结构是块</p><ul><li><p>块的基本结构</p><ul><li><p>定义部分（DECLARE//变量、常量、游标、异常）</p></li><li><p>执行部分（BEGIN//SQL语句、过程化SQL的流程）</p></li><li><p>控制语句（EXCEPTION//异常处理部分//END）</p></li></ul></li><li><p>变量和常量的定义</p></li></ul></li><li><p>存储过程</p><ul><li><p>创建存储过程</p></li><li><p>执行SQL语句</p></li><li><p>修改存储过程</p></li><li><p>删除存储过程</p></li></ul></li><li><p>函数</p><ul><li><p>创建函数 create or replace function &lt;函数名&gt; (参数…) return &lt;类型&gt; AS &lt;过程化SQL块&gt;</p></li><li><p>执行函数 CALL\SELECT 函数(参数…)</p></li><li><p>修改函数 alter function &lt;函数名1&gt; rename to &lt;函数名2&gt;</p></li></ul></li><li><p>ODBC编程</p></li></ul><h2 id="九、关系查询和优化"><a href="#九、关系查询和优化" class="headerlink" title="九、关系查询和优化"></a>九、关系查询和优化</h2><ul><li><p>查询处理</p><ul><li><p>查询语句—查询分析—查询检查—查询优化—查询执行</p></li><li><p>查询优化包括代数优化和物理优化</p></li></ul></li><li><p>！代数优化</p><ul><li><p>规则</p><ul><li><p>连接、笛卡尔积的交换律</p></li><li><p>连接、笛卡尔积的结合律</p></li><li><p>投影的串接定律</p></li><li><p>选择的串接定律</p></li><li><p>选择和投影操作的交换律</p></li><li><p>选择和笛卡尔积的交换律</p></li><li><p>选择与并的分配律</p></li><li><p>选择与差运算的分配律</p></li><li><p>选择对自然连接的分配律</p></li><li><p>投影和笛卡尔积的分配律</p></li><li><p>投影与并的分配律</p></li></ul></li><li><p>查询树的算法</p><ul><li><p>选择运算尽可能先做</p></li><li><p>投影运算和选择运算同时进行</p></li><li><p>把投影同其前或后的双目运算结合起来</p></li></ul></li></ul></li><li><p>物理优化</p></li></ul><h2 id="十、数据库恢复技术"><a href="#十、数据库恢复技术" class="headerlink" title="十、数据库恢复技术"></a>十、数据库恢复技术</h2><ul><li><p>事务</p><ul><li><p>四大特性（ACID）</p><ul><li><p>A—原子性：要么不做要么全做</p></li><li><p>C—一致性：一致性与原子性密切相关，要么全做要么不做，否则就会造成数据不一致。如银行汇款，两边都有操作才行</p></li><li><p>I—隔离性：一个事务的执行不能被其他事务干扰</p></li><li><p>D—持久性：数据库的改变是永久的</p></li></ul></li></ul></li><li><p>事物的种类</p><ul><li><p>故障的种类</p><ul><li><p>事物内部故障：采取REDO重做和UNDO撤销技术</p></li><li><p>系统故障：系统突然停转，系统要重启</p></li><li><p>介质故障：硬件损坏</p></li><li><p>计算机病毒</p></li></ul></li></ul></li><li><p>恢复技术</p><ul><li><p>数据转储：对失败的事物重新执行</p></li><li><p>日志文件：记录事物对数据的更新操作的文件</p></li></ul></li><li><p>恢复策略</p><ul><li><p>事务故障：事务异常终止，那么就撤销之前的所有操作</p></li><li><p>系统故障：还没执行完的事务UNDO，丢失的事务REDO</p></li><li><p>介质故障：重装数据库，重做已完成的事物</p></li></ul></li><li>有检查点的恢复</li><li><img src="https://api2.mubu.com/v3/document_image/e8d3d647-8534-4d32-a18e-e49e257809a9-9610017.jpg" alt="img"></li></ul><h2 id="十一、并发控制"><a href="#十一、并发控制" class="headerlink" title="十一、并发控制"></a>十一、并发控制</h2><ul><li><p>并发带来的问题和解决</p><ul><li>问题</li></ul></li></ul><pre><code>  - 丢失修改：修改的数据丢失  - 读脏数据：读取了已撤回的无效数据  - 不可重复读：同一事物中，连续两次读到的数据不一样- 解决方法  - 排他锁：写锁，X锁  - 共享锁：读锁，S锁- 封锁协议  - 一级封锁协议（解决丢死修改）：修改时，必须加X锁，直到结束  - 二级封锁协议（解决读脏数据）：读的时候，加S锁，用完就放  - 三级封锁协议（解决不可重复读）：读的时候，加S锁，直到结束</code></pre><ul><li><p>活锁和死锁</p><ul><li><p>活锁：该锁永远等待得不到机会上锁</p></li><li><p>死锁：多个锁互相等待，互相谦让，没人上锁</p></li></ul></li><li><p>可串行性</p><ul><li><p>并发调度中的某一次结果与串行调度一致，称为可串行化，可串行化是事务正确调度的准则</p></li><li><p>两段锁协议</p></li><li><p><img src="https://api2.mubu.com/v3/document_image/a38a6bb4-2326-4bce-8839-ec22423c4aec-9610017.jpg" alt="img"></p></li><li><p>判断冲突可串行化（优先图存在环，S不是冲突可串行的；反之则是）</p></li></ul></li></ul><pre><code>  - 优先图画法：结点：S中的事务。弧：Ti-&gt;Tj （pi，pj涉及同一数据库元素），pi在qj之前且至少一个是写动作  - ![img](https://api2.mubu.com/v3/document_image/ba44f70e-29f5-42ba-ab56-a1c5be9b9733-9610017.jpg)</code></pre><ul><li>封锁的粒度：封锁粒度大，并发度小，开销小；封锁粒度小，并发度大，开销大</li></ul><h2 id="十二、B树、B-树"><a href="#十二、B树、B-树" class="headerlink" title="十二、B树、B+树"></a>十二、B树、B+树</h2><ul><li><p>B+树记录数量：间隔数^层数*格数</p></li><li><p><a href="https://blog.csdn.net/u014453898/article/details/112469113?ops_request_misc=%7B%22request%5Fid%22%3A%22162038860616780262576719%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=162038860616780262576719&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-112469113.first_rank_v2_pc_rank_v29&amp;utm_term=B%2B树">B数、B+树增删操作</a></p></li></ul><ul><li><a href="https://www.bilibili.com/video/BV1P5411e7rU">数据库必考题视频链接</a></li></ul><blockquote><p><strong>参考资料</strong></p><p><a href="https://mubu.com/doc/1jff_OxSqV">9311数据库期末要点复习</a>——IF</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9311 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNSW 关于学校</title>
      <link href="/2021/05/04/unsw/unsw-guan-yu-xue-xiao/"/>
      <url>/2021/05/04/unsw/unsw-guan-yu-xue-xiao/</url>
      
        <content type="html"><![CDATA[<h3 id="学校校历"><a href="#学校校历" class="headerlink" title="学校校历"></a>学校校历</h3><h4 id="开学时间"><a href="#开学时间" class="headerlink" title="开学时间"></a>开学时间</h4><ul><li>2021-Summer: 1月4日至2月6日</li><li>2021-T1：2月15日-5月13日</li><li>2021-T2：5月31日-8月26日</li><li>2021-T3：9月13日-12月9日</li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210504203729.jpg" alt="UNSW 校历"></p><h4 id="课程评分标准"><a href="#课程评分标准" class="headerlink" title="课程评分标准"></a>课程评分标准</h4><p><a href="https://student.unsw.edu.au/grade">Grade Definitions</a></p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手册 </tag>
            
            <tag> 持续更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更换MacOS的brew源</title>
      <link href="/2021/04/26/zui-jia-shi-jian/geng-huan-macos-de-brew-yuan/"/>
      <url>/2021/04/26/zui-jia-shi-jian/geng-huan-macos-de-brew-yuan/</url>
      
        <content type="html"><![CDATA[<p>MacOS操作系统在使用<code>brew</code>命令安装工具时，可能停留在Updating Homebrew…提示行处。其更可能的原因为使用了默认的brew源，下载更新速度过慢导致，</p><p>brew源有如下三个配置：</p><ol><li>brew.git</li><li>homebrew-core.git</li><li>homebrew-bottles</li></ol><h2 id="修改brew-git-仓库地址"><a href="#修改brew-git-仓库地址" class="headerlink" title="修改brew.git 仓库地址"></a>修改brew.git 仓库地址</h2><p>执行如下命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 替换brew.git地址cd "$(brew --repo)"git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git# 阿里源git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git # 清华源git remote set-url origin https://mirrors.cloud.tencent.com/homebrew/brew.git# 腾讯源# 还原brew.git地址cd "$(brew --repo)"git remote set-url origin https://github.com/Homebrew/brew.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改homebrew-core-git仓库地址"><a href="#修改homebrew-core-git仓库地址" class="headerlink" title="修改homebrew-core.git仓库地址"></a>修改homebrew-core.git仓库地址</h2><p>执行如下命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 替换homebrew-core.git地址cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git# 阿里源git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git# 清华源git remote set-url origin https://mirrors.cloud.tencent.com/homebrew/brew.git# 腾讯源# 还原homebrew-core.git地址cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"git remote set-url origin https://github.com/Homebrew/homebrew-core.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改homebrew-bottles访问地址"><a href="#修改homebrew-bottles访问地址" class="headerlink" title="修改homebrew-bottles访问地址"></a>修改homebrew-bottles访问地址</h2><p>修改 homebrew-bottles 访问地址与 MacOS 系统使用的 Shell 版本有关。<br>使用如下命令查看当前 Shell 版本</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo $SHELL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若当前使用的 Shell 版本为/bin/zsh，则替换方法为：<br></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 替换 homebrew-bottles 地址echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' &gt;&gt; ~/.zshrcsource ~/.zshrc# 还原 homebrew-bottles 地址vim ~/.zshrc# 编辑.zshrc文件source ~/.zshrc# 删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>若当前使用的 Shell 版本为/bin/bash，则替换方法为：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 替换 homebrew-bottles 地址echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' &gt;&gt; ~/.bash_profilesource ~/.bash_profile# 还原 homebrew-bottles 地址vim ~/.bash_profile# 编辑.zshrc文件source ~/.bash_profile# 删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="全部操作完成后，刷新brew源"><a href="#全部操作完成后，刷新brew源" class="headerlink" title="全部操作完成后，刷新brew源"></a>全部操作完成后，刷新brew源</h2><p>执行如下命令：<br></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 更新brewbrew update# 根据提示，可能需要执行git -C /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core fetch --unshallowgit -C /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask fetch --unshallow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p><strong>参考资料</strong></p><p>Mac下如何更改brew地址源<br><a href="https://www.cnblogs.com/feiquan/p/13267284.html">https://www.cnblogs.com/feiquan/p/13267284.html</a></p><p>mac brew更换国内源<br><a href="https://www.jianshu.com/p/bea984d27cd2">https://www.jianshu.com/p/bea984d27cd2</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 最佳实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理财训练营（2）</title>
      <link href="/2021/04/22/ke-cheng-bi-ji/li-cai-xun-lian-ying-2/"/>
      <url>/2021/04/22/ke-cheng-bi-ji/li-cai-xun-lian-ying-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 本学习笔记根据某投学堂提供资料整理学习</p></blockquote><h2 id="初识投资品：人人都该有的4个钱包"><a href="#初识投资品：人人都该有的4个钱包" class="headerlink" title="初识投资品：人人都该有的4个钱包"></a>初识投资品：人人都该有的4个钱包</h2><h3 id="投资不可能三角"><a href="#投资不可能三角" class="headerlink" title="投资不可能三角"></a>投资不可能三角</h3><p>投资品三个特征：安全性、流动性、收益性</p><p>投资不可能三角：没有一款投资品，可以兼顾高收益、高流动性和高安全性</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210422001152.png" alt="投资不可能三角" style="zoom:50%;"></p><h3 id="投资品的四种分类"><a href="#投资品的四种分类" class="headerlink" title="投资品的四种分类"></a>投资品的四种分类</h3><p>四大类：货币类、债权类、股权类、商品实物类</p><p>它们按特征分，处于不可能三角的不同位置</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210422001003.png" alt="不可能三角" style="zoom:50%;"></p><p>投资品的主要差异：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210422001003.png" alt="投资品的主要差异" style="zoom: 50%;"></p><h3 id="学会资产配置"><a href="#学会资产配置" class="headerlink" title="学会资产配置"></a>学会资产配置</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210422001433.png" alt="通用家庭资产象限图"></p><p>四个钱包：要花的钱，保命的钱，生钱的钱和保本的钱</p><p>要花的钱：3-6个月生活费</p><p>保命的钱：年收入的10%，意外险，重疾险等</p><p>生钱的钱：股票、基金，即有较高风险，较高收益</p><p>保本的钱：稳中有升，如国债，债券基金</p><p>投资100法则：</p><p>生钱的钱=投资本金*（100-现在的年龄）%</p><p>保本的钱=投资本金*现在的年龄%</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210422002359.png" alt="资产配置表"></p><h2 id="可转债打新实操入门"><a href="#可转债打新实操入门" class="headerlink" title="可转债打新实操入门"></a>可转债打新实操入门</h2><p>适合新手，下有保底，上不封顶的投资品：可转债</p><p>可转债，即可转换公司债券</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210422003039.png" alt="中信银行可转债表"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210422003149.png" alt="历史可转债收益情况"></p><p>可转债的性质：</p><ol><li>债券必须还本付息</li></ol><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210422003300.png" alt="已退市的可转债"></p><ol><li>发行可转债的公司，违约意愿小</li></ol><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210422003441.png" alt="一些新上市公司可转债数据"></p><ol><li>一定条件下，可转债能转换为公司股票</li></ol><h3 id="可转债的投资方法"><a href="#可转债的投资方法" class="headerlink" title="可转债的投资方法"></a>可转债的投资方法</h3><p>有两种：构建投资组合；可转债打新</p><p>构建投资组合：购买组合可转债，降低一只可转债的波动风险</p><p>可转债打新：申购即将上市的可转债</p><h2 id="选股方法"><a href="#选股方法" class="headerlink" title="选股方法"></a>选股方法</h2><p><strong>要投资，不要投机！</strong></p><p>股市里，永远不要高估自己的理性，更不要挑战自己的运气。</p><p>正确的做法：深入研究背后的公司，找到好公司，让好公司替我们赚钱。</p><p>投资股票，就是投资公司。</p><p>股票赚钱的方式：</p><ol><li>分红，如格力电器、双汇发展</li><li>赚股价上涨的差价</li></ol><p><strong>判断股票是否便宜的方法</strong></p><p>看市盈率（PE）和市净率（PB）</p><p>市盈率PE=买下公司需要的钱/每年能转到的钱</p><p>PE越小，越有投资价值</p><p>市净率PB=买下公司需要的钱/公司自己拥有的资产</p><p>PB越小，越具有投资价值</p><p>查询PE和PB的网站：<a href="www.lixinger.com">理杏仁</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bistoury综合资料</title>
      <link href="/2021/04/21/ji-zhu-xue-xi/bistoury/bistoury-zong-he-zi-liao/"/>
      <url>/2021/04/21/ji-zhu-xue-xi/bistoury/bistoury-zong-he-zi-liao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/qunarcorp/bistoury">bistoury官网</a></p><p><a href="https://cloud.tencent.com/developer/article/1553180">Bistoury原理解析</a></p><p><a href="https://github.com/qunarcorp/bistoury/releases">Bistoury-releases</a></p><p><a href="https://github.com/qunarcorp/bistoury/releases/download/v2.0.7/bistoury-2.0.7-quick-start.tar.gz">bistoury-2.0.7-quick-start.tar.gz</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持续更新 </tag>
            
            <tag> 监控技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bistoury使用及配置</title>
      <link href="/2021/04/20/ji-zhu-xue-xi/bistoury/bistoury-shi-yong-ji-pei-zhi/"/>
      <url>/2021/04/20/ji-zhu-xue-xi/bistoury/bistoury-shi-yong-ji-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="应用注册"><a href="#应用注册" class="headerlink" title="应用注册"></a>应用注册</h3><ul><li>一台主机（ip）只可绑定到一个应用</li></ul><h3 id="发布信息配置"><a href="#发布信息配置" class="headerlink" title="发布信息配置"></a>发布信息配置</h3><p>在日志目录下创建../webapps/releaseInfo.properties文件</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">#gitlab项目名project=tc/bistoury#项目所属module，没有module时值为英文句号[.]module=bistoury-ui#应用运行的版本号/分支/tagoutput=master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JVM参数配置"><a href="#JVM参数配置" class="headerlink" title="JVM参数配置"></a>JVM参数配置</h3><p>Agent启动前需要在bin/bistoury-agent-env.sh的JAVA_OPTS设置以下参数</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数名称</th><th style="text-align:left">是否必须</th><th style="text-align:left">默认值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">bistoury.store.path</td><td style="text-align:left">否</td><td style="text-align:left">/home/bistoury/store</td><td style="text-align:left">bistoury agent数据存放路径，包括rocksdb存放的监控、jstack及jmap数据和反编译代码临时文件的存放</td></tr><tr><td style="text-align:left">bistoury.proxy.host</td><td style="text-align:left">是</td><td style="text-align:left"></td><td style="text-align:left">proxy的域名，具体值请联系管理员，agent依赖该值获取proxy的连接配置信息</td></tr><tr><td style="text-align:left">bistoury.app.lib.class</td><td style="text-align:left">是</td><td style="text-align:left"></td><td style="text-align:left">应用依赖的jar包中的一个类（推荐使用公司内部中间件的jar包或Spring相关包中的类，如org.springframework.web.servlet.DispatcherServlet），agent通过该类获取加载应用类的classloader</td></tr><tr><td style="text-align:left">bistoury.pid.handler.jps.symbol.class</td><td style="text-align:left">否</td><td style="text-align:left">org.apache.catalina.startup.Bootstrap</td><td style="text-align:left">attach的应用入口类，用于使用jps -l命令获取应用pid</td></tr><tr><td style="text-align:left">bistoury.pid.handler.jps.enable</td><td style="text-align:left">否</td><td style="text-align:left">true</td><td style="text-align:left">是否打开通过jps -l获取pid的开关</td></tr><tr><td style="text-align:left">bistoury.pid.handler.ps.enable</td><td style="text-align:left">否</td><td style="text-align:left">true</td><td style="text-align:left">是否打开通过ps aux</td></tr><tr><td style="text-align:left">bistoury.app.classes.path</td><td style="text-align:left">否</td><td style="text-align:left">bistoury.app.lib.class对应jar包目录同级的classes目录</td><td style="text-align:left">项目代码编译后字节码存放目录，一般情况下为classes目录</td></tr><tr><td style="text-align:left">bistoury.agent.workgroup.num</td><td style="text-align:left">否</td><td style="text-align:left">2</td><td style="text-align:left">agent netty work group 线程数</td></tr><tr><td style="text-align:left">bistoury.agent.thread.num</td><td style="text-align:left">否</td><td style="text-align:left">16</td><td style="text-align:left">agent执行命令的线程数</td></tr></tbody></table></div><h3 id="启动bistoury-agent"><a href="#启动bistoury-agent" class="headerlink" title="启动bistoury agent"></a>启动bistoury agent</h3><p>启动是可以通过-p指定pid确定agent attach特定的java进程，不指定时会通过jps -l和ps aux|grep java 命令及proxy中配置的参数解析pid，优先级依次降低。</p><p>使用 <code>./bistoury-agent.sh -h</code> 查看脚本参数信息</p><ul><li>启动</li></ul><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">./bistoury-agent.sh -p 100 start./bistoury-agent.sh start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>停止</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">./bistoury-agent.sh stop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>重启</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">./bistoury-agent.sh -p 101 restart./bistoury-agent.sh restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><ul><li>使用Spring EL表达式，基于 spring-expression 3.2.8.RELEASE</li><li>局部变量<code>localVariables[a]</code></li><li>类属性<code>fields[a]</code></li><li>静态变量<code>staticFields[A]</code></li><li>支持逻辑连接符：<code>&amp;&amp;</code>、 <code>||</code>、 <code>==</code>，符号两侧不可有空格</li><li>表达式最终结果是个布尔值</li><li>支持的方法白名单:<code>equals</code>, <code>length</code>, <code>valueOf</code>, <code>toString</code>, <code>hashCode</code>, <code>compareTo</code>, <code>size</code>, <code>count</code></li></ul><p><a href="https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions-language-ref">Spring EL表达式官网使用规则</a></p><p>Spring EL 表达式样例</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">localVariables[content].value.equals("aaa")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="获取源码的方式"><a href="#获取源码的方式" class="headerlink" title="获取源码的方式"></a>获取源码的方式</h3><p>三种：</p><ul><li>反编译字节码</li><li>项目代码从git获取源码</li><li>jar包里的类从maven获取源码</li></ul><p>反编译字节码无需配置；git和maven需要做一些配置。</p><p>git目前仅支持gitlab api3 和 github。</p><h4 id="配置发布信息"><a href="#配置发布信息" class="headerlink" title="配置发布信息"></a>配置发布信息</h4><p>配置发布信息位置：<code>bistoury-proxy-bin/conf/releaseInfo_config.properties</code></p><p>默认值：<code>/tmp/bistoury/releaseInfo.properties</code></p><p>默认提供<code>properties</code>文件解析。若需要自定义文件解析方法，可实现<code>qunar.tc.bistoury.ui.util.ReleaseInfoParse</code>接口，并在<code>qunar.tc.bistoury.ui.service.impl.ReleaseInfoServiceImpl</code>中修改实现类</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">#gitlab项目名，项目名组成：owner/repoproject=tc/bistoury#项目所属module，没有module时值为英文句号[.]module=bistoury-ui#应用运行的版本hash/分支/tagoutput=master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><p>配置文件在<code>bistoury-ui-bin/conf/config.properties</code></p><p>配置仓库类型：<code>git.repository</code>，值为github或gitlabv3</p><p>配置仓库地址：<code>git.endpoint</code>，giblab填写首页地址；github填写api地址（<a href="https://api.github.com）">https://api.github.com）</a></p><p>配置private token：<code>bistoury-ui-bin/conf/url_redirect.properties</code> <code>gitlab.private.token.url</code></p><pre><code>* gitlab获取位置一般在gitlab&gt;Profile Settings&gt;Account* github获取位置一般在github&gt;settings&gt;Developer settings&gt;Personal access tokens，链接一般为：[https://github.com/settings/tokens](https://github.com/settings/tokens)</code></pre><p>配置private token：在线debug和动态监控页面按钮上方都有一个配置private token的链接，点击配置private token。</p><p>配置目录格式：<code>bistoury-ui-bin/conf/config.properties</code> <code>file.path.format</code></p><h4 id="maven配置"><a href="#maven配置" class="headerlink" title="maven配置"></a>maven配置</h4><p>maven配置之后可以从maven私服下载源码，所以需要在<code>bistoury-ui-bin/conf/config.properties</code>文件中配置<code>maven.nexus.url</code>为jar source的下载链接</p><ul><li>获取的key为<code>ETag</code></li><li>值的格式：<code>{SHA1{d32c943ba20a1351181e11adb71f7e3e28bdfe3c}}</code>，其中SHA1是hash算法，<code>d32c943ba20a1351181e11adb71f7e3e28bdfe3c</code>是hash值</li><li>hash算法支持MD5、SHA1和SHA256</li></ul><h3 id="应用PID的获取方式"><a href="#应用PID的获取方式" class="headerlink" title="应用PID的获取方式"></a>应用PID的获取方式</h3><p>按以下顺序获取：</p><ul><li>系统参数指定</li><li>jps -l获取</li><li>ps aux|grep java 获取</li></ul><p>使用系统参数指定，则应用重启后也需要重启agent</p><p>使用jps -l或ps aux|grep java获取，重启不需要重启agent</p><blockquote><p><strong>参考资料</strong></p><p>Bistoury官网网站及文档：</p><p><a href="https://github.com/qunarcorp/bistoury">https://github.com/qunarcorp/bistoury</a></p></blockquote><h2 id="详细部署方法"><a href="#详细部署方法" class="headerlink" title="详细部署方法"></a>详细部署方法</h2><h4 id="推荐部署方法"><a href="#推荐部署方法" class="headerlink" title="推荐部署方法"></a>推荐部署方法</h4><ul><li><p>ui 独立部署，推荐部署在多台机器，并提供独立的域名</p></li><li><p>proxy 独立部署，推荐部署在多台机器，并提供独立的域名</p></li><li><p>agent 需要和应用部署在同一台机器上。推荐在测试环境全环境自动部署，线上环境提供单机一键部署，以及应用下所有机器一键部署</p></li><li><p>独立的应用中心，管理所有功能内部应用和机器信息，这是一个和 Bistoury 相独立的系统，Bistoury 从中拿到不断更新的应用和机器信息</p></li></ul><h4 id="环境支持"><a href="#环境支持" class="headerlink" title="环境支持"></a>环境支持</h4><p>OS: Linux</p><p>Java: ui、proxy使用Java1.8+，agent使用java1.7+</p><p>注册中心：zookeeper</p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><ul><li>1、初始化数据库：Bistoury的ui和proxy依赖数据库，所以需要事先创建并完成初始化</li><li>2、获取安装包：Bistoury的安装包共三个，bistoury-ui、bistoury-proxy和bistoury-agent，通过源码构建安装包</li><li>3、部署：获取安装包后修改对应的配置文件后就可以通过脚本进行部署到测试和生产环境了</li></ul><h4 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h4><p>sql文件在bistoury-ui安装包的sql目录下</p><p>ui和proxy需配置相同的数据库</p><p>配置文件在<code>conf/jdbc.properties</code>文件中</p><h4 id="获取安装包"><a href="#获取安装包" class="headerlink" title="获取安装包"></a>获取安装包</h4><p>安装包一共有两种，local和prod，local本地快速启动用，使用h2数据库；prod使用MySQL数据库</p><p>修改好各个配置文件后，执行脚本</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">./build.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>生成的文件在</strong></p><p>bistoury-dist/target/bistoury-agent-bin.tar.gz</p><p>bistoury-ui/target/bistoury-ui-bin.tar.gz</p><p>bistoury-proxy/target/bistoury-proxy-bin.tar.gz</p>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑中 </tag>
            
            <tag> 监控技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bistoury搭建及使用问题解决记录</title>
      <link href="/2021/04/20/ji-zhu-xue-xi/bistoury/bistoury-da-jian-ji-shi-yong-wen-ti-jie-jue-ji-lu/"/>
      <url>/2021/04/20/ji-zhu-xue-xi/bistoury/bistoury-da-jian-ji-shi-yong-wen-ti-jie-jue-ji-lu/</url>
      
        <content type="html"><![CDATA[<h3 id="解决agent无法启动问题"><a href="#解决agent无法启动问题" class="headerlink" title="解决agent无法启动问题"></a><strong>解决agent无法启动问题</strong></h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>打开UI后，页面提示agent没有启动</p><h4 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h4><p>查看agent日志，提示某个GC命令不存在，推测为java版本问题。由于之前在官网下载的Java最新版本，使之不兼容一些原有命令。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>删除系统中的java，并重新根据要求，安装Jdk1.8，重新启动bistoury，问题解决。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>Bistoury官网及使用文档：<a href="https://github.com/qunarcorp/bistoury">https://github.com/qunarcorp/bistoury</a></p><h3 id="排查arthas未正常启动问题"><a href="#排查arthas未正常启动问题" class="headerlink" title="排查arthas未正常启动问题"></a>排查arthas未正常启动问题</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>UI启动后，在主机信息-文件信息下报错：</p><p>Agent error: java.lang.IllegalStateException—-can not init bistoury, start arthas error, pid [30043],Agent JAR loaded but agent failed to initialize</p><h4 id="排查过程-1"><a href="#排查过程-1" class="headerlink" title="排查过程"></a>排查过程</h4><p>官方文档中有提及：agent attach时加载初始化类失败，即arthas未成功加载。</p><p>其日志目录为：<strong>/root/logs/arthas/arthas.log</strong></p><p>日志中关键错误信息：</p><p>java.lang.IllegalStateException: can not find lib class, [org.springframework.web.servlet.DispatcherServlet]</p><p>官方参考启动命令：</p><p><strong>./quick_ start.sh -c org.springframework.web.servlet.DispatcherServlet  -p 1024 start</strong></p><p>询问曹奇<strong>org.springframework.web.servlet.DispatcherServlet</strong> 的引用方式，发现实际上helloworld-jenkins-pipeline.war包并没有正确放置正确，放在tomcat里的是个zip包！</p><h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4><p>根据参考资料，尝试使用以下命令重新启动</p><p>./quick_start.sh -c  org.springframework.web.servlet.DispatcherServlet  -p 30043 -i 172.20.59.153 start</p><p>问题仍未解决</p><p>配置idea，重新构建出helloworld-jenkins-pipeline.war包，并重新启动bistoury，该问题解决</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p>官方FAQ：<a href="https://github.com/lqnasa/bistoury/blob/master/docs/cn/FAQ.md">https://github.com/lqnasa/bistoury/blob/master/docs/cn/FAQ.md</a></p><p>Spring 官网下载地址：<a href="https://repo.spring.io/webapp/#/artifacts/browse/tree/General/libs-release-local/org/springframework/spring/5.2.9.RELEASE">https://repo.spring.io/webapp/#/artifacts/browse/tree/General/libs-release-local/org/springframework/spring/5.2.9.RELEASE</a></p><p>官网下载Spring的jar包教程：<a href="https://blog.csdn.net/qq_35661171/article/details/86165467">https://blog.csdn.net/qq_35661171/article/details/86165467</a></p><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><h4 id="排查过程-2"><a href="#排查过程-2" class="headerlink" title="排查过程"></a>排查过程</h4><h4 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h4><h4 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h4>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持续更新 </tag>
            
            <tag> 监控技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bistoury功能详解</title>
      <link href="/2021/04/20/ji-zhu-xue-xi/bistoury/bistoury-gong-neng-xiang-jie/"/>
      <url>/2021/04/20/ji-zhu-xue-xi/bistoury/bistoury-gong-neng-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="Bistoury介绍"><a href="#Bistoury介绍" class="headerlink" title="Bistoury介绍"></a>Bistoury介绍</h2><p>开发者：去哪儿网</p><p>功能：从日志、内存、线程、类信息、调试、机器和系统属性等各个方面对应用进行诊断</p><p>目的：提升开发人员诊断问题的效率和能力</p><p>集成：Alibaba开源的<a href="https://github.com/alibaba/arthas">arthas</a>和唯品会开源的<a href="https://github.com/vipshop/vjtools">vjtools</a></p><p><a href="https://github.com/alibaba/arthas/blob/master/README_CN.md">Arthhas官方中文说明</a></p><ul><li>Arthas和vjtools通过命令行或类似的方式使用</li><li>Arthas和vjtools针对单台机器，从机器的维度对系统进行诊断</li></ul><h3 id="Bistoury特点及优势"><a href="#Bistoury特点及优势" class="headerlink" title="Bistoury特点及优势"></a>Bistoury特点及优势</h3><ul><li>Bistoury图形化界面</li><li>提供全局的视角（多台机器）</li><li>提供统一的web入口</li><li>在线debug功能：通过web界面提供断点调试的功能，可以在<strong>不阻塞</strong>应用的情况下捕获断点处的信息</li><li>线程级cpu使用率监控：监控系统每个线程的分钟级cpu使用率</li><li>动态对方法添加监控：监控方法的调用次数、异常次数和执行时间</li><li>日志查看功能：可对单台或同时对多台机器的日志进行查看</li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="Bistoury-能做什么？"><a href="#Bistoury-能做什么？" class="headerlink" title="Bistoury 能做什么？"></a>Bistoury 能做什么？</h3><ul><li>查看应用日志</li><li>查看主机运行状态</li><li>在线debug</li><li>动态监控</li><li>线程级cpu使用率监控</li><li>JVM运行状态监控</li><li>thread dump</li><li>jstack</li><li>jmap</li><li>JVM数据紧急收集，一键收集jstack、jmap以及GC日志等相关信息</li><li>能查看这个类从哪个 jar 包加载的，为什么会报各种类相关的 Exception。</li><li>从全局视角来查看系统的运行状况。</li><li>觉得代码和想的不一样？反编译class试试</li></ul><h2 id="Bistoury技术架构"><a href="#Bistoury技术架构" class="headerlink" title="Bistoury技术架构"></a>Bistoury技术架构</h2><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>Bistoury必要模块：<strong>agent，proxy，ui</strong></p><p>其他模块：<strong>用户系统，注册中心，负载均衡器，应用中心</strong></p><p><strong>用户系统</strong>：待诊断的正在运行的应用</p><p><strong>agent</strong>: 接收、执行、返回从proxy传递过来的命令，目前一个agent对应一个用户系统；一个agent注册到一个proxy上</p><p><strong>proxy</strong>: 接收ui传来的命令，并传递给agent</p><p><strong>ui</strong>: 图形化界面，接收操作者指令，下发指令给proxy，为用户展示结果</p><p><strong>负载均衡器</strong>：为proxy做负载均衡</p><p><strong>注册中心</strong>：注册所有proxy的地址；注册中心目前仅支持zookeeper</p><p>应用中心：获取用户的应用信息和机器信息，bistoury只自带一个微信用户中心，需要用户接入自己的应用中心（通过实现bistoury-application模块的相关api接入）</p><h3 id="各逻辑链条"><a href="#各逻辑链条" class="headerlink" title="各逻辑链条"></a>各逻辑链条</h3><h4 id="agent连接proxy"><a href="#agent连接proxy" class="headerlink" title="agent连接proxy"></a>agent连接proxy</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210420203023.png" alt="agent连接proxy"></p><ol><li>agent通过域名访问proxy</li><li>访问请求打到proxy2这台机器上</li><li>proxy2返回自身ip和注册信息</li><li>agent接收到注册信息</li><li>agent注册到proxy2上，建立连接</li></ol><h4 id="ui根据命令选择proxy"><a href="#ui根据命令选择proxy" class="headerlink" title="ui根据命令选择proxy"></a>ui根据命令选择proxy</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210420203130.png" alt="UI根据命令选择proxy"></p><ol><li>proxy集群机器全部注册到注册中心上</li><li>ui从注册中心获取到全部的proxy地址信息</li><li>ui从应用中心拿到要执行命令的机器信息</li><li>ui请求proxy1，判断要执行命令的机器是否与proxy1连接</li><li>ui请求proxy2，判断要执行命令的机器是否与proxy2连接</li><li>proxy1返回结果为否</li><li>proxy2返回连接存在</li></ol><h4 id="命令执行与结果返回"><a href="#命令执行与结果返回" class="headerlink" title="命令执行与结果返回"></a>命令执行与结果返回</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210420203408.png" alt="命令执行与结果返回"></p><ol><li>ui将命令信息发给proxy2</li><li>proxy2将命令发给agent</li><li>agent将命令发给用户系统（如果需要访问用户系统的话）</li><li>用户系统将结果返回给agent（如果需要访问用户系统的话）</li><li>agent将结果返回给proxy2</li><li>proxy2将结果返回给ui</li></ol><h2 id="功能详细说明"><a href="#功能详细说明" class="headerlink" title="功能详细说明"></a>功能详细说明</h2><h3 id="在线debug"><a href="#在线debug" class="headerlink" title="在线debug"></a>在线debug</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li><p>模拟IDE的调试体验</p></li><li><p>可以直接在代码上添加断点</p></li><li><p>支持条件断点</p></li><li><p>可查看本地变量、成员变量、静态变量以及调用栈</p></li><li>在线debug不需要应用重启</li><li>系统不挂起，只打印快照信息</li></ul><h4 id="待改进"><a href="#待改进" class="headerlink" title="待改进"></a>待改进</h4><ul><li>只会触发一次</li><li>目前原代码只支持gitlab，若不设置token，只通过反编译获取原代码</li></ul><h4 id="技术特点"><a href="#技术特点" class="headerlink" title="技术特点"></a>技术特点</h4><ul><li>条件表达式使用Spring EL表达式</li></ul><h3 id="线程级CPU监控"><a href="#线程级CPU监控" class="headerlink" title="线程级CPU监控"></a>线程级CPU监控</h3><ul><li>保存最近3天的线程级别监控数据</li></ul><h3 id="动态监控"><a href="#动态监控" class="headerlink" title="动态监控"></a>动态监控</h3><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>性能分析结果默认只保存三天</p><p>Java支持的三种方式：插桩统计，同步抽样，异步抽样</p><p>Bistoury采用异步抽样</p>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑中 </tag>
            
            <tag> 监控技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS搭建Nginx</title>
      <link href="/2021/04/20/zui-jia-shi-jian/centos-da-jian-nginx/"/>
      <url>/2021/04/20/zui-jia-shi-jian/centos-da-jian-nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="使用Yum安装方法"><a href="#使用Yum安装方法" class="headerlink" title="使用Yum安装方法"></a>使用Yum安装方法</h2><ol><li>添加yum源</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或在/etc/yum.repo.d/目录下，新建新Yum源<br></p><pre class="line-numbers language-none"><code class="language-none">[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.key[nginx-mainline]name=nginx mainline repobaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck=1enabled=0gpgkey=https://nginx.org/keys/nginx_signing.key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><ol><li>安装Nginx</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yum search nginx# 查看yum源是否包含nginxyum install -y nginx# 安装Nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li><p>启动Nginx并设置开机自动运行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 启动Nginxsystemctl start nginx# 系统开机自动启动Nginxsystemctl enable nginx# 查看Nginx状态systemctl status nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>访问Nginx</p></li></ol><ul><li>Nginx默认占用端口为80</li><li>默认配置文件在 /etc/nginx/nginx.conf </li><li>项目部署目录为 /usr/share/nginx/html/</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lsof -i:80# 查看80端口占用情况<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>配置nginx下载目录</li></ol><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 在nginx配置文件中增加下载目录# 此配置的文件下载目录为/data/download    location ~ ^/download {         root            /data/;        autoindex on;  # 开启目录文件列表        autoindex_exact_size on;  # 显示出文件的确切大小，单位是bytes        autoindex_localtime on;  # 显示的文件时间为文件的服务器时间        charset utf-8,gbk;  # 避免中文乱码    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用安装包安装Nginx方法"><a href="#使用安装包安装Nginx方法" class="headerlink" title="使用安装包安装Nginx方法"></a>使用安装包安装Nginx方法</h2><ol><li><p>下载Nginx安装包，并解压</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget http://nginx.org/download/nginx-1.9.9.tar.gztar -zxvf nginx-1.9.9.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>进入Nginx目录，安装编译Nginx</p></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 可将Nginx安装至 /usr/local/nginx./configuremakemake install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>查看修改Nginx配置文件nginx.conf</p></li><li><p>启动Nginx服务</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">/usr/local/nginx/sbin./nginx# 启动命令ps -ef | grep nginx# 查看nginx服务是否启动成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="nginx配置文件说明"><a href="#nginx配置文件说明" class="headerlink" title="nginx配置文件说明"></a>nginx配置文件说明</h2><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">#user  nobody;worker_processes  1; #工作进程：数目。根据硬件调整，通常等于cpu数量或者2倍cpu数量。 #错误日志存放路径#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info; #pid        logs/nginx.pid; # nginx进程pid存放路径  events {    worker_connections  1024; # 工作进程的最大连接数量}  http {    include       mime.types; #指定mime类型，由mime.type来定义    default_type  application/octet-stream;     # 日志格式设置    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '    #                  '$status $body_bytes_sent "$http_referer" '    #                  '"$http_user_agent" "$http_x_forwarded_for"';     #access_log  logs/access.log  main; #用log_format指令设置日志格式后，需要用access_log来指定日志文件存放路径    sendfile        on; #指定nginx是否调用sendfile函数来输出文件，对于普通应用，必须设置on。如果用来进行下载等应用磁盘io重负载应用，可设着off，以平衡磁盘与网络io处理速度，降低系统uptime。    #tcp_nopush     on; #此选项允许或禁止使用socket的TCP_CORK的选项，此选项仅在sendfile的时候使用     #keepalive_timeout  0;  #keepalive超时时间    keepalive_timeout  65;     #gzip  on; #开启gzip压缩服务     #虚拟主机    server {        listen       80;  #配置监听端口号        server_name  localhost; #配置访问域名，域名可以有多个，用空格隔开         #charset koi8-r; #字符集设置         #access_log  logs/host.access.log  main;         location / {            root   html;            index  index.html index.htm;        }        #错误跳转页        #error_page  404              /404.html;          # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }         # proxy the PHP scripts to Apache listening on 127.0.0.1:80        #        #location ~ \.php$ {        #    proxy_pass   http://127.0.0.1;        #}         # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        #location ~ \.php$ { #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。        #    root           html; #根目录        #    fastcgi_pass   127.0.0.1:9000; #请求转向定义的服务器列表        #    fastcgi_index  index.php; # 如果请求的Fastcgi_index URI是以 / 结束的, 该指令设置的文件会被附加到URI的后面并保存在变量$fastcig_script_name中        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        #    include        fastcgi_params;        #}         # deny access to .htaccess files, if Apache's document root        # concurs with nginx's one        #        #location ~ /\.ht {        #    deny  all;        #}    }      # another virtual host using mix of IP-, name-, and port-based configuration    #    #server {    #    listen       8000;    #    listen       somename:8080;    #    server_name  somename  alias  another.alias;     #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}      # HTTPS server    #    #server {    #    listen       443 ssl;  #监听端口    #    server_name  localhost; #域名     #    ssl_certificate      cert.pem; #证书位置    #    ssl_certificate_key  cert.key; #私钥位置     #    ssl_session_cache    shared:SSL:1m;    #    ssl_session_timeout  5m;      #    ssl_ciphers  HIGH:!aNULL:!MD5; #密码加密方式    #    ssl_prefer_server_ciphers  on; # ssl_prefer_server_ciphers  on; #      #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>参考资料</strong></p><p>centOS7安装nginx及nginx配置<br><a href="https://blog.csdn.net/qq_37345604/article/details/90034424">https://blog.csdn.net/qq_37345604/article/details/90034424</a></p><p>CentOS7中使用yum安装Nginx的方法<br><a href="https://www.cnblogs.com/songxingzhu/p/8568432.html">https://www.cnblogs.com/songxingzhu/p/8568432.html</a></p><p>CentOS7.X中使用yum安装nginx的方法<br><a href="https://www.cnblogs.com/opsprobe/p/10773582.html">https://www.cnblogs.com/opsprobe/p/10773582.html</a></p><p>nginx配置下载目录<br><a href="https://cloud.tencent.com/developer/article/1366668">https://cloud.tencent.com/developer/article/1366668</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 最佳实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS搭建Zookeeper</title>
      <link href="/2021/04/20/zui-jia-shi-jian/centos-da-jian-zookeeper/"/>
      <url>/2021/04/20/zui-jia-shi-jian/centos-da-jian-zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="使用Yum安装方法"><a href="#使用Yum安装方法" class="headerlink" title="使用Yum安装方法"></a>使用Yum安装方法</h2><ol><li><p>从<a href="http://mirror.bit.edu.cn/apache/zookeeper/">Zookeeper官网</a>，下载安装包<br><a href="http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz">3.4.14 版本的 ZooKeeper</a></p></li><li><p>上传安装包至服务器，或在服务器中直接下载安装包，并解压</p></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gztar -xvf zookeeper-3.4.14.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>创建 ZooKeeper 数据文件存放目录、以及日志存放目录</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir -p /root/zookeeper/tmpmkdir -p /root/zookeeper/log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>在conf目录中，复制并编辑Zookeeper的配置文件</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd confcp zoo_sample.cfg zoo.cfgvim zoo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">dataDir=/root/zookeeper/tmpdataLogDir=/root/zookeeper/log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>进入bin目录，启动并查看Zookeeper的状态</li></ol><pre class="line-numbers language-none"><code class="language-none">cd bin./zkServer.sh start./zkServer.sh status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>参考资料</strong></p><p>CentOS下ZooKeeper的安装教程（单机模式）<br><a href="https://www.hangge.com/blog/cache/detail_2790.html">https://www.hangge.com/blog/cache/detail_2790.html</a></p><p>CentOS 7下安装 Zookeeper单机版<br><a href="https://www.linuxidc.com/Linux/2017-01/139731.htm">https://www.linuxidc.com/Linux/2017-01/139731.htm</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 最佳实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL查询视图、函数及存储过程</title>
      <link href="/2021/04/20/zui-jia-shi-jian/mysql-cha-xun-cun-chu-guo-cheng/"/>
      <url>/2021/04/20/zui-jia-shi-jian/mysql-cha-xun-cun-chu-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="查询MySQL视图"><a href="#查询MySQL视图" class="headerlink" title="查询MySQL视图"></a>查询MySQL视图</h2><p>查看视图<br></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * from information_schema.VIEWS   //视图SELECT * from information_schema.TABLES   //表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><h2 id="查询MySQL函数及存储过程"><a href="#查询MySQL函数及存储过程" class="headerlink" title="查询MySQL函数及存储过程"></a>查询MySQL函数及存储过程</h2><p>方法一<br></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select `name` from mysql.proc where db = 'your_db_name' and `type` = 'PROCEDURE'   //存储过程select `name` from mysql.proc where db = 'your_db_name' and `type` = 'FUNCTION'    //函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><p>方法二<br></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">show procedure status;    //存储过程show function status;     //函数show function status where db='giangao' ; ---数据库名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><p>查看存储过程或函数的创建代码<br></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">show create procedure proc_name;show create function func_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><h2 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h2><p>方法一:<br></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">语法：SHOW TRIGGERS [FROM db_name] [LIKE expr]实例：SHOW TRIGGERS\G     //触发器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><p>方法二:<br></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">对INFORMATION_SCHEMA数据库中的TRIGGERS表查询mysql&gt;SELECT * FROM triggers T WHERE trigger_name=”mytrigger” \G<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><blockquote><p><strong>参考文档</strong></p><p>MySQL查看存储过程和函数、视图和触发器<br><a href="https://blog.csdn.net/dbagaoshou/article/details/81940859">https://blog.csdn.net/dbagaoshou/article/details/81940859</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 最佳实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学课程笔记（9）</title>
      <link href="/2021/04/18/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-9/"/>
      <url>/2021/04/18/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-9/</url>
      
        <content type="html"><![CDATA[<h2 id="条件概率与期望-Conditional-Probability-and-Expectation"><a href="#条件概率与期望-Conditional-Probability-and-Expectation" class="headerlink" title="条件概率与期望 Conditional Probability and Expectation"></a>条件概率与期望 Conditional Probability and Expectation</h2><h3 id="条件概率-Conditional-Probability"><a href="#条件概率-Conditional-Probability" class="headerlink" title="条件概率 Conditional Probability"></a>条件概率 Conditional Probability</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>已知S下，E的概率为</p><script type="math/tex; mode=display">P(E|S)=\frac{P(E\cap S)}{P(S)},\quad E,S\subseteq\Omega</script><p>仅当$P(S)\neq0$</p><p>注意，$P(A|B)$和$P(B|A)$一般情况下不相关，即其中一个值本身无法预测另一个值。唯一的特例是，若$P(A),P(B)\neq 0$，当且仅当$P(A\cap B)=0$时，$P(A|B)=0$，$P(B|A)=0$</p><p>如果$P$在有限集$ω$上的均匀分布，那么</p><script type="math/tex; mode=display">P(E|S)=\frac{\frac{|E\cap S|}{|\Omega|}}{\frac{|S|}{|\Omega|}}=\frac{|E\cap S|}{|S|}</script><h3 id="一些一般规则"><a href="#一些一般规则" class="headerlink" title="一些一般规则"></a>一些一般规则</h3><p>事实上，</p><script type="math/tex; mode=display">\begin{align}A ⊆ B & ⇒ P(A|B) ≥ P(A) \\A ⊆ B & ⇒ P(B|A) = 1 \\P(A ∩ B|B) & = P(A|B) \\P(∅|A) & = 0 \ 对于\ A \neq ∅ \\P(A|Ω) & = P(A) \\P(A^c|B) & = 1 - P(A|B) \\P(A^c\cap B) & = P(B) - P(A\cap B) \\P(A) & = P(A|B) P(B)+ P(A|B^c)P(B^c)\end{align}</script><p>注意：</p><p>$P(A|B)$与$P(A|B^C)$不相关</p><p>$P(A|B),P(B|A),P(A^C|B^C),P(B^C|A^C)$不相关</p><p><strong>贝叶斯公式 Bayes’ Formula</strong>：$P(S|B)\cdot P(B)=P(B|S)\cdot P(S)$ </p><p>推论：如果$P(A|B)&gt; P(A)$（正相关），那么$P(B|A)&gt; P(B)$ </p><h3 id="随机独立-Stochastic-Independence"><a href="#随机独立-Stochastic-Independence" class="headerlink" title="随机独立 Stochastic Independence"></a>随机独立 Stochastic Independence</h3><p><strong>定义</strong>：如果$P(A\cap B)=P(A)\cdot P(B)$，那么称A和B随机独立，记作$A\perp B$</p><p>如果$P(A)\neq 0$，且$P(B)\neq 0$，那么以下所有等价：</p><script type="math/tex; mode=display">P(A ∩ B) = P(A)\cdot P(B) \\P(A|B) = P(A) \\P(B|A) = P(B) \\P(A\cup B)=P(A)+P(B)-P(A)\cdot P(B) \\P(A^C|B) = P(A^C) 或 P(A|B^C) = P(A) 或 P(A^C|B^C) = P(A^C)</script><p>最后一条也意味着：</p><p>$A\perp B \Leftrightarrow A^C\perp B \Leftrightarrow A\perp B^C \Leftrightarrow A^C\perp B^C$</p><p>基本非独立事件集（如果$P(A)， P(B) &gt; 0$）</p><ul><li><p>$A\subseteq B$</p></li><li><p>$A\cap B=\emptyset$</p></li><li>任意单值事件$\{x\},\{y\}$:要么$x=y$且$P(x|y)=1$，或者$x\neq y$且$P(x|y)=0$</li></ul><p>对于独立的$A_1,\dots,A_n$，对所有的可能集$A_{i_{1}},A_{i_{2}},\dots,A_{i_{k}}$</p><p>$P(A_{i_{1}} \cap A_{i_{2}} \cap \dots \cap A_{i_{k}})=P(A_{i_{1}})\cdot P(A_{i_{2}}) \cdots P(A_{i_{k}})$</p><p>这通常被称为<strong>完全独立</strong>  <strong><em>full independence</em></strong></p><p>两两独立是一个较弱的概念。</p><p>我们也可以构造一个$n$个事件的集合，其中任意$k$个事件是独立的，而任意$k + 1$个事件是相互依赖的</p><p>总体可能性：$P(A)=P(A|B)\cdot P(B) + P(A|B^C)\cdot P(B^C)$</p><h3 id="随机变量-Random-Variables"><a href="#随机变量-Random-Variables" class="headerlink" title="随机变量 Random Variables"></a>随机变量 Random Variables</h3><p><strong>定义</strong>：（整数）随机变量是从$\Omega$到$Z$的函数。换句话说，它将一个数值与每个结果相关联。</p><p>随机变量通常用$X, Y, Z，…$表示。</p><h3 id="期望-Expectation"><a href="#期望-Expectation" class="headerlink" title="期望 Expectation"></a>期望 Expectation</h3><p><strong>定义</strong>：随机变量X的期望值(通常称为“期望”或“平均值”)为</p><script type="math/tex; mode=display">E(X)=\sum_{k \in \mathbb{Z}}{P(X=k) \cdot k}</script><p><strong>注</strong>：期望是一个真正普遍的概念；它是一切决策的基础，是估计收益和损失的基础，是一切冒险行为的基础。从历史上看，期望值的基本概念比概率的概念早得多。</p><p><strong>定理</strong>（期望值线性）</p><script type="math/tex; mode=display">E(X + Y ) = E(X) + E(Y ) \\E(c · X) = c · E(X)</script><p><strong>二项身份</strong> binomial identity:$\sum\limits_{k=0}^{n}{(\begin{array}{1}n \\ k\end{array})}=2^n$</p><p><strong>注意</strong>：如果$X_1 X_2…， X_n$是独立的恒等分布随机变量，则$E(X_1 + X_2 +…+ X_n)$和$E(nX_1)$是一样的，但它们是非常不同的随机变量。</p><p><strong>几何级数 geometric progressions</strong></p><p><strong>定理</strong>：看到概率为p的事件的平均试验次数是$A = \frac{1}{p}$。</p><h3 id="标准差和方差-Standard-Deviation-and-Variance"><a href="#标准差和方差-Standard-Deviation-and-Variance" class="headerlink" title="标准差和方差 Standard Deviation and Variance"></a>标准差和方差 Standard Deviation and Variance</h3><p><strong>定义</strong>：对于具有期望值（或:均值）的随机变量$X\ µ= E(X)$，$X$的<strong>标准差 <em>standard deviation</em> </strong>为</p><script type="math/tex; mode=display">\sigma=\sqrt{E((X-\mu )^2)}</script><p>X的<strong>方差 <em>variance</em></strong>为：$\sigma^2$</p><p>标准差和方差测量随机变量值的分布情况。对于随机选择的$ω$， $σ^2$越小，我们就越确信$X(ω)$接$近E(X)$。</p><p><strong>注意</strong>：方差可以计算为$E((X-µ)^2 ) = E(X^2)- µ^2$</p><h3 id="累积分布函数-Cumulative-Distribution-Functions"><a href="#累积分布函数-Cumulative-Distribution-Functions" class="headerlink" title="累积分布函数 Cumulative Distribution Functions"></a>累积分布函数 Cumulative Distribution Functions</h3><p><strong>定义</strong>：定义整数随机变量$X$的累积分布函数$CDF_X: \mathbb{Z}→\mathbb{R}$为</p><script type="math/tex; mode=display">CDF_X(y)\mapsto \sum_{k\leq y} {P(X=k)}</script><p>$CDF_X (y)$累积在$y$之前所有值的概率$P(X)$</p><h4 id="例如：二项分布-Binomial-Distributions"><a href="#例如：二项分布-Binomial-Distributions" class="headerlink" title="例如：二项分布 Binomial Distributions"></a>例如：二项分布 Binomial Distributions</h4><p><strong>定义</strong>：二项随机变量计算n个独立实验中成功的次数，每个实验的概率为p。</p><script type="math/tex; mode=display">P(X=k)=(\begin{matrix} n \\ k\end{matrix})p^k(1-p)^{n-k} \\CDF_B(y)\mapsto \sum_{k\leq y}(\begin{matrix} n \\ k\end{matrix})p^k(1-p)^{n-k}</script><p><strong>定理</strong>：如果$X$是一个基于$n$次和概率$p$的二项分布随机变量，那么$E(X) = n·p$，$ σ^2 = n·p·(1 - p)$</p><h3 id="正态分布-Normal-Distribution"><a href="#正态分布-Normal-Distribution" class="headerlink" title="正态分布 Normal Distribution"></a>正态分布 Normal Distribution</h3><p>如果n非常大，二项分布可以近似为<strong>正态分布normal distributions</strong>（又称<strong>高斯分布 Gaussian distributions</strong>），其均值$µ= n·p$，方差$σ^2 = n·p·(1 - p)$。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210419010801.png" alt="正态分布"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>条件概率$P(A |b)$，独立性$A⊥B$</li><li>贝叶斯公式，总概率</li><li>随机变量$X$</li><li>期望值$E (X)$</li><li>均值$µ$，$CDF$，标准差$σ$，方差$σ^2$</li></ul><blockquote><p><strong>参考资料</strong></p><p>Textbook (R &amp; W) - Ch. 9, Sec. 9.1-9.4</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9020 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 离散数学 </tag>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学课程笔记（8）</title>
      <link href="/2021/04/18/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-8/"/>
      <url>/2021/04/18/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-8/</url>
      
        <content type="html"><![CDATA[<h2 id="统计与概率-Counting-and-Probability"><a href="#统计与概率-Counting-and-Probability" class="headerlink" title="统计与概率 Counting and Probability"></a>统计与概率 Counting and Probability</h2><h3 id="计算技术"><a href="#计算技术" class="headerlink" title="计算技术"></a>计算技术</h3><p>总体思路：从一些基本集合，以一种结构化的方式寻找方法、算法或精确公式来计算不同集合或派生集合中的元素数量。</p><h3 id="基本统计规则"><a href="#基本统计规则" class="headerlink" title="基本统计规则"></a>基本统计规则</h3><p><strong>结合律</strong> <em>Union rule</em>：<br>对不相交的$S$和$T$，有</p><script type="math/tex; mode=display">|S\cup T| = |S| + |T|</script><p>若$S_1,S_2,\dots S_n$两两不相交，则</p><script type="math/tex; mode=display">|S_1 \cup \dots \cup S_n| = \sum|S_i|</script><p><strong>乘积率</strong> <em>Product rule</em>：</p><script type="math/tex; mode=display">|S_1 \times \dots \times S_k| = |S_1| \cdot |S_2| \cdots |S_k| = \prod _{i=1}^{k}|S_i|</script><p>如果所有的$S_i=S$，且$|S|=m$，那么$|S^k|=m^k$</p><p>对于有限函数$S\rightarrow T$，可能的组合数为$|T|^{|S|}$</p><p>对于有n个点的完全图:</p><ul><li>长度为3的路径数量为 $n\cdot (n-1)^3$</li><li>长度为3，各点不同的路径数量为 $n(n-1)(n-2)(n-3)$</li><li>长度为3，各边不同的路径数量为 $n(n-1)(n-2)^2$</li></ul><h4 id="容斥定理-Inclusion-Exclusion"><a href="#容斥定理-Inclusion-Exclusion" class="headerlink" title="容斥定理 Inclusion-Exclusion"></a>容斥定理 Inclusion-Exclusion</h4><p>两个集合：</p><script type="math/tex; mode=display">|A\cup B| = |A| + |B| - |A\cap B|</script><p>三个集合：</p><script type="math/tex; mode=display">|A \cup B \cup C | = |A| + |B| + |C| - |A \cap B| - |A\cap C| - |B \cap C| + |A \cap B \cap C |</script><p>注：</p><p>容斥定理通常是非正式的应用，没有明确或明确地说明为什么要减去或放回某些数量。</p><p>推论：<br>如果 $|S\cup T|=|S| + |T|$，那么 $S$ 和 $T$ 不相交<br>如果 $|\cup_{i=1}^{n}S_i|=\sum_{i=1}^n|S_i|$，那么 $S_i$ 互不相交<br>如果 $|T\setminus S|=|T|-|S|$，那么 $S\subseteq T$</p><p><strong>排列</strong> <em>Permutations</em><br>n个元素的全排列数为：</p><script type="math/tex; mode=display">n! = n \cdot (n-1)\cdots 1, 0!=1!=!</script><p><strong>r-排列</strong> <em>r-permutations</em><br>n个元素中r个元素的排列数为：</p><script type="math/tex; mode=display">\Pi(n,r)=n\cdot (n-1)\cdots (n-r+1)=\frac{n!}{(n-r)!}</script><p><strong>r-组合</strong> <em>r-combinations</em></p><script type="math/tex; mode=display">\left( \begin{array}{} n \\ r \end{array} \right) = \frac{n!}{(n-r)!r!}=\frac{n\cdot (n-1)\cdots (n-r+1)}{1\cdot 2 \cdots r}</script><p>注：</p><p>这些数字通常被称为二项式系数，因为：</p><script type="math/tex; mode=display">(a+b)^n = a^n + \left(\begin{array}{} n \\ 1 \end{array}\right) a^{n-1}b + \left( \begin{array}{} n \\ 2 \end{array} \right) a ^{n-2}b^2 + \dots + b^n = \sum_{i=0}^{n}\left( \begin{array}{} n \\ i \end{array} \right)a^{n-i}b^i</script><p>在实数领域$\alpha \in \mathbb{R}$，有</p><script type="math/tex; mode=display">\left( \begin{array}{} \alpha \\ r \end{array} \right) = \frac{\alpha\cdot (\alpha-1)\cdots (\alpha-r+1)}{ r!}</script><h3 id="计数扑克牌型-Poker-Hands"><a href="#计数扑克牌型-Poker-Hands" class="headerlink" title="计数扑克牌型 Poker Hands"></a>计数扑克牌型 Poker Hands</h3><p>52张扑克牌可为：$\{A, 2-10, J, Q, K\} \times \{\textcolor{black}{\spadesuit} \text{spade},\textcolor{red}{\heartsuit}  \text{heart}, \textcolor{black}{\clubsuit} \text{club},\textcolor{red}{\diamondsuit} \text{diamond} \} $ </p><p>“4 of a kind” 4张相同<br>“flushes” 同花<br>“straight” 顺</p><h3 id="基本概率-Elementary-Probability"><a href="#基本概率-Elementary-Probability" class="headerlink" title="基本概率 Elementary Probability"></a>基本概率 Elementary Probability</h3><p>样本空间：</p><script type="math/tex; mode=display">\Omega = \{ \omega_1, \dots, \omega_n \}</script><p>当每一种可能性概率相同时，即$P(\omega_i)=\frac{1}{n}$</p><p>这被称为$Ω$上的<strong>均匀概率分布</strong> <em>uniform probability distribution</em></p><p>对于<strong>非均匀概率</strong> <em>Non-uniform Probability</em><br>令$P(\omega_1)=p_1, P(\omega_2)=p_2, \dots, P(\omega_n)=p_n$<br>那么，</p><script type="math/tex; mode=display">\sum_{i=1}^{n}p_i=1</script><h3 id="事件-Events"><a href="#事件-Events" class="headerlink" title="事件 Events"></a>事件 Events</h3><p><strong>事件</strong> <em>Event</em> -结果集合= $Ω$的子集</p><script type="math/tex; mode=display">P(E)=\sum_{\omega \in E}P(\omega)</script><p>一般有$P(\emptyset)=0, P(\Omega)=1, P(E^C)=1-P(E)$</p><h3 id="递归在概率计算中的应用"><a href="#递归在概率计算中的应用" class="headerlink" title="递归在概率计算中的应用"></a>递归在概率计算中的应用</h3><p>给定n次抛硬币，连续两次正面朝上的概率是多少?计算n = 5, 10, 20，…</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>统计 Counting<ul><li>结合律，乘积律，$n!, \Pi(n,r) \left( \begin{array}{} n \\ r \end{array} \right)$</li><li>容斥原理 inclusion-exclusion principle</li></ul></li><li>概率 Probability<ul><li>事件Event</li><li>容斥 inclusion-exclusion</li><li>递归 recursion</li></ul></li></ul><blockquote><p><strong>参考资料</strong></p><p>Textbook (R &amp; W) - Ch. 5, Sec. 5.1-5.3</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9020 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 离散数学 </tag>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python自定义错误</title>
      <link href="/2021/04/17/ji-zhu-xue-xi/python/python-zi-ding-yi-cuo-wu/"/>
      <url>/2021/04/17/ji-zhu-xue-xi/python/python-zi-ding-yi-cuo-wu/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class CustomizeError(BaseException):    def __init__(self, msg):        self.msg = msg    def __str__(self):        return self.msgtry:    raise CustomizeError('错误类型')except CustomizeError as e:    print(e)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>本文参考链接</strong></p><p>python 自定义错误处理<br><a href="https://www.cnblogs.com/zjj1990/p/12924649.html">https://www.cnblogs.com/zjj1990/p/12924649.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 已完稿 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中yield及itertools用法</title>
      <link href="/2021/04/17/ji-zhu-xue-xi/python/python-zhong-yield-ji-itertools-yong-fa/"/>
      <url>/2021/04/17/ji-zhu-xue-xi/python/python-zhong-yield-ji-itertools-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>在函数中，功能类似于return</p><p>但是函数一旦包含yield，就是一个生成器了</p><p>其定义方法为</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def foo():    print("starting...")    while True:        res = yield 4        print("res:",res)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其使用方法为：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">g = foo()print(next(g))    # 调用生成器时，不传入参数print(g.send(7))  # 调用生成器时，传入参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用生成器的一个好处是，其可以有效减小在生成列表时，内存空间的占用</p><h2 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h2><h3 id="引用方法"><a href="#引用方法" class="headerlink" title="引用方法"></a>引用方法</h3><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from itertools import * # 或import itertools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="itertools-izip-iterables"><a href="#itertools-izip-iterables" class="headerlink" title="itertools.izip(*iterables)"></a>itertools.izip(*iterables)</h3><p>功能类似于zip，但速度更快，作用是将两个相同长度的集合合并成对.</p><p>创建一个迭代器，生成元组(i1, i2, … iN)，其中i1，i2 … iN 分别来自迭代器iter1，iter2 … iterN，只要提供的某个迭代器不再生成值，迭代就会停止，此函数生成的值与内置的zip()函数相同。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">a = [1,2,3,4]b = [2,2,2,2]c = zip(a,b)&gt;&gt; c = [(1,2),(2,2),(3,2),(4,2)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="itertools-izip-longest-iterables-fillvalue"><a href="#itertools-izip-longest-iterables-fillvalue" class="headerlink" title="itertools.izip_longest(*iterables[, fillvalue])"></a>itertools.izip_longest(*iterables[, fillvalue])</h3><p>与izip()相同，但是迭代过程会持续到所有输入迭代变量iter1,iter2等都耗尽为止，如果没有使用fillvalue关键字参数指定不同的值，则使用None来填充已经使用的迭代变量的值。</p><h3 id="itertools-count-start-0-step-1"><a href="#itertools-count-start-0-step-1" class="headerlink" title="itertools.count(start=0, step=1)"></a>itertools.count(start=0, step=1)</h3><p>创建一个迭代器，生成从n开始的连续整数，如果忽略n，则从0开始计算</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">for i in izip(count(1), ['a', 'b', 'c']):    print i&gt;&gt;&gt;(1, 'a')(2, 'b')(3, 'c')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="itertools-cycle-iterables"><a href="#itertools-cycle-iterables" class="headerlink" title="itertools.cycle(*iterables)"></a>itertools.cycle(*iterables)</h3><p>无限迭代iterables中的内容</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">cycle('ABCD') --&gt; A B C D A B C D <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="itertools-repeat-object-times"><a href="#itertools-repeat-object-times" class="headerlink" title="itertools.repeat(object[, times])"></a>itertools.repeat(object[, times])</h3><p>创建一个迭代器，重复生成object，times（如果已提供）指定重复计数，如果未提供times，将无止尽返回该对象。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">for i in repeat('over-and-over', 3):    print i    &gt;&gt;&gt;over-and-overover-and-overover-and-over<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="itertools-chain-iterables"><a href="#itertools-chain-iterables" class="headerlink" title="itertools.chain(*iterables)"></a>itertools.chain(*iterables)</h3><p>将多个迭代器作为参数, 但只返回单个迭代器, 它产生所有参数迭代器的内容, 就好像他们是来自于一个单一的序列。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">for i in chain([1, 2, 3], ['a', 'b', 'c']):    print i    &gt;&gt;&gt;123abc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="itertools-compress-data-selectors"><a href="#itertools-compress-data-selectors" class="headerlink" title="itertools.compress(data, selectors)"></a>itertools.compress(data, selectors)</h3><p>提供一个选择列表，对原始数据进行筛选</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def should_drop(x):    print 'Testing:', x    return (x&lt;1)for i in dropwhile(should_drop, [ -1, 0, 1, 2, 3, 4, 1, -2 ]):    print 'Yielding:', i    &gt;&gt;&gt;Testing: -1Testing: 0Testing: 1Yielding: 1Yielding: 2Yielding: 3Yielding: 4Yielding: 1Yielding: -2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="itertools-groupby-iterable-key"><a href="#itertools-groupby-iterable-key" class="headerlink" title="itertools.groupby(iterable[, key])"></a>itertools.groupby(iterable[, key])</h3><p>返回一个产生按照key进行分组后的值集合的迭代器.</p><p>如果iterable在多次连续迭代中生成了同一项，则会定义一个组，如果将此函数应用一个分类列表，那么分组将定义该列表中的所有唯一项，key（如果已提供）是一个函数，应用于每一项，如果此函数存在返回值，该值将用于后续项而不是该项本身进行比较，此函数返回的迭代器生成元素(key, group)，其中key是分组的键值，group是迭代器，生成组成该组的所有项。</p><p>即：按照keyfunc函数对序列每个元素执行后的结果分组(每个分组是一个迭代器), 返回这些分组的迭代器</p><h3 id="itertools-ifilter-predicate-iterable"><a href="#itertools-ifilter-predicate-iterable" class="headerlink" title="itertools.ifilter(predicate, iterable)"></a>itertools.ifilter(predicate, iterable)</h3><p>返回的是迭代器类似于针对列表的内置函数 filter() , 它只包括当测试函数返回true时的项. 它不同于 dropwhile()</p><p>创建一个迭代器，仅生成iterable中predicate(item)为True的项，如果predicate为None，将返回iterable中所有计算为True的项</p><h3 id="itertools-ifilterfalse-predicate-iterable"><a href="#itertools-ifilterfalse-predicate-iterable" class="headerlink" title="itertools.ifilterfalse(predicate, iterable)"></a>itertools.ifilterfalse(predicate, iterable)</h3><p>和ifilter(函数相反 ， 返回一个包含那些测试函数返回false的项的迭代器)</p><p>创建一个迭代器，仅生成iterable中predicate(item)为False的项，如果predicate为None，则返回iterable中所有计算为False的项 对函数func执行返回假的元素的迭代器</p><h3 id="itertools-islice-iterable-stop"><a href="#itertools-islice-iterable-stop" class="headerlink" title="itertools.islice(iterable, stop)"></a>itertools.islice(iterable, stop)</h3><h3 id="itertools-islice-iterable-start-stop-step"><a href="#itertools-islice-iterable-start-stop-step" class="headerlink" title="itertools.islice(iterable, start, stop[, step])"></a>itertools.islice(iterable, start, stop[, step])</h3><p>返回的迭代器是返回了输入迭代器根据索引来选取的项</p><p>创建一个迭代器，生成项的方式类似于切片返回值： iterable[start : stop : step]，将跳过前start个项，迭代在stop所指定的位置停止，step指定用于跳过项的步幅。 与切片不同，负值不会用于任何start，stop和step， 如果省略了start，迭代将从0开始，如果省略了step，步幅将采用1.</p><p>返回序列seq的从start开始到stop结束的步长为step的元素的迭代器</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">print 'Stop at 5:'for i in islice(count(), 3):    print iprint 'Start at 5, Stop at 10:'for i in islice(count(), 5, 8):    print iprint 'By tens to 100:'for i in islice(count(), 0, 50, 10):    print iStop at 3:012Start at 5, Stop at 8:567By tens to 50:010203040<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="itertools-imap-function-iterables"><a href="#itertools-imap-function-iterables" class="headerlink" title="itertools.imap(function, *iterables)"></a>itertools.imap(function, *iterables)</h3><p>创建一个迭代器，生成项function(i1, i2, …, iN)，其中i1，i2…iN分别来自迭代器iter1，iter2 … iterN，如果function为None，则返回(i1, i2, …, iN)形式的元组，只要提供的一个迭代器不再生成值，迭代就会停止。</p><p>即：返回一个迭代器, 它是调用了一个其值在输入迭代器上的函数, 返回结果. 它类似于内置函数 map() , 只是前者在任意输入迭代器结束后就停止(而不是插入None值来补全所有的输入).</p><p>返回序列每个元素被func执行后返回值的序列的迭代器</p><h3 id="itertools-starmap-function-iterable"><a href="#itertools-starmap-function-iterable" class="headerlink" title="itertools.starmap(function, iterable)"></a>itertools.starmap(function, iterable)</h3><p>创建一个迭代器，生成值func(*item),其中item来自iterable，只有当iterable生成的项适用于这种调用函数的方式时，此函数才有效。</p><p>对序列seq的每个元素作为func的参数列表执行, 返回执行结果的迭代器</p><h3 id="itertools-tee-iterable-n-2"><a href="#itertools-tee-iterable-n-2" class="headerlink" title="itertools.tee(iterable[, n=2])"></a>itertools.tee(iterable[, n=2])</h3><p>返回一些基于单个原始输入的独立迭代器(默认为2). 它和Unix上的tee工具有点语义相似, 也就是说它们都重复读取输入设备中的值并将值写入到一个命名文件和标准输出中</p><p>从iterable创建n个独立的迭代器，创建的迭代器以n元组的形式返回，n的默认值为2，此函数适用于任何可迭代的对象，但是，为了克隆原始迭代器，生成的项会被缓存，并在所有新创建的迭代器中使用，一定要注意，不要在调用tee()之后使用原始迭代器iterable，否则缓存机制可能无法正确工作。</p><p>把一个迭代器分为n个迭代器, 返回一个元组.默认是两个</p><h3 id="itertools-takewhile-predicate-iterable"><a href="#itertools-takewhile-predicate-iterable" class="headerlink" title="itertools.takewhile(predicate, iterable)"></a>itertools.takewhile(predicate, iterable)</h3><p>和dropwhile相反</p><p>创建一个迭代器，生成iterable中predicate(item)为True的项，只要predicate计算为False，迭代就会立即停止。</p><p>即：从序列的头开始, 直到执行函数func失败.</p><h3 id="itertools-product-iterables-repeat"><a href="#itertools-product-iterables-repeat" class="headerlink" title="itertools.product(*iterables[, repeat])"></a>itertools.product(*iterables[, repeat])</h3><p>笛卡尔积</p><p>创建一个迭代器，生成表示item1，item2等中的项目的笛卡尔积的元组，repeat是一个关键字参数，指定重复生成序列的次数。</p><h3 id="itertools-permutations-iterable-r"><a href="#itertools-permutations-iterable-r" class="headerlink" title="itertools.permutations(iterable[, r])"></a>itertools.permutations(iterable[, r])</h3><p>排列</p><p>创建一个迭代器，返回iterable中所有长度为r的项目序列，如果省略了r，那么序列的长度与iterable中的项目数量相同： 返回p中任意取r个元素做排列的元组的迭代器</p><h3 id="itertools-combinations-iterable-r"><a href="#itertools-combinations-iterable-r" class="headerlink" title="itertools.combinations(iterable, r)"></a>itertools.combinations(iterable, r)</h3><p>创建一个迭代器，返回iterable中所有长度为r的子序列，返回的子序列中的项按输入iterable中的顺序排序 (不带重复)</p><h3 id="itertools-combinations-with-replacement-iterable-r"><a href="#itertools-combinations-with-replacement-iterable-r" class="headerlink" title="itertools.combinations_with_replacement(iterable, r)"></a>itertools.combinations_with_replacement(iterable, r)</h3><p>创建一个迭代器，返回iterable中所有长度为r的子序列，返回的子序列中的项按输入iterable中的顺序排序 (带重复)</p><blockquote><p><strong>本文参考链接</strong></p><p>官方itertools<br><a href="https://docs.python.org/2/library/itertools.html">https://docs.python.org/2/library/itertools.html</a></p><p>python中yield的用法详解——最简单，最清晰的解释<br><a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856/">https://blog.csdn.net/mieleizhi0522/article/details/82142856/</a></p><p>Python - zip和izip函数 以及 位置参数和命名参数的运用<br><a href="https://blog.csdn.net/qq_33704653/article/details/79920339">https://blog.csdn.net/qq_33704653/article/details/79920339</a></p><p>Python itertools模块详解<br><a href="https://blog.csdn.net/u011089523/article/details/51384255">https://blog.csdn.net/u011089523/article/details/51384255</a><br>1<br>1<br>1<br>1</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 已完稿 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我活着是为了什么？</title>
      <link href="/2021/04/17/sheng-huo-ji-shi/wo-huo-zhao-shi-wei-liao-shi-me/"/>
      <url>/2021/04/17/sheng-huo-ji-shi/wo-huo-zhao-shi-wei-liao-shi-me/</url>
      
        <content type="html"><![CDATA[<h2 id="我的人生理想"><a href="#我的人生理想" class="headerlink" title="我的人生理想"></a>我的人生理想</h2><h3 id="物质生活：宜居城市，现代小楼，有可以长途旅行的汽车，生活富足而平静"><a href="#物质生活：宜居城市，现代小楼，有可以长途旅行的汽车，生活富足而平静" class="headerlink" title="物质生活：宜居城市，现代小楼，有可以长途旅行的汽车，生活富足而平静"></a>物质生活：宜居城市，现代小楼，有可以长途旅行的汽车，生活富足而平静</h3><p>有房，二三层小楼，房前有一个小院子，可以种一些花草</p><p>屋子装修比较现代，干净</p><p>有车</p><p>生活平静，城市安稳发达，气候温和，绿化及空气好</p><p>上班通勤40分钟之内</p><h3 id="精神生活：时间平衡，知识丰富，生活惬意且有趣"><a href="#精神生活：时间平衡，知识丰富，生活惬意且有趣" class="headerlink" title="精神生活：时间平衡，知识丰富，生活惬意且有趣"></a>精神生活：时间平衡，知识丰富，生活惬意且有趣</h3><p>工作与生活时间平衡，有自己的时间</p><p>了解更多自然、科学、人文、历史知识，了解更多有趣好玩的事</p><p>生活状态充实、健康，惬意，富足，有乐趣</p><p>有一本日志册，记录着自己过往生活的点点滴滴，回首往事却又不沉醉于往事</p><h3 id="心性：自信乐观，心态年轻，平和不焦虑，享受当下生活"><a href="#心性：自信乐观，心态年轻，平和不焦虑，享受当下生活" class="headerlink" title="心性：自信乐观，心态年轻，平和不焦虑，享受当下生活"></a>心性：自信乐观，心态年轻，平和不焦虑，享受当下生活</h3><p>磨砺心性：自信、乐观、积极、平和、高情商，处变不惊，保持年轻的心态，懂得人情世故，却又不世故</p><p>有平和心，钝感力，不过分为未来的事情担心和焦虑，可以平静的享受当下的生活</p><p>有执行力，有行动力，精力充沛</p><h3 id="人际：志同道合，氛围融洽"><a href="#人际：志同道合，氛围融洽" class="headerlink" title="人际：志同道合，氛围融洽"></a>人际：志同道合，氛围融洽</h3><p>有几个聊得来，志同道合的朋友</p><p>有几个可以一起出来玩的朋友</p><p>和领导、同事相处愉快</p><p>有几个朋友可以吃饭聊天，相处融洽</p><p>会和他人合作完成任务</p><h3 id="娱乐：兴趣广泛，有影视与游戏相伴，旅行与美食不可辜负"><a href="#娱乐：兴趣广泛，有影视与游戏相伴，旅行与美食不可辜负" class="headerlink" title="娱乐：兴趣广泛，有影视与游戏相伴，旅行与美食不可辜负"></a>娱乐：兴趣广泛，有影视与游戏相伴，旅行与美食不可辜负</h3><p>品尝世界各地美食</p><p>可以和男友双人自驾游</p><p>可以看时下流行的和经典的影视剧</p><p>每年有1次7天以上的出国旅行，看世界各地自然风光，体验风土人情</p><p>平时可以去家附近郊游</p><p>有时间可以专心的玩喜欢的游戏</p><p>有更多兴趣爱好</p><h3 id="事业：领域专家，受人尊敬，收入中上，小有所成"><a href="#事业：领域专家，受人尊敬，收入中上，小有所成" class="headerlink" title="事业：领域专家，受人尊敬，收入中上，小有所成"></a>事业：领域专家，受人尊敬，收入中上，小有所成</h3><p>经济独立，工作稳定，收入较好，中等之上</p><p>成为一个领域的专家，技术大牛，受人尊敬，处理工作内容游刃有余不需要特别多的钱，但要足够支撑日常的生活</p><h3 id="技能：读书、外语、乐器、声乐、美食、穿着皆略知一二"><a href="#技能：读书、外语、乐器、声乐、美食、穿着皆略知一二" class="headerlink" title="技能：读书、外语、乐器、声乐、美食、穿着皆略知一二"></a>技能：读书、外语、乐器、声乐、美食、穿着皆略知一二</h3><p>有时间读书，提升自己</p><p>英语流利</p><p>熟练掌握几种乐器，比如电子琴</p><p>参加合唱团等集体活动</p><p>自己会做很多美食</p><p>会穿衣打扮，自然帅气</p><h3 id="情感：深爱且忠诚，共同生活，相互扶持，心灵相伴"><a href="#情感：深爱且忠诚，共同生活，相互扶持，心灵相伴" class="headerlink" title="情感：深爱且忠诚，共同生活，相互扶持，心灵相伴"></a>情感：深爱且忠诚，共同生活，相互扶持，心灵相伴</h3><p>有一个深爱的爱人，我很爱他，他很爱我，我们互相关心、支持、鼓励</p><p>他的年龄比我小一些，小10岁之内都可以</p><p>他乐观，积极，有趣，有主见，懂得照顾我的情绪</p><p>他性情温和，忠于爱情，谦逊，却不软弱，不失男子气概</p><p>他喜欢运动，阳光，帅气，身高180左右</p><p>我和他的性生活和谐</p><p>和他在一起很开心，舒适，可以轻松的做自己</p><p>和他生活在一起，每天晚上可以抱着他睡觉</p><p>我的付出能够得到他的肯定</p><p>喜欢我做的美食，我做的饭能够给他带来喜悦</p><p>和他在一起时能做很多有趣的事</p><h3 id="家庭：父母健康，有孩子与宠物"><a href="#家庭：父母健康，有孩子与宠物" class="headerlink" title="家庭：父母健康，有孩子与宠物"></a>家庭：父母健康，有孩子与宠物</h3><p>我父母身体健康</p><p>我有自己的孩子，最好是男孩</p><p>家里有宠物，有猫有狗</p><p>陪父母去外边旅游，对父母多尽尽孝道</p><h4 id="健康：身体健康无顽疾，穿衣显瘦，脱衣有肉"><a href="#健康：身体健康无顽疾，穿衣显瘦，脱衣有肉" class="headerlink" title="健康：身体健康无顽疾，穿衣显瘦，脱衣有肉"></a>健康：身体健康无顽疾，穿衣显瘦，脱衣有肉</h4><p>身体健康，无重大疾病</p><p>身形好看，有一些肌肉，没有赘肉</p><p>能坚持长跑</p><h3 id="老年生活：健康依旧，爱人常在，膝下有福，安度晚年"><a href="#老年生活：健康依旧，爱人常在，膝下有福，安度晚年" class="headerlink" title="老年生活：健康依旧，爱人常在，膝下有福，安度晚年"></a>老年生活：健康依旧，爱人常在，膝下有福，安度晚年</h3><p>老年时身体依然健康</p><p>还可以和老公一起生活在自己家里</p><p>孩子大了，能时常回来看看我们</p><p>不依靠轮椅和药物生活</p><p>每天在家看看花，弄弄草，摆弄几下乐器</p><p>和几个朋友一起在外聊天娱乐</p><p>没有负债</p><p>自己的生活不拖累别人</p><h2 id="和这个世界愉快的相处"><a href="#和这个世界愉快的相处" class="headerlink" title="和这个世界愉快的相处"></a>和这个世界愉快的相处</h2><p>墓志铭：他喜欢这个世界并全身心投入其中，他没有在这个世界上白走一遭，他生活过得很幸福。</p>]]></content>
      
      
      <categories>
          
          <category> 生活纪实 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理财训练营（1）</title>
      <link href="/2021/04/15/ke-cheng-bi-ji/li-cai-xun-lian-ying-1/"/>
      <url>/2021/04/15/ke-cheng-bi-ji/li-cai-xun-lian-ying-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 本学习笔记根据某投学堂提供资料整理学习</p></blockquote><h2 id="什么是某投学堂"><a href="#什么是某投学堂" class="headerlink" title="什么是某投学堂"></a>什么是某投学堂</h2><p>一家能让零基础想学理财的人轻松学习理财的公司。</p><p>2011年成立，至今已10年。</p><h2 id="某狗钱钱"><a href="#某狗钱钱" class="headerlink" title="某狗钱钱"></a>某狗钱钱</h2><h3 id="第一节：想变得有钱，这3个建议可以帮你"><a href="#第一节：想变得有钱，这3个建议可以帮你" class="headerlink" title="第一节：想变得有钱，这3个建议可以帮你"></a>第一节：想变得有钱，这3个建议可以帮你</h3><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ol><li><p>为什么要学习理财</p></li><li><p>小狗钱钱的3个建议</p></li><li><p>不要试试看，要去做</p></li></ol><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p><strong>钱不是万能的，但是如果缺钱的话，钱就会变得格外的重要</strong></p><p>你努力赚钱是为了可以追求钱以外的重要东西，而如果你不努力赚钱，对不起，你们家就会陷入到钱的困扰里面来，钱呢，就会占据你生命中的大部分。</p><p>故事的小主人的3个愿望：</p><ol><li><p>要当交换生去美国学习；</p></li><li><p>要一台笔记本电脑；</p></li><li><p>要帮爸爸妈妈偿还债务。</p></li></ol><p>成功的人之所成功，<strong>因为他们一直梦想着有成功的那天，</strong>不停地想着他们成功后的情景，强烈的欲望会推动你走向成功，这是“视觉化”的作用。</p><p><strong>面对任何一件事情，你只有两个选择，那就是“做”或者“不做”。</strong></p><p>而不能说“试试吧”。如果你每次只是抱着“试试看”心态，那么最后只会以失败而告终。“试试看”其实就是一个借口，是自己为自己失败提前预设的一个理由。因此，从现在开始，无论任何事情，不要试验，只选择：做或者不做。只要选择了做，就用尽全力，直到成功。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>3个实现梦想的方法：<strong>写3个愿望，准备梦想相册、准备梦想储蓄罐。</strong></p><h4 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h4><p>说实话，本身就抱着试试看的心态报名的这个课程。找着接口说白天要上班，晚上要学习，没有时间看这个课程。结果今天终于起身着手开始做这件事，发现第一课就惊艳到了我。这个故事难道不也正说的我吗？我总是说着试试吧之类的话，却总不拼尽全力做事；工作也总是得过且过，最后吃亏的只有自己。从今天，从此刻开始，必须行动起来了！</p><h3 id="第二节：赚钱，没你想得那么难"><a href="#第二节：赚钱，没你想得那么难" class="headerlink" title="第二节：赚钱，没你想得那么难"></a>第二节：赚钱，没你想得那么难</h3><h4 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a><strong>知识点</strong></h4><ol><li><p>坚持写成功日记</p></li><li><p>赚钱的要点是：第一，别人需要什么？第二，我能做什么？</p></li></ol><h4 id="正文-1"><a href="#正文-1" class="headerlink" title="正文"></a>正文</h4><p>你可以为你的梦想赚钱啊，而能不能赚到钱，并不取决于你有没有好的点子，更不取决于你有多聪明，而在于你有没有自信，只要你相信自己，就一定能赚到钱。</p><p><strong>该如何树立自己的自信呢？</strong></p><p>方法很简单：<strong>像富人一样写“成功日记”</strong>——把自己做的成功的事情都记录进去，任何小事都可以。</p><p>你想赚钱吗？我给你两个建议：</p><p>第一，为别人解决问题；</p><p>第二，把精力放在你知道的事情和能够做的事情上。</p><p>巴菲特在5岁时，已经学会每天自己坐公交送报纸了。</p><p>想挣钱当然是好事，可是<strong>你花了多少时间思考该怎么挣钱呢？你喜欢什么，你擅长什么呢？</strong></p><p>觉得钱难赚的人，我觉得大概可以总结为2类人：</p><p><strong>第一类是：没有认真思考；</strong></p><p><strong>第二类是：不愿面对困难。</strong></p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>增加自信的方法就是写成功日记；赚钱的两个方法是，别人需要什么？我能做什么？</p><h4 id="读后感-1"><a href="#读后感-1" class="headerlink" title="读后感"></a>读后感</h4><p>文章内容同样精彩。我就是这样，觉得现在已经赚得足够了，为什么还要再那么努力呢？平平淡淡的多好啊！可是，我还是羡慕那些更加财富自由的人，能够有更高的社会地位，能够有过更加富足的生活。同样的，我一直都不是特别有自信的人，我觉得文章提供的方法很好，我从今天开始，每天都记录一点，自己当天成功完成的事。我相信，这是培养自己自信的一种很好的方式。</p><h3 id="第三节：99-的人不成功，都是因为它"><a href="#第三节：99-的人不成功，都是因为它" class="headerlink" title="第三节：99%的人不成功，都是因为它"></a>第三节：99%的人不成功，都是因为它</h3><h4 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h4><ol><li><p>无论什么时候，都要坚持自己的想法，尤其是困难时期；</p></li><li><p>每天不间断做重要不紧急的事情；</p></li><li><p>决定要做一件事情的时候，就立刻去做，不要犹豫。</p></li></ol><h4 id="正文-2"><a href="#正文-2" class="headerlink" title="正文"></a>正文</h4><p>人往往在顺境中趁胜追击，而在逆境中就会消沉。</p><p>首先从体力上改善自己，比如每天坚持午休和锻炼；其次，从精神状态上进行改善，比如即使生病中也可以给自己加油打气，坚持做一些力所能及的工作。</p><p><strong>当你决定做一件事的时候，你必须在72小时之内完成它，否则你很可能永远不会再做了。</strong>总之就是要立即去做，不要有太多顾虑。</p><p>很多人害怕决定太快会带来不好的结果，但事实上呢，反复犹豫反而错失许多机遇。立即下决心去做，可能会做错，但更多是为下一次成功积累了经验。</p><p>如果总想着“<strong>等我有时间再做或等条件成熟再做”，90%的可能是一直都不会去做了</strong>。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>三条原则</p><h4 id="读后感-2"><a href="#读后感-2" class="headerlink" title="读后感"></a>读后感</h4><p>又给自己重重的上了一课。我觉得对我来说，最重要的就是第三点，不要犹豫，立刻去做。因为我发现，我有好多好多想做的事，结果因为一个犹豫，没计划好，害怕失败。。各种各样的原因，把时间都蹉跎了，却始终没有把自己的愿望提上日程。时间不等人，我得继续加油啊！</p><h3 id="第四节：不要杀死你的鹅"><a href="#第四节：不要杀死你的鹅" class="headerlink" title="第四节：不要杀死你的鹅"></a>第四节：不要杀死你的鹅</h3><h4 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h4><ol><li><p>永远不要杀死你的鹅；</p></li><li><p>对于负债的人4条建议。</p></li></ol><h4 id="正文-3"><a href="#正文-3" class="headerlink" title="正文"></a>正文</h4><p>寓言故事：一个人发现自己的鹅可以下金蛋，直到贪婪到一刀把鹅劈成两半，最终却什么都没得到。</p><p>对负债人的建议：</p><ol><li><p>应当扔掉所有信用卡：因为使用信用卡时，总比使用现金要花的多；</p></li><li><p>尽可能少的偿还贷款；</p></li><li><p>对于消费贷款，欠债的人应该将不用于生活的钱存起来一半，另一半用于还债；</p></li><li><p>对于所有的消费，都要问一问自己“这真的有必要吗？将物品划分成必要、需要和想要三个级别。</p></li></ol><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>保留本金，赚利息。对负债人的建议。</p><h4 id="读后感-3"><a href="#读后感-3" class="headerlink" title="读后感"></a>读后感</h4><p>学习这堂课，让我想到最多的就是我的本金如何变成利息。对于负债，除了房贷，我没有更多的债务，所以暂时还不需要考虑更多。当然，我仍然认为文章给出的几点建议是值得考虑的，是合理的建议。</p><h3 id="第五节：投资，遵循这3个原则就足够了"><a href="#第五节：投资，遵循这3个原则就足够了" class="headerlink" title="第五节：投资，遵循这3个原则就足够了"></a>第五节：投资，遵循这3个原则就足够了</h3><h4 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h4><ol><li><p>现金很重要，可以来应对突发状况；</p></li><li><p>富人思维&amp;穷人思维</p></li><li><p>投资三原则</p></li></ol><h4 id="正文-4"><a href="#正文-4" class="headerlink" title="正文"></a>正文</h4><p><strong>投资之前一定要做好资产配置</strong></p><p><strong>金钱能否带来幸福，不取决于数量，而取决于人们是否懂得怎样使用它。</strong></p><p>穷人思维就是<strong>，一旦拿到钱，首先就本能的想到买买买，想到吃喝玩乐，想到各种奢侈享受，却忽略了投资。</strong></p><p>富人思维就截然不同了，<strong>他们也会消费一些金钱作为对自己的奖励，却会将80%甚至更多的钱分配到投资上，让它们继续为自己赚取更多的钱。</strong></p><p><strong>投资三条准则：</strong></p><p>第一条：应该把钱投资在安全的地方；</p><p>第二条：钱应该能下很多金蛋；</p><p>第三条：投资应该简单明白。</p><p><strong>不懂的就不要碰</strong>。</p><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>投资要安全，要有收益，要充分了解投资对象</p><h4 id="读后感-4"><a href="#读后感-4" class="headerlink" title="读后感"></a>读后感</h4><p>终于，开始准备切入真正的投资课程了。有点小激动，希望正式的课程真的能解决自己的很多顾虑和疑惑，学到有用的理财知识。</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux CentOS 综合使用技巧</title>
      <link href="/2021/04/15/zui-jia-shi-jian/linux-centos-zong-he-shi-yong-ji-qiao/"/>
      <url>/2021/04/15/zui-jia-shi-jian/linux-centos-zong-he-shi-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h2 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h2><h3 id="查询Java进程"><a href="#查询Java进程" class="headerlink" title="查询Java进程"></a>查询Java进程</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ps -ef | grep java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">jps -l     #（显示java进程的Id和软件名称）jps -lmv   #（显示java进程的Id和软件名称；显示启动main输入参数；虚拟机参数）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 最佳实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持续更新 </tag>
            
            <tag> Linux </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7操作系统配置Java</title>
      <link href="/2021/04/15/zui-jia-shi-jian/centos7-pei-zhi-java/"/>
      <url>/2021/04/15/zui-jia-shi-jian/centos7-pei-zhi-java/</url>
      
        <content type="html"><![CDATA[<p>1.从官网下载Java SDK。安装Java环境有rpm版本和使用tar.gz两种方式。比如下载文件为 jdk-16_linux-x64_bin.rpm，上传至要安装Java环境的服务器中</p><p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">Java官网下载地址</a></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210415162918.png" alt="Java官网下载列表"></p><p>2.在服务器中卸载原有 Java/JDK</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">rpm -qa | grep jdk   // 查看当前系统Java版本rpm -e [jdk版本]      // 卸载现有JDK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>3.若以rpm版本安装，则可运行以下命令，安装Java</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">rpm -ivh jdk-16_linux-x64_bin.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210415163309.png" alt="RPM安装JAVA"></p><p>4.若以tar.gz版本安装，则可运行以下命令，安装Java</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">mkdir /usr/javatar -zxvf jdk-8u161-linux-x64.tar.gz -C /usr/java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>5.设置环境变量</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">vim /etc/profile# 安装下方需要粘贴的内容修改该文件source /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell"># /etc/profile里需要粘贴的内容JAVA_HOME=/usr/java/jdk-16        # 本例中，RPM方法默认安装位置为此路径JAVA_HOME=/usr/java/jdk1.8.0_161  # 本例中，tar.gz方法安装位置为此路径CLASSPATH=%JAVA_HOME%/lib:%JAVA_HOME%/jre/libPATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/binexport PATH CLASSPATH JAVA_HOME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>6.检查Java环境</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">java -versionecho $JAVA_HOME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210416145913.png" alt="查看本地Java版本"></p><blockquote><p><strong>参考资料</strong></p><p>CentOS 7 安装 JAVA环境（JDK 1.8）<br><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a></p><p>centos7使用rpm安装jdk8<br><a href="https://blog.csdn.net/fansenjun/article/details/82256528">https://blog.csdn.net/fansenjun/article/details/82256528</a></p><p>centos rpm安装的 jdk路径在哪和配置在哪<br><a href="https://blog.csdn.net/qq_43313588/article/details/88556527">https://blog.csdn.net/qq_43313588/article/details/88556527</a></p><p>jdk下载/Linux64位 jdk1.8 jdk-8u161下载<br><a href="https://blog.csdn.net/qq_21187515/article/details/84850814/">https://blog.csdn.net/qq_21187515/article/details/84850814/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 最佳实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Java </tag>
            
            <tag> 已完稿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windown10通过Vagrant搭建CentOS7虚拟机.md</title>
      <link href="/2021/04/15/zui-jia-shi-jian/windown10-tong-guo-vagrant-da-jian-centos7-xu-ni-ji/"/>
      <url>/2021/04/15/zui-jia-shi-jian/windown10-tong-guo-vagrant-da-jian-centos7-xu-ni-ji/</url>
      
        <content type="html"><![CDATA[<ol><li><p>下载并安装Vagrant及VMBOX</p></li><li><p>下载CentOS7的Box</p></li><li><p>载入Box到系统中</p></li><li></li></ol><blockquote><p><strong>参考资料</strong></p><p>Vagrant Cloud - 官网CentOS7-box下载地址<br><a href="https://app.vagrantup.com/centos/boxes/7">https://app.vagrantup.com/centos/boxes/7</a></p><p>vagrant在windows下的使用<br><a href="https://www.cnblogs.com/xiang--liu/p/9710351.html">https://www.cnblogs.com/xiang--liu/p/9710351.html</a><br>1<br>vagrant使用三种网络配置<br><a href="https://blog.csdn.net/zc474235918/article/details/51039150">https://blog.csdn.net/zc474235918/article/details/51039150</a><br>1<br>vagrant调整内存大小<br><a href="https://blog.csdn.net/yageeart/article/details/72840763">https://blog.csdn.net/yageeart/article/details/72840763</a><br>1<br><a href="http://www.fancyecommerce.com/2017/06/06/vagrant-%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%EF%BC%8C%E5%B0%86windows%E6%96%87%E4%BB%B6%E5%A4%B9%E6%98%A0%E5%B0%84%E5%88%B0linux%E4%B8%AD/">http://www.fancyecommerce.com/2017/06/06/vagrant-%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%EF%BC%8C%E5%B0%86windows%E6%96%87%E4%BB%B6%E5%A4%B9%E6%98%A0%E5%B0%84%E5%88%B0linux%E4%B8%AD/</a><br>1<br>vagrant报unknownfilesystemtype’vboxsf’解决方<br><a href="https://blog.csdn.net/weixin_43066287/article/details/99703093">https://blog.csdn.net/weixin_43066287/article/details/99703093</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 最佳实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Windows </tag>
            
            <tag> 编辑中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在kubernetes环境搭建bistoury</title>
      <link href="/2021/04/15/ji-zhu-xue-xi/bistoury/zai-kubernetes-huan-jing-da-jian-bistoury/"/>
      <url>/2021/04/15/ji-zhu-xue-xi/bistoury/zai-kubernetes-huan-jing-da-jian-bistoury/</url>
      
        <content type="html"><![CDATA[<h2 id="Bistoury介绍"><a href="#Bistoury介绍" class="headerlink" title="Bistoury介绍"></a>Bistoury介绍</h2><p>开发者：去哪儿网</p><p>功能：从日志、内存、线程、类信息、调试、机器和系统属性等各个方面对应用进行诊断</p><p>目的：提升开发人员诊断问题的效率和能力</p><p>集成：Alibaba开源的<a href="https://github.com/alibaba/arthas">arthas</a>和唯品会开源的<a href="https://github.com/vipshop/vjtools">vjtools</a></p><h2 id="功能概览"><a href="#功能概览" class="headerlink" title="功能概览"></a>功能概览</h2><p>通过命令行界面查看日志，使用arthas和vjtools的各项功能</p><p><a href="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/console.png"><img src="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/console.png" alt="console"></a></p><p>在线debug，在线应用调试神器</p><p><a href="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/debug_panel.png"><img src="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/debug_panel.png" alt="debug"></a></p><p>线程级cpu监控，帮助你掌握线程级cpu使用率</p><p><a href="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/jstack.png"><img src="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/jstack.png" alt="jstack_dump"></a></p><p>在web界面查看JVM运行信息，以及各种其它信息</p><p><a href="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/jvm.png"><img src="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/jvm.png" alt="jvm"></a></p><p>动态给方法添加监控</p><p><a href="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/monitor.png"><img src="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/monitor.png" alt="monitor"></a></p><p>线程dump</p><p><a href="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/thread_dump.png"><img src="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/thread_dump.png" alt="thread_dump"></a></p><h2 id="Bistoury架构分析"><a href="#Bistoury架构分析" class="headerlink" title="Bistoury架构分析"></a>Bistoury架构分析</h2><p>Bistoury核心组件包含agent，proxy，ui：</p><ul><li>agent ： 与需要诊断的应用部署到一起，负责具体的诊断命令执行，通过域名连接proxy</li><li>proxy：agent的代理，agent启动时会通过ws和proxy连接注册，proxy可以部署多个，推荐使用域名负载</li><li>ui：ui提供图形化和命令行界面，接收从用户传来的命令，传递命令给proxy，接收从proxy传来的结果并展示给用户。</li></ul><p><a href="https://github.com/qunarcorp/bistoury/blob/master/docs/cn/design/design.md">Bistoury的访问流程</a></p><p><a href="https://www.jianshu.com/p/f7202e490156">Bistoury原理分析</a></p><p><a href="https://github.com/qunarcorp/bistoury/blob/master/docs/cn/quick_start.md">Bistoury快速开始</a></p><h2 id="Bistoury的快速部署"><a href="#Bistoury的快速部署" class="headerlink" title="Bistoury的快速部署"></a>Bistoury的快速部署</h2><ol><li><p>从官网下载quick_start安装包，本例下载安装包文件名称为<a href="https://github.com/qunarcorp/bistoury/releases/download/v2.0.7/bistoury-2.0.7-quick-start.tar.gz">bistoury-2.0.7-quick-start.tar.gz</a></p><p><a href="https://github.com/qunarcorp/bistoury/blob/master/docs/cn/quick_start.md">快速开始官网地址</a></p><p><a href="https://github.com/qunarcorp/bistoury/releases">最新release下载地址</a></p></li><li><p>解压安装包，并运行quick_start.sh</p></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 解压文件，并进入到对应目录中tar -zxvf bistoury-quick-start.tar.gzcd bistoury-2.0.7# 如果应用以本人用户启动，可以直接运行./quick_start.sh -p 1024(应用进程pid，自行替换) start# 如果应用以其它帐号启动，比如 tomcat，需要指定一下用户然后运行sudo -u tomcat ./quick_start.sh -p 1024(应用进程pid，自行替换) start# 停止运行./quick_start.sh stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>访问方法<br>在浏览器输入 <a href="http://ip:9091">http://ip:9091</a> 访问 UI，初始化用户名/密码为 admin/admin</li><li>官方提供的启动参数<br>| 参数名称 | 是否必填 | 默认值                                            | 说明                                                         |<br>| ———— | ———— | ————————————————————————- | —————————————————————————————— |<br>| -i       | 选填     | ip 中列表的第一个                                 | 当本机存在多个 ip 时，指定一个可用 ip                        |<br>| -j       | 选填     | 环境变量 JAVA_HOME                                | 指定 jdk 路径                                                |<br>| -l       | 选填     | /tmp                                              | 应用的日志目录，Bistoury 命令执行的目录，比如 ls，tail 等都会默认在此目录下执行 |<br>| -p       | 必填     |                                                   | 应用进程 id，因为是脚本快速启动，所以需要使用该参数指定对哪个 JAVA 进程进行诊断 |<br>| -c       | 选填     | org.springframework.web.servlet.DispatcherServlet | 用于获取一些应用信息，应填写为依赖的 jar 包中的一个已加载的类（不能使用 Bistoury agent 中用到的类，推荐使用公司内部中间件的 jar 包或 Spring 相关包中的，agent 不可能使用到的类，如org.springframework.web.servlet.DispatcherServlet） |<br>| -h       | 选填     |                                                   | 查看帮助文档                                                 |</li></ol><h2 id="Bistoury-在docker运行"><a href="#Bistoury-在docker运行" class="headerlink" title="Bistoury 在docker运行"></a>Bistoury 在docker运行</h2><p>官方的快速启动命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!/bin/bash#创建网络echo "start create network"docker network create --subnet=172.19.0.0/16 bistoury#mysql 镜像echo "start run mysql image"docker run --name mysql -p 3307:3306 -e MYSQL_ROOT_PASSWORD=root -d -i --net bistoury --ip 172.19.0.7  registry.cn-hangzhou.aliyuncs.com/bistoury/bistoury-db#zk 镜像echo "start run zk image"docker run -d -p 2181:2181 -it --net bistoury --ip 172.19.0.2 registry.cn-hangzhou.aliyuncs.com/bistoury/zk:latestsleep 30#proxy 镜像echo "start run proxy module"docker run -d -p 9880:9880 -p 9881:9881 -p 9090:9090 -i --net bistoury --ip 172.19.0.3 registry.cn-hangzhou.aliyuncs.com/bistoury/bistoury-proxy --real-ip $1 --zk-address 172.19.0.2:2181 --proxy-jdbc-url jdbc:mysql://172.19.0.7:3306/bistoury#ui 镜像echo "start run ui module"docker run -p 9091:9091  -it -d --net bistoury --ip 172.19.0.4 registry.cn-hangzhou.aliyuncs.com/bistoury/bistoury-ui --zk-address 172.19.0.2:2181 --ui-jdbc-url jdbc:mysql://172.19.0.7:3306/bistoury#boot 镜像echo "start run demo application"docker  run -it -d  -p 8686:8686 -i --net bistoury --ip 172.19.0.5 registry.cn-hangzhou.aliyuncs.com/bistoury/bistoury-demo --proxy-host $1:9090docker  run -it -d  -p 8687:8686 -i --net bistoury --ip 172.19.0.6 registry.cn-hangzhou.aliyuncs.com/bistoury/bistoury-demo --proxy-host $1:9090<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，运行时需要传入本机IP地址</p><h2 id="Bistoury-在生产环境运行"><a href="#Bistoury-在生产环境运行" class="headerlink" title="Bistoury 在生产环境运行"></a>Bistoury 在生产环境运行</h2><p>官方推荐部署方式：</p><ul><li>ui 独立部署，推荐部署在多台机器，并提供独立的域名</li><li>proxy 独立部署，推荐部署在多台机器，并提供独立的域名</li><li>agent 需要和应用部署在同一台机器上。推荐在测试环境全环境自动部署，线上环境提供单机一键部署，以及应用下所有机器一键部署</li><li>独立的应用中心，管理所有功能内部应用和机器信息，这是一个和 Bistoury 相独立的系统，Bistoury 从中拿到不断更新的应用和机器信息</li></ul><h2 id="bistoury-application-k8s-Bistoury-on-K8S"><a href="#bistoury-application-k8s-Bistoury-on-K8S" class="headerlink" title="bistoury-application-k8s(Bistoury on K8S)"></a>bistoury-application-k8s(Bistoury on K8S)</h2><blockquote><p><strong>本文参考链接</strong></p><p>bistoury官网<br><a href="https://github.com/qunarcorp/bistoury">https://github.com/qunarcorp/bistoury</a></p><p>java应用诊断和在线debug利器bistoury介绍与在K8S环境使用<br><a href="https://www.cnblogs.com/xiaoqi/p/Bistoury.html">https://www.cnblogs.com/xiaoqi/p/Bistoury.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑中 </tag>
            
            <tag> 监控技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学课程笔记（7）</title>
      <link href="/2021/04/01/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-7/"/>
      <url>/2021/04/01/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-7/</url>
      
        <content type="html"><![CDATA[<h2 id="归纳，递归，Big-Oh符号-Induction-Recursion-Big-Oh-Notation"><a href="#归纳，递归，Big-Oh符号-Induction-Recursion-Big-Oh-Notation" class="headerlink" title="归纳，递归，Big-Oh符号 Induction, Recursion, Big-Oh Notation"></a>归纳，递归，Big-Oh符号 Induction, Recursion, Big-Oh Notation</h2><h3 id="归纳推理-Inductive-Reasoning"><a href="#归纳推理-Inductive-Reasoning" class="headerlink" title="归纳推理 Inductive Reasoning"></a>归纳推理 Inductive Reasoning</h3><p>假设我们想要得出这种形式的结论：$P(x)$对于所有的$x$都属于某种类型</p><p>正如哲学中所理解的那样，归纳推理是从例子出发的。</p><p>例如：已知“这只天鹅是白色的，那只天鹅也是白色的，事实上每只天鹅都是白色的。我所见过的天鹅都是白色的。”</p><p>结论：”每只天鹅都是白色的“</p><p>注意：这对发现假说来说，确实是个好方法，但这不是一个有效的推理原则！</p><p><strong>数学归纳法</strong> <em>Mathematical induction</em> 是一种有效的变体。</p><h3 id="数学归纳法-Mathematical-Induction"><a href="#数学归纳法-Mathematical-Induction" class="headerlink" title="数学归纳法 Mathematical Induction"></a>数学归纳法 Mathematical Induction</h3><p>数学归纳法不仅基于一组例子，而且基于从已知P存在的情况中推导出新的$P(x)$情况的规则。</p><p>数学归纳法推理的一般结构：</p><p><strong>基本情况Base Case[B]</strong>：$P(a_1), P(a_2),…. P(a_n)$对于一个小的例子集$a_1…a_n$(通常 n = 1)</p><p><strong>归纳步骤 Inductive Step[I]</strong>: 如果$P(x)$在某些情况下$x = x_1,…, x_k$成立，那么以某种方式由$x_1,…,x_k$构成的$y$，$P(y)$成立。</p><p><strong>结论 Conclusion</strong>: 从$a_1…a_n$开始，并重复应用已有值构造y的方法，我们最终可以构造所有感兴趣的域内的值。</p><h3 id="关于-mathbb-N-的数学归纳-Mathematical-Induction-on-mathbb-N"><a href="#关于-mathbb-N-的数学归纳-Mathematical-Induction-on-mathbb-N" class="headerlink" title="关于$\mathbb{N}$的数学归纳 Mathematical Induction on $\mathbb{N}$"></a>关于$\mathbb{N}$的数学归纳 Mathematical Induction on $\mathbb{N}$</h3><p>假设从$x=0$开始，重复构建$x \mapsto x +1$。那么，也就构建了</p><p>$0, 0+1=1, 1+1=2,2+1=3,3+1=4,…$</p><p>这被称为$\mathbb{N}$</p><p>$\mathbb{N}$的数学归纳法对应原理：</p><p><strong>基础情形</strong> <em>Base Case</em>[B]: $P(0)$</p><p><strong>归纳过程</strong> <em>Inductive Step</em>[I]: $\forall k \ge 0(P(k)\Rightarrow(k+1))$</p><p><strong>结论</strong> <em>Conclusion</em>: $\forall n \in \mathbb{N}\ P(n)$</p><h3 id="归纳假设-Inductive-Hypothesis"><a href="#归纳假设-Inductive-Hypothesis" class="headerlink" title="归纳假设 Inductive Hypothesis"></a>归纳假设 Inductive Hypothesis</h3><p>为了证明$k≥0$时的归纳步骤[I]， $P(k)\Rightarrow P(k + 1)$，我们通常进行如下步骤：</p><p><strong>假设</strong>  <em>Assume</em> P(k)，对任意$k \ge 0$</p><p>​    $\vdots$  （推理步骤，通常使用$P(k)$假设）</p><p>推导出$P(k+1)$</p><p>此处，$P(k)$为称为<strong>归纳假设</strong> <em>Inductive Hypothesis</em></p><p><strong>定理</strong>：</p><p>对任意$n \in \mathbb{N}$，有</p><script type="math/tex; mode=display">P(n):\quad \sum_{i=0}^{n}i=\frac{n(n+1)}{2}</script><h3 id="从m开始的归纳-Induction-From-m-Upwards"><a href="#从m开始的归纳-Induction-From-m-Upwards" class="headerlink" title="从m开始的归纳 Induction From $m$ Upwards"></a>从m开始的归纳 Induction From $m$ Upwards</h3><p>如果</p><p>[B] $P(m)$</p><p>[I] $\forall k \ge m(P(k)\rightarrow P(k+1))$</p><p>那么</p><p>[C] $\forall n \ge m(P(n))$</p><p><strong>定理：</strong></p><p>对于任意的$n\ge 1$，$8^n-2^n$可被6整除</p><h3 id="推理步骤-Induction-Steps-mathcal-l-gt-1"><a href="#推理步骤-Induction-Steps-mathcal-l-gt-1" class="headerlink" title="推理步骤 Induction Steps  $ \mathcal{l} > 1$"></a>推理步骤 Induction Steps  $ \mathcal{l} &gt; 1$</h3><p>如果</p><p>[B] $P(m)$</p><p>[I] $P(k)\Rightarrow P(k+\mathcal{l})\quad \forall k\ge m$</p><p>那么</p><p>[C] $P(n)$ 对于所有的第 $\mathcal{l}$个 $n \ge m$</p><h3 id="强归纳-Strong-Induction"><a href="#强归纳-Strong-Induction" class="headerlink" title="强归纳 Strong Induction"></a>强归纳 Strong Induction</h3><p>这是一个归纳假设更强的版本。<br>我们不使用P(k)只适用于一个值，而是使用k之前的所有值。</p><p>如果</p><p>[B] $P(m)$</p><p>[I] $[p(m)\land P(m_1)\land \dots \land P(k)]\Rightarrow P(k+1)\ \forall k \ge m$</p><p>那么</p><p>[C] $P(n)$ 对于所有的 $n \ge m$</p><h3 id="负整数，逆向归纳-Negative-Integers-Backward-Induction"><a href="#负整数，逆向归纳-Negative-Integers-Backward-Induction" class="headerlink" title="负整数，逆向归纳 Negative Integers, Backward Induction"></a>负整数，逆向归纳 Negative Integers, Backward Induction</h3><p><strong> 注：</strong><br>归纳法可以对$\mathbb{Z}$的任何元素最小的子集进行。因此m可以是负数。如，[b] $m = -10^6$。<br>我们可以在”相反”方向$p(m) \Rightarrow p(m - 1)$上应用归纳法，它意味着以相反的顺序考虑整数，即n之后的下一个数是$n - 1$。这种归纳法可以用来证明所有$n≤m$时的某个$p(n)$。<br>有时需要推理所有整数$\mathbb{Z}$。这需要两个单独的简单归纳法证明：一个对$\mathbb{Z}$，另一个对$-\mathbb{Z}$。它们都会形成一些相同的初始值，比如0。之后，先证明正整数情形，再证明负整数情形。</p><h3 id="前后向归纳-Forward-Backward-Induction"><a href="#前后向归纳-Forward-Backward-Induction" class="headerlink" title="前后向归纳 Forward-Backward Induction"></a>前后向归纳 Forward-Backward Induction</h3><p>思考：<br>为了证明$P(n) \ \forall n \ge k_0$，</p><ul><li>核实$P(k_0)$</li><li>证明$P(k_i) 对无穷k_0 &lt; k_1 &lt; k_2 &lt; k_3 &lt; …$</li><li>填充空隙<br>$P(k_1) ⇒ P(k_1- 1) ⇒ P(k_1-2) ⇒ . . . ⇒ P(k_0 + 1)$<br>$P(k_2) ⇒ P(k_2- 1) ⇒ P(k_2-2) ⇒ . . . ⇒ P(k_1 + 1)$</li></ul><h3 id="无限下降-Infinite-Descent"><a href="#无限下降-Infinite-Descent" class="headerlink" title="无限下降 Infinite Descent"></a>无限下降 Infinite Descent</h3><p>欧拉定理：对于平面连接图G，有</p><script type="math/tex; mode=display">V-E+F=2</script><p>其中，F为面数，E为边数，V为顶点数</p><h3 id="结构归纳-Structural-Induction"><a href="#结构归纳-Structural-Induction" class="headerlink" title="结构归纳 Structural Induction"></a>结构归纳 Structural Induction</h3><p>归纳法不仅适用于自然数(和整数)，而且一般适用于任何部分有序集。<br>基本的方法总是一样的——我们需要验证这一点<br>[I] 对于任何给定的对象，如果该属性对其所有的前身(“较小的”对象)都有效，那么它对对象本身也有效<br>[B] 该属性适用于所有最小对象——没有前身的对象；它们通常是非常简单的对象，可以立即验证</p><p>定理：<br>在任何有根的树中，叶节点的数量都比有右兄弟节点的顶点的数量多1。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210504004826.png" alt="树的叶子节点和右兄弟节点"></p><h3 id="递归定义-Recursive-Definitions"><a href="#递归定义-Recursive-Definitions" class="headerlink" title="递归定义 Recursive Definitions"></a>递归定义 Recursive Definitions</h3><p>它们包括基(B)和递归过程(R)。<br>递归定义序列时(通常)<br>(B) 一些初始条款被指定，也许只有第一个；<br>(R) 后面的术语表示为前面术语的函数表达式。</p><p>(R)又称<strong>递归公式</strong> <em>recurrence formula</em></p><h3 id="关于递归定义的归纳证明"><a href="#关于递归定义的归纳证明" class="headerlink" title="关于递归定义的归纳证明"></a>关于递归定义的归纳证明</h3><p>关于递归定义函数的证明通常是根据定义的结构进行数学归纳法。</p><p>阿克曼数字 <em>Ackermann’s numbers</em>: $(2, 4, 6, 6553, …)$</p><script type="math/tex; mode=display">b_n = 2^{b_{n-1}}</script><h3 id="递归定义的正确性-Correctness-of-Recursive-Definitions"><a href="#递归定义的正确性-Correctness-of-Recursive-Definitions" class="headerlink" title="递归定义的正确性 Correctness of Recursive Definitions"></a>递归定义的正确性 Correctness of Recursive Definitions</h3><p>如果后一项的计算可以简化为(B)中给出的初始值，则递归公式是正确的。</p><p>在应用递归构造之前，对定义的边界(极限)情况进行评估。</p><h3 id="相互递归-Mutual-Recursion"><a href="#相互递归-Mutual-Recursion" class="headerlink" title="相互递归 Mutual Recursion"></a>相互递归 Mutual Recursion</h3><p>一些更复杂的程序采用了两个过程相互调用的技术。当然，它应该被设计成每个连续调用引用更小的参数，这样整个过程就会终止。这种方法常用于计算机图形学，特别是用于生成分形图像(包括各种想象的风景)。</p><h2 id="大o符号-动机-Big-Oh-Notation-Motivation"><a href="#大o符号-动机-Big-Oh-Notation-Motivation" class="headerlink" title="大o符号:动机 Big-Oh Notation: Motivation"></a>大o符号:动机 Big-Oh Notation: Motivation</h2><p>我们希望能够讨论一个程序/算法所需的资源(运行时间、内存、能量消耗)，作为其输入大小n的函数f (n)。</p><h3 id="增长的次序-Order-of-Growth"><a href="#增长的次序-Order-of-Growth" class="headerlink" title="增长的次序 Order of Growth"></a>增长的次序 Order of Growth</h3><p>增长的顺序提供了一种方法来抽象这两个问题，并专注于什么是函数大小的本质，通过说“(复杂的)函数g是大致相同的大小(对于大的输入)(简单的)函数f”</p><h3 id="渐近上界-Asymptotic-Upper-Bounds"><a href="#渐近上界-Asymptotic-Upper-Bounds" class="headerlink" title="渐近上界 Asymptotic Upper Bounds"></a>渐近上界 Asymptotic Upper Bounds</h3><h3 id="“Big-Oh”渐近上界-“Big-Oh”-Asymptotic-Upper-Bounds"><a href="#“Big-Oh”渐近上界-“Big-Oh”-Asymptotic-Upper-Bounds" class="headerlink" title="“Big-Oh”渐近上界 “Big-Oh” Asymptotic Upper Bounds"></a>“Big-Oh”渐近上界 “Big-Oh” Asymptotic Upper Bounds</h3><p>定义：<br>令$f,g:\mathbb{N} \rightarrow \mathbb{R}$，我们说$g$渐近小于$f$(或:$f$是$g$的上界)，如果存在$n_0\in N$，且实常数$c &gt; 0$对于所有$N≥n_0$，</p><script type="math/tex; mode=display">g(n) ≤ c · f (n)</script><p>对于所有渐近小于$f$的函数$g$，写作$\mathcal{O}(f (n))$。</p><p>传统的记录符号为：</p><script type="math/tex; mode=display">g(n) = \mathcal{O}(f (n))</script><p>一般地，</p><ul><li><p>对于常数$a_k \dots a_0$，</p><script type="math/tex; mode=display">a_k n^k + a_{k-1} n ^{k-1} + \dots + a_0 = \mathcal{O}(n^k)</script></li><li><p>所有的$\log _b x$都有相同的阶数，不管b的值是多少</p><script type="math/tex; mode=display">\mathcal{O}(\log_2 n) = \mathcal{O}(\log_3 n) = \dots = \mathcal{O}(\log_{10} n) = \dots</script></li><li><p>指数$r^n,s^n$到不同的基$r &lt; s$有不同的阶数，例如，对于所有的$n$没有c &gt; 0使$3^n &lt; c·2^n$</p><script type="math/tex; mode=display">\mathcal{O}(r^n)\not\subseteq \mathcal{O}(s^n) \not\subseteq \mathcal{O}(t^n) \dots \quad for\ r < s < t \dots</script></li><li><p>多项式类似</p><script type="math/tex; mode=display">\mathcal{O}(n^k) \not\subseteq \mathcal{O}(n^l) \not\subseteq \mathcal{O}(n^m) \dots \quad for\ k < l < m \dots</script></li></ul><p>以下是在分析程序性能(算法复杂度)时最常见的一些函数：</p><script type="math/tex; mode=display">\begin{array}{}1, \log \log n, \log n, \sqrt{n}, \sqrt{n}(\log n), \sqrt{n}(\log n)^2 \\n, n \log \log n, n \log n, n^{1.5}, n^2, n^3 \\2^n, 2^n \log n, n2^n, 3^n \\n!, n^n, n^{2n}, \dots, n^{n^2} , n^{2^n}\end{array}</script><p>符号:$\mathcal{O}(1)≡ const$，尽管技术上它可以是在两个常数c和d之间变化的任何函数。</p><h3 id="大θ符号-Big-Theta-Notation"><a href="#大θ符号-Big-Theta-Notation" class="headerlink" title="大θ符号 Big-Theta Notation"></a>大θ符号 Big-Theta Notation</h3><p><strong>定义：</strong><br>两个函数$f, g$如果以相同的方式伸缩，它们的增长顺序是相同的：<br>存在$n_0∈\mathbb{N}$，实常数$c &gt; 0, d &gt; 0$，对于所有$N≥n_0$，有</p><script type="math/tex; mode=display">c·f (N)≤g(N)≤d·f (N)</script><p>对于与$f$具有相同增长阶的所有函数$g$的类，写$Θ(f (n))$。</p><p>如果$g∈O(f)$，则$f$是(给出)$g$的增长阶的上界；如果$g∈Θ(f)$，我们称它为<strong>紧界</strong> <em>tight bound</em>。</p><p>注意这一点，有对称性</p><script type="math/tex; mode=display">g ∈ Θ(f ) \Leftrightarrow f ∈ Θ(g)</script><p>很明显，有</p><script type="math/tex; mode=display">Θ(f (n)) ⊆ \mathcal{O}(f (n))</script><p>同时，“大O”不是一个对称关系</p><script type="math/tex; mode=display">g ∈ \mathcal{O}(f ) \not\Rightarrow f ∈ \mathcal{O}(g)</script><h3 id="分析算法的复杂性"><a href="#分析算法的复杂性" class="headerlink" title="分析算法的复杂性"></a>分析算法的复杂性</h3><p>我们想知道当输入量增加时算法的运行时间是多少。为了避免特定计算平台的变化，我们以基本操作的数量而不是时钟时间来衡量性能。<br>通常我们将四种算术运算、比较运算和逻辑运算视为基本运算；它们占用一个处理器周期(或固定数量的周期)。</p><p>确定算法复杂度的一种典型方法，即对其运行时间的渐近估计，是将操作数的递归式写成输入大小的函数。<br>然后我们将递归式求解到一个大小的阶数。</p><h3 id="普遍式"><a href="#普遍式" class="headerlink" title="普遍式"></a>普遍式</h3><p>算法复杂度的递归通常涉及到子问题规模的<strong>线性减少</strong> <em>linear reduction</em>。<br><em>定理：</em><br>情行1：</p><script type="math/tex; mode=display">\begin{array}{}T(n) = T(n - 1) + bn^k \\T(n) = \mathcal{O}(n^{k+1})\end{array}</script><p>情行2：</p><script type="math/tex; mode=display">\begin{array}{}T(n) = cT(n - 1) + bn^k, c>1 \\T(n) = \mathcal{O}(c^n)\end{array}</script><p>这与分治算法形成了对比，在分治算法中，我们通过对某个c(通常是c = 2)的子问题递归来解决规模为n的问题。</p><h3 id="主定理-Master-Theorem"><a href="#主定理-Master-Theorem" class="headerlink" title="主定理 Master Theorem"></a>主定理 Master Theorem</h3><p><strong>定理：</strong><br>以下案例涵盖了实践中出现的许多分治法：</p><script type="math/tex; mode=display">T(n) = d^α · T (\frac{n}{d}) + \mathcal{O}(n^β)</script><p>情行1：$α &gt; β$，$T(n) = O(n^α)$<br>情行2：$α = β$，$T(n) = O(n^α\log n)$<br>情行3：$α &lt; β$，$T(n) = O(n^β)$</p><p>当我们将一个规模为$n$的问题简化为几个规模为$n/d$的子问题时，就会出现这种情况。如果这些子问题的数量是$d^α$，而合并这些更小的解的代价是$n^β$，那么总代价取决于$α$和$β$的相对大小。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>数学归纳法 Mathematical induction<br>基本情况，归纳假设$P(k)$<br>结论：归纳步骤$∀k (P(k)\Rightarrow P(k + 1))$</li><li>变化 Variations:<br>强型、前后型、结构型。</li><li>递归定义 recursive definitions<br>“大-哦”符号$\mathcal{O}(f (n))$为一类函数<br>$f (n)$是上界;$Θ(f (n))$</li><li>分析算法的复杂性，求解递归</li><li>线性缩减的一般结果指数约简(“主定理”)</li></ul><blockquote><p><strong>参考资料</strong></p><p>Textbook (R &amp; W) - Ch. 4, Sec. 4.2-4.6</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9020 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 离散数学 </tag>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础课程笔记（8）</title>
      <link href="/2021/03/28/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-8/"/>
      <url>/2021/03/28/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-8/</url>
      
        <content type="html"><![CDATA[<h2 id="文件组织和索引"><a href="#文件组织和索引" class="headerlink" title="文件组织和索引"></a>文件组织和索引</h2><h3 id="成本模型"><a href="#成本模型" class="headerlink" title="成本模型"></a>成本模型</h3><p><strong>D</strong>: 读取或写入磁盘页的平均时间</p><p><strong>C</strong>: 处理记录的平均时间</p><p>H：对记录应用Hash函数所需的时间</p><p>3文件组织:<br>堆文件</p><p>整理文件</p><p>散列文件</p><h3 id="待研究的操作"><a href="#待研究的操作" class="headerlink" title="待研究的操作"></a>待研究的操作</h3><p><strong>扫描Scan</strong>：获取文件中的所有记录</p><p>根据相等选择搜索。(SWES) (“ Find the students record with sid = 23 “)<br>根据范围选择搜索。(SWRS) (“ Find all students with name alphabetically after ‘ Smith ‘ “)</p><p><strong>插入Insert</strong>：插入一个给定的记录到文件中。</p><p><strong>删除Delete</strong>:删除给定rid的记录。</p><p>下面，我们将根据3种不同的文件组织检查这些操作的成本。</p><h3 id="堆文件Heap-Files"><a href="#堆文件Heap-Files" class="headerlink" title="堆文件Heap Files"></a>堆文件Heap Files</h3><p>扫描：</p><p>B(D + RC)，其中<strong>B是页面数</strong>，<strong>R是页面(块)的平均记录数</strong></p><p>SWES：</p><p>如果选择是在一个键上指定的，平均0.5B(D + RC)，否则为B(D + RC)</p><p>SWRS：</p><p>插入Insert: 2D + C (总是插入到文件末尾)</p><p>删除Delete：</p><p>只涉及到一个记录</p><ul><li><p>如果rid没有给出，平均成本为0.5B(D + RC) + D;</p></li><li><p>其他为 (D + C ) + D</p></li></ul><p>如果涉及几条记录，则花费巨大</p><h3 id="整理文件-Sorted-Files"><a href="#整理文件-Sorted-Files" class="headerlink" title="整理文件 Sorted Files"></a>整理文件 Sorted Files</h3><p>按搜索键排序——一个或多个字段的组合</p><p>如果对搜索键执行以下查询，则：</p><p>扫描Scan: B(D + RC)</p><p>SWES: </p><p>如果唯一记录 O(D log2  B + C log2 R) </p><p>O(D log2 B + C log2 R + #matches)</p><p>SWRS:</p><p>O (D log2 B + C log2 R + #matches)</p><p>插入：花费巨大，搜索成本 + 2∗(0.5B(D + RC))</p><p>删除：花费巨大，搜索成本 + 2∗(0.5B(D + RC))</p><h3 id="哈希文件-Hashed-Files"><a href="#哈希文件-Hashed-Files" class="headerlink" title="哈希文件 Hashed Files"></a>哈希文件 Hashed Files</h3><p>文件中的页面被分组成桶。bucket由散列函数定义。页面的占用率保持在80%左右。</p><p>假设数据操作基于Hash键。</p><p>扫描Scan：1.25B(D + RC)</p><p>SWES：如果每个哈希桶只包含一个页面，则H + D + 0.5RC</p><p>SWRS: 1.25B(D + RC)。（没有从哈希结构得到帮助）</p><p>插入Insert：如果涉及一个块，搜索成本加上C + D</p><p>删除Delete：如果涉及一个块，搜索成本加上C + D</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><div class="table-container"><table><thead><tr><th>FileType</th><th>Scan</th><th>EqualitySearch</th><th>RangeSearch</th><th>Insert</th><th>Delete</th></tr></thead><tbody><tr><td>Heap</td><td>BD</td><td>0.5 BD</td><td>BD</td><td>Search + D</td><td>Search+ D</td></tr><tr><td>Sorted</td><td>B D</td><td>D log B</td><td>D log B+# matches</td><td>Search+ BD</td><td>Search+ BD</td></tr><tr><td>Hashed</td><td>1.25 BD</td><td>D</td><td>1.25 BD</td><td>2 D</td><td>Search+ BD</td></tr></tbody></table></div><h2 id="索引-Indexes"><a href="#索引-Indexes" class="headerlink" title="索引 Indexes"></a>索引 Indexes</h2><p>索引背后的基本思想是参照书籍：</p><p>一个键值表，其中每个条目给出使用键的位置。</p><p>目的：通过键值有效地访问记录。</p><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210328203734.png" alt="索引结构" style="zoom:25%;"></p><p>索引是数据项k∗的集合。</p><p>每个数据条目k∗都包含足够的信息来检索（一个或多个）具有搜索键值k的记录。</p><p>编入索引 Indexing：</p><p>如何组织数据条目以支持对具有给定搜索键值的数据条目的有效检索？数据输入到底存储了什么？</p><h3 id="索引中数据条目的替代方案"><a href="#索引中数据条目的替代方案" class="headerlink" title="索引中数据条目的替代方案"></a>索引中数据条目的替代方案</h3><p>数据条目k∗是一个实际的数据记录（搜索键值k）。</p><p>一个数据条目（k, 消除）对（rid是数据的记录id，记录搜索键值k)</p><p>数据条目是（k, rid-list）对（rid-list是数据的记录ids，记录搜索键值k)</p><p>例如：(Xuemin Lin, page 12),(Xuemin Lin, page 100)和(Xuemin Lin, page 12, page 100)</p><h3 id="聚集索引-Clustered-Index"><a href="#聚集索引-Clustered-Index" class="headerlink" title="聚集索引 Clustered Index"></a>聚集索引 Clustered Index</h3><p>群集：一个文件是由数据记录组织起来的，与某些索引中的数据条目的顺序相同或接近。通常，“file”的搜索键与“index”的搜索键相同。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210328204638.png" alt="集群索引" style="zoom:50%;"></p><h3 id="未聚集索引-Unclustered-Index"><a href="#未聚集索引-Unclustered-Index" class="headerlink" title="未聚集索引 Unclustered Index"></a>未聚集索引 Unclustered Index</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210328204753.png" alt="未聚集索引" style="zoom:50%;"></p><p>聚集索引维护起来相对昂贵。一个数据文件最多可以集中在一个搜索键上。</p><h3 id="稠密索引与稀疏索引-Dense-VS-Sparse-Indexes"><a href="#稠密索引与稀疏索引-Dense-VS-Sparse-Indexes" class="headerlink" title="稠密索引与稀疏索引 Dense VS Sparse Indexes"></a>稠密索引与稀疏索引 Dense VS Sparse Indexes</h3><p>密集：对于每个搜索键值，它包含(至少)一个数据输入。</p><p>稀疏：其他情况</p><p>Q：我们可以建立一个非聚集的稀疏索引吗？</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210328205021.png" alt="稀疏索引VS稠密索引" style="zoom: 33%;"></p><h3 id="一级和二级索引-Primary-and-Secondary-Indexes"><a href="#一级和二级索引-Primary-and-Secondary-Indexes" class="headerlink" title="一级和二级索引 Primary and  Secondary Indexes"></a>一级和二级索引 Primary and  Secondary Indexes</h3><p>一级：索引字段包括主键</p><p>二级：其他情况</p><p>一个文件最多只能有一个主索引</p><p>组合搜索键：搜索键包含多个字段</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9311 </tag>
            
            <tag> 编辑中 </tag>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础课程笔记（7）</title>
      <link href="/2021/03/28/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-7/"/>
      <url>/2021/03/28/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-7/</url>
      
        <content type="html"><![CDATA[<h2 id="磁盘及文件"><a href="#磁盘及文件" class="headerlink" title="磁盘及文件"></a>磁盘及文件</h2><h3 id="记忆等级"><a href="#记忆等级" class="headerlink" title="记忆等级"></a>记忆等级</h3><div class="table-container"><table><thead><tr><th>等级</th><th>存储</th><th>特点</th></tr></thead><tbody><tr><td>一级存储</td><td>主内存</td><td>访问快，昂贵</td></tr><tr><td>二级存储</td><td>磁盘</td><td>访问慢，略昂贵</td></tr><tr><td>三级存储</td><td>磁带、CD等</td><td>访问最慢，最便宜</td></tr></tbody></table></div><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>磁盘的特点</p><ul><li><strong>盘片（platters）</strong>集</li><li>每个盘片=<strong>磁道（tracks）</strong>集</li><li>每个磁道=<strong>扇区sectors</strong>（块blocks）序列</li><li>传输单元：1扇区（例如512B, 1KB）</li><li>访问时间取决于磁头访问扇区所需耗时</li><li>通过块地址访问（p, t, s）</li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210328171315.png" alt="磁盘结构" style="zoom: 33%;"></p><p>DBMS只能对保存在内存中的数据进行操作。对于磁盘来说，如果需要读取一个块中的一条记录，则整个块都会被转移。</p><p>访问时间包括：</p><ul><li><strong>寻道时间（find the right track）</strong>，例如10msec</li><li><strong>旋转延迟（find the right sector）</strong>，例如5msec</li><li><strong>传输时间（read/write block）</strong>，例如10μsec</li></ul><p>随机访问主要受寻道时间和旋转延迟的控制</p><h3 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h3><p>磁盘空间由磁盘空间管理器管理</p><ol><li><p>提高磁盘访问：<br>使用数据访问模式的知识，例如：两条记录经常一起访问，那就将它们放在同一个块（集群）<br>例如：顺序扫描的记录，那么就将它们放置在同一轨道上的连续扇区</p></li><li><p>跟踪空闲块：</p><ul><li>维护空闲块列表</li><li>使用位图</li></ul></li><li><p>使用OS文件系统管理磁盘空间</p><ul><li>扩展OS工具，但是</li><li>不依赖OS文件系统（保证可移植性和可伸缩性）</li></ul></li></ol><h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3><p>缓冲区管理器</p><p>通过在主内存中维护一个缓冲池来管理磁盘和内存之间的通信</p><p><strong>缓冲池（Buffer pool）</strong>=可以填满磁盘块数据副本的page slots（帧）集合</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210328172609.png" alt="缓冲池访问示意图" style="zoom: 33%;"></p><p>request_block操作先替换所有文件访问算法中的read block</p><p>如果块已经在缓冲池中：</p><ul><li>不需要再读取这些数据<br>直接在缓冲池复制（除非write-locked）</li></ul><p>如果块还没有在缓冲池中：</p><ul><li>需要从硬盘读取到一个空闲帧</li><li>如果没有空闲帧，需要使用缓冲区替换策略删除块</li></ul><p>release_block函数表明块不再在使用，这意味着它是是好的移除候选项</p><p>对于每一帧，我们需要知道：</p><ul><li>它目前是否正在使用</li><li>自加载后，它是否已经被修改（脏位）</li><li>有多少事务目前正在使用它（pin计数）</li><li>（可能）时间戳为最近访问</li></ul><p><strong>request_block操作</strong><br>方法：</p><ol><li><p>检查缓冲池，看它是否已经包含请求的块。<br>如果没有，区块被引入如下：<br>(a)选择要替换的帧，使用替换策略<br>(b)如果选择的帧是脏的，写块到磁盘<br>(c)将请求的页面读到现在空闲的缓冲区帧(并设置dirty= False和pinCount = 0)</p></li><li><p>固定包含请求块的框架（这只是意味着更新pin计数）</p></li><li><p>包含被请求块的帧的返回地址</p></li></ol><p><strong>release_block操作</strong></p><p>方法：</p><p>减少指定页的pin计数。除非需要更换，否则没有实际效果。</p><p><strong>write_block操作</strong></p><p>方法：</p><ol><li>更新池中包含的页面</li><li>设置脏数据dirty bit</li></ol><p>注意：实际上不写入磁盘。</p><p><strong>force_block操作</strong>通过写入磁盘来”提交“。</p><h4 id="缓冲区替换策略"><a href="#缓冲区替换策略" class="headerlink" title="缓冲区替换策略"></a>缓冲区替换策略</h4><p>有几种常用的方案：</p><ul><li>最少最近使用(LRU)<ul><li>释放没有使用最长时间的框架</li><li>直觉上吸引人，但可能执行效果并不理想</li></ul></li><li>先进先出（FIFO）<ul><li>需要维护帧队列</li><li>当读取时进入队列尾部</li></ul></li><li>最近使用(MRU)：释放最近使用的帧</li><li>随机</li></ul><p>没有保证比其他更好。对于DBMS，我们可以更好地预测访问。</p><h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h3><p>记录存储在固定长度的块中。</p><ul><li>固定长度fixed-length：每个字段都有一个固定的长度和字段的数量。<ul><li>便于块内空间管理</li><li>可能浪费空间</li></ul></li><li>可变长度：某些字段的长度可变<ul><li>复杂的块内空间管理</li><li>不浪费（太多）空间</li></ul></li></ul><p>记录格式信息：</p><ul><li>最好存储在数据字典</li><li>字典内存驻留</li></ul><h4 id="固定长度"><a href="#固定长度" class="headerlink" title="固定长度"></a>固定长度</h4><p>固定长度记录的编码方案：</p><ul><li>长度+偏移量存储在头文件中</li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210328181650.png" alt="固定长度存储记录" style="zoom:50%;"></p><h4 id="可变长度"><a href="#可变长度" class="headerlink" title="可变长度"></a>可变长度</h4><p>可变长度记录的编码方案：</p><ul><li>每个字段以长度为前缀<br>[4] xxxx [10]Neil Young [8]musicians [4] xxxx</li><li>字段以分隔符结尾<br>33357462/Neil Young/ musicians /0277/</li><li>偏移数组</li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210328181958.png" alt="可变长度" style="zoom:50%;"></p><h2 id="块（页面）格式"><a href="#块（页面）格式" class="headerlink" title="块（页面）格式"></a>块（页面）格式</h2><p>块是<strong>槽slots</strong>的集合。</p><p>每个插槽包含一条记录。</p><p>记录由rid =&lt;页面id，槽位号&gt;标识。</p><h4 id="固定长度的记录"><a href="#固定长度的记录" class="headerlink" title="固定长度的记录"></a>固定长度的记录</h4><p>对于固定长度的记录，使用记录槽：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210328182233.png" alt="固定长度的记录" style="zoom:50%;"></p><p>插入：占用第一个空闲槽；打包更有效率。</p><p>删除：(a)需要压缩，(b)标记为0；打开更有效率。</p><h4 id="变长记录"><a href="#变长记录" class="headerlink" title="变长记录"></a>变长记录</h4><p>对于变长记录，请使用槽位目录。</p><p>处理块内的空闲空间的可能性：</p><ul><li>压缩（一个区域的空闲空间）</li><li>碎片（分布式空闲空间）</li></ul><p>在实践中，可能使用一个组合：</p><ul><li>通常碎片化（维护成本低）</li><li><p>在需要时压缩（例如记录不适合）</p></li><li><p>压实自由空间：</p></li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210328182523.png" alt="压实自由空间" style="zoom: 33%;"></p><p>注意：“指针”是在块内实现的偏移量；允许块被加载到内存的任何地方。</p><ul><li>分散的自由空间：</li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210328182822.png" alt="分散的自由空间" style="zoom:33%;"></p><h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><p>一些文件结构（例如哈希）将记录分配给特定的块。如果指定的块已经满了怎么办？需要一个地方来存储“多余的”记录。</p><p>介绍溢出块的概念：</p><ul><li>位于主文件外部（不破坏主文件的块序列）</li><li>连接到原始块</li><li>可能有溢出块的“链”</li></ul><p>新块总是追加到文件中</p><p><strong>一个单独文件中的溢出块</strong>：</p><p>注意：”指针“是作为文件偏移量实现的</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210506004507.png" alt="指针" style="zoom:50%;"></p><p>不适合通过偏移（例如哈希）访问块</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210328183501.png" alt="image-20210328183501422" style="zoom:25%;"></p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>一个文件由几个数据块组成。</p><p><strong>堆文件（Heap Files）</strong>：无序的页面（块）。</p><p>维护阻塞信息的两种选择：</p><ul><li>链接页面列表</li><li>页面目录</li></ul><h4 id="链接页面列表"><a href="#链接页面列表" class="headerlink" title="链接页面列表"></a>链接页面列表</h4><p>将堆文件维护为双向链接的页面列表。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210328183810.png" alt="链接页面列表" style="zoom:50%;"></p><p>缺点：如果记录的长度是可变的，那么所有的页面实际上都在空闲的记录列表中。为了插入一个记录，可能要检索和检查几页。</p><h4 id="页面的目录"><a href="#页面的目录" class="headerlink" title="页面的目录"></a>页面的目录</h4><p>维护页面目录。</p><ul><li>每个目录条目标识堆文件中的一个页（或一系列页）。</li><li>每个条目还保留一个位来指示对应的页面是否有空闲空间。</li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210328184033.png" alt="页面的目录" style="zoom:33%;"></p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9311 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础大作业记录（1）</title>
      <link href="/2021/03/23/unsw/comp9311/shu-ju-ku-ji-chu-da-zuo-ye-ji-lu-1/"/>
      <url>/2021/03/23/unsw/comp9311/shu-ju-ku-ji-chu-da-zuo-ye-ji-lu-1/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>这个项目的目的是给你练习</li><li>阅读和理解一个中等规模的关系模式(MyMyUNSW)</li><li>实现SQL查询和视图，以满足信息请求</li><li>实现PLpgSQL函数来帮助满足对信息的请求</li></ul><h2 id="如何做这个项目"><a href="#如何做这个项目" class="headerlink" title="如何做这个项目"></a>如何做这个项目</h2><ul><li>仔细、完整地阅读本说明书</li><li>熟悉数据库模式（描述、SQL模式、摘要）</li><li>为这个项目创建一个私有目录，并放置一个projec1.sql的副本</li><li>当定义解决方案时必须使用proj1中的create语句</li><li>查看作为检查的一部分加载的expected_qX表中的预期输出check.sql文件</li><li>解决下面的每个问题，并将你完成的解决方案放入proj1.sql中</li><li>检查您的解决方案是正确的，通过验证与示例输出和使用check_qX()函数</li><li>测试你的proj1.sql文件，可以毫无错误地加载到只包含原始文件的数据库中MyMyUNSW数据</li><li>仔细检查你的proj1.sql文件加载到仅包含原始MyMyUNSW数据</li><li>通过moodle提交项目</li><li>对于每个问题，您必须在120秒内在Grieg服务器上输出结果</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>所有的大学都需要一个重要的信息基础设施来管理他们的事务。这通常需要安装一个大型的商业DBMS。UNSW的学生信息系统位于MyUNSW网站的后面。MyUNSW提供了一个与PeopleSoft企业管理系统的接口，该系统具有底层Oracle数据库。这个后端系统(Peoplesoft/Oracle)通常称为NSS。</p><p>UNSW已经在MyUNSW/NSS系统上花了相当多的钱(8000多万美元)，而且它似乎很好地处理了大部分的教育管理工作。大多数人都抱怨MyUNSW的界面质量，但该系统确实允许你在线完成最基本的注册任务。</p><p>尽管MyUNSW/NSS取得了成功，但仍然存在一些不足，包括：</p><ul><li>没有课程或课程报名等候名单</li><li>没有代表学位项目结构</li><li>与新南威尔士大学在线手册的整合很差</li></ul><p>第一点很不方便，因为这意味着注册一门完整的课程或课程变成了一系列反复尝试的过程。想要注册这门可的人只能希望在注册之前有人退出，而且没有其他人抢了这个空位。</p><p>第二点限制了MyUNSW/NSS在三个重要操作，而这些操作原本对学生管理他们的注册非常有帮助：</p><ul><li>了解他们在学位课程中已经取得了多大的进步，还有哪些是需要完成的</li><li>查一查他们下学期的注册项目（例如，弄一份可供选择的课程列表）</li><li>确定他们何时完成了学位课程的所有要求并有资格毕业</li></ul><p>NSS包含有关学生、课程、课程、先决条件、配额等数据，但不包含任何UNSW学位项目结构的表示。如果在NSS数据库中没有这些信息，以上三种情况都是不可能做到的。因此，在2007年，COMP9311班设计了一个数据模型，可以代表UNSW学位课程的要求和规则。这是建立在表示所有核心NSS数据（学生、工作人员、课程、类等）的现有模式之上的。增强的数据模型被命名为MyMyUNSW模式。</p><p>MyMyUNSW数据库包括包括NSS功能的信息，UNSW在线手册和CATS（房间分配）数据库。MyMyUNSW数据模型、模式和数据库在单独的文档中描述。</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>要在Grieg服务器下安装MyMyUNSW数据库，只需运行以下两个命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ createdb proj1$ psql proj1 -f /home/cs9311/web/21T1/proj/proj1/mymyunsw.dump<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你已经在template1数据库中设置了PLpgSQL，当数据库开始加载时，你会得到一条错误消息:</p><pre class="line-numbers language-none"><code class="language-none">psql:mymyunsw.dump:NN: ERROR: language "plpgsql" already exists<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您可以忽略此错误消息，但是在加载期间发生的任何其他错误都需要进行调查。</p><p>如果一切正常，load输出应该有很多信息。</p><p>除了可能的与plpgsql相关的消息外，您应该不会得到错误消息。在Grieg上加载数据库的时间应该少于60秒，前提是Grieg负载不重。(如果您直到最后一刻才开始进行项目，那么在Grieg上加载数据库将会相当缓慢，从而进一步推迟您的工作。解决方案：至少现在就加载数据库，即使您一段时间后不要开始使用它。转储文件大小为50MB；把它复制到你的主目录或/srvr目录下不是一个好主意)。</p><p>如果您的PostgreSQL服务器在Grieg上有其他大型数据库，或者您的/srvr/you/目录下有大型文件，那么您可能会耗尽Grieg磁盘配额。特别是，您将无法在Grieg服务器下存储MyMyUNSW数据库的两个副本。解决方案:在加载MyMyUNSW数据库之前删除所有现有的数据库。</p><p>如果您在家里运行PostgreSQL，您可以下载这些文件：ymyunsw.dump，proj1.sql来帮助您开始。一旦check.sql可用，你可以去拿单独使用。</p><p>一开始要做的一件事是对实际存在的数据有一个感觉。这可以帮助你更好地理解模式，并使练习的描述更容易理解。看看这个模式。问一些查询。现在就做。</p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">$ psql proj1... PostgreSQL welcome stuff ...proj1=# \d... look at the schema ...proj1=# select * from Students;... look at the Students table ...proj1=# select p.unswid,p.name from People p join Students s on (p.id=s.id);... look at the names and UNSW ids of all students ...proj1=# select p.unswid,p.name,s.phone from People p join Staff s on (p.id=s.id);... look at the names, staff ids, and phone #s of all staff ...proj1=# select count(*) from Course_Enrolments;... how many course enrolments records ...proj1=# select * from dbpop();... how many records in all tables ...proj1=# ... etc. etc. etc.proj1=# \q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>您将发现一些表（例如，书籍、需求等）目前没有填充；这个项目不需要他们的内容。</p><h3 id="入门总结"><a href="#入门总结" class="headerlink" title="入门总结"></a>入门总结</h3><p>要为这个项目设置数据库，按提供的顺序运行以下命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ createdb proj1$ psql proj1 -f /home/cs9311/web/21T1/proj/proj1/mymyunsw.dump$ psql proj1... run some checks to make sure the database is ok$ mkdir Project1Directory... make a working directory for Project 1$ cp /home/cs9311/web/21T1/proj/proj1/proj1.sql Project1Directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在开始做练习之前，请先阅读以下内容：</p><ul><li>分数反映了每个问题的相对难度/长度</li><li>使用提供的proj1.sql模板文件来完成任务</li><li>可以根据需要定义更多的附加函数和视图，前提是(a)在保留proj1.sql中的定义，(b)您可以按照每个问题中的要求来定义允许定义的内容</li><li>确保你的查询可以在MyMyUNSW模式的任何实例上工作；不要定制它们只在这个数据库上工作；最后可能在一个不同的实例上测试</li><li>不要假设任何查询都只返回单个结果;即使用“大多数”或“最大”来表示，数据库中也可能有两个或两个以上同样“大”的实例</li><li>查询人名时，使用Person.name字段;它的作用就是产生可显示的名称</li><li>当查询要求学生ID时，使用people.unswid字段；people.id字段是一个内部数字键，数据库之外的任何人都不感兴趣</li><li>除非在练习中特别提到，否则结果中元组的顺序无关紧要；它可以随时调整使用顺序。事实上，我们的check.sql将自动对结果进行排序以进行比较</li><li>结果元组中字段的精确格式确实很重要，例如，如果你使用to_char将一个数字转换为字符串，它可能不再匹配包含相同值的数字字段，即使这两个字段看起来很相似</li><li>分阶段开发查询；在最终视图/函数的查询中使用它们之前，请确保您正在使用的任何子查询或子连接实际工作正确</li><li>您可以定义SQL视图来回答以下问题。</li><li>如果你遇到类似“不能改变视图列的名称”这样的错误，你可以使用命令<code>drop view VIEWNAME cascade</code>删除你刚刚创建的视图，然后重新创建你的新视图。</li></ul><p>每个问题都附有对所需内容的简要描述。如果您想要预期输出的完整细节，请查看检查脚本中提供的expected_qX表。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>为了方便半自动标记，请按照每个问题中定义的方式将所有SQL解决方案打包到视图中(参见我们提供的解决方案模板的详细信息)。</p><pre class="line-numbers language-none"><code class="language-none">$ dropdb proj1 ... remove any existing DB$ createdb proj1 ... create an empty database$ psql proj1 -f /home/cs9311/web/21T1/proj/proj1/mymyunsw.dump ... load the MyMyUNSW schema and data$ psql proj1 -f /home/cs9311/web/21T1/proj/proj1/check.sql ... load the checking code$ psql proj1 -f proj1.sql ... load your solution (replace by proj2.sql here)$ psql proj1proj1=# select check_q1(); … check your solution to question1 (replace by check_q13() here)…proj1=# select check_q6(); … check your solution to question6…proj1=# select check_q12(); … check your solution to question13proj1=# select check_all(); … check all your solutions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9311 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 实践操作 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学课程笔记-综合</title>
      <link href="/2021/03/22/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-zong-he/"/>
      <url>/2021/03/22/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-zong-he/</url>
      
        <content type="html"><![CDATA[<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><p>正整数$\mathbb{P}$ 自然数$\N$ 整数$\Z$ 有理数$\Q$ 实数$\R$</p><p>$\mathbb{P} \subset \N \subset \Z \subset \Q \subset \R$</p><p>$\lfloor\pi \rfloor=3=3\lceil e \rceil$</p><p>$\lfloor -x \rfloor=-\lceil x \rceil \quad \lceil x \rceil = - \lfloor -x \rfloor$</p><p>对于$m \le n$，其中有$\lfloor \frac{n}{k}\rfloor- \lfloor \frac{m-1}{k}\rfloor$个$k$</p><p>$m|n$，意思是n可以被m整除，除数divisor，即$n=k\cdot m $；相对的表示为$m\not|\ n$</p><p>$r=n\mod m\Rightarrow n=k\cdot m + r(0\le r&lt; m)$</p><p>质数prime，互质relatively prime，最大公约数$gcd (m,n)$，最小公倍数$lcm (m,n)$</p><p>$gcd (m,n) \cdot lcm(m,n) = |m|\cdot |n|$</p><p>$gcd(0,n)=|n|(n\neq 0)$</p><p>$gcd(m,n)=\begin{cases} m &amp; (m=n)\\ gcd(m-n,n) &amp; (m&gt;n)\\ gcd(m,n-m) &amp; (m&lt;n)\end{cases}$</p><p>闭区间$[a,b]$，边开半闭区间$(a,b]，[a,b)$，开区间$(a,b)$</p><p>对于$m\le n$的整数，$[m,n]=\{m,m+1,\dots,n\}\quad |[m,n]|=n-m+1$</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>定义：集合set，元素element，有限集，无限集，空集empty set $\emptyset$，全集U</p><p>符号表示方法：集合$A,B,C$；元素$a,b,c$；</p><p>属于关系$a \in A \quad a \not\in A$</p><p>表示方法：枚举法、叙述法、文氏图</p><p>基数Cardinality $|A|$：元素的个数</p><p>集合相等$A=B$，即其包含的元素完全相同</p><p>子集subset $B\subseteq A \quad B \nsubseteq A$，真子集proper subset $B\subset A \quad B\not\subset A$</p><p>证明集合相等：$A=B \Leftrightarrow A\subseteq B \land B\subseteq A$</p><p>幂集(power set)：$Pow(A)$，$|Pow(X)|=2^{|X|}$</p><p>并集Union $A\cup B$，交集Intersection $A \cap B$，补集$A^C$，差集$A\setminus B$，对称差集$A\oplus B\overset{def}{=}(A\setminus B)\cup(B \setminus A)$</p><p>不相交disjoint $A \cap B=\emptyset$</p><p>集合的运算</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210322145505.png" alt="集合的运算"></p><script type="math/tex; mode=display">|A \cup B|=|A|+|B|-|A\cap B| \\|A \cup B|+ |A\cap B|=|A|+|B| \\|A \setminus B|=|A|-|A\cap B| \\|A \oplus B|=|A| + |B| -2|A\cap B|</script><p>等势$A\sim B$，可数集合，不可数集合</p><p>文氏图Venn Diagrams</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210324212241.png" alt="文氏图样例" style="zoom: 33%;"></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>定义域dom f，值域ran f</p><p>单射1-1，满射onto，双射bijection</p><p>复合函数$(f\circ g)(x)=g(f(x))$</p><p>复合函数不满足交换律，但满足结合律</p><p>逆函数</p><p>词语word $\Sigma$，空词empty word $\lambda$，$\Sigma^k\ \Sigma^0\ \Sigma^*\ \Sigma^+\ \Sigma^{\le k}$</p><h2 id="命题逻辑"><a href="#命题逻辑" class="headerlink" title="命题逻辑"></a>命题逻辑</h2><p>定义：命题，真值T1F0，原子命题，复合命题，真值函数/命题公式，公式的解释，真值表</p><p>否定联结词$\lnot$，合取联结词$\land$，析取联结词$\lor$，蕴含联结词$\Rightarrow$，等价联结词$\Leftrightarrow$</p><p>否定式$\lnot P$，合取式$P\land Q$，析取式$P\or Q$，蕴含式$P\Rightarrow Q$，等价式$P \Leftrightarrow Q$</p><p>$\land \or \Leftrightarrow$具有对称性，$\lnot \rightarrow$没有对称性</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210322151657.png" alt="命题联结词的真值表"></p><p>永真公式（重言式），永假公式（矛盾式/不可满足公式），可满足公式</p><p>逻辑等价$G=H$，充要条件是$G\Leftrightarrow H$</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210322154100.png" alt="基本等价关系1"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210322154132.png" alt="基本等价关系2"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210322154155.png" alt="基本等价关系3"></p><p>简单析取式$P\lor Q \lor \lnot R$，简单合取式$\lnot P \land Q \land R$</p><p>析取范式（DNF），合取范式（CNF），主范式</p><p>极小项和极大项</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210322160606.png" alt="极小项的性质"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210322160649.png" alt="极大项的性质"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210322161229.png" alt="极小项和极大项的性质"></p><p>主范式求解定理：</p><ol><li>求析取范式和合取范式</li><li>消除重复命题变元，矛盾式，重言式</li><li>缺少变元P可通过增加$\land (\lnot P \lor P)$或$\or (\lnot P \and P)$的方式补足</li><li>合并极小项和极大项，调整顺序</li></ol><p>求公式$G=\lnot (P \Rightarrow Q) \lor R$ 的主析取范式和主合取范式。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210322163202.png" alt="真值表求主范式方法"></p><p>（析取范式看1，子项0取逆，合取范式看0，子项1取逆）</p><p>（极大或有逆1，极小和有逆0）</p><p>推理定律–基本蕴涵关系</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210322164140.png" alt="![](https://gitee.com/szdf123/hexoblog/raw/master/img/20210322164140.png)"></p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>定义：序偶，笛卡尔积</p><p>笛卡尔积不一定满足交换律和结合律</p><p>对于有限集A，B，有$|A\times B| = | B \times A | = |A| \times |B|$，同时，从A到B的不同关系共有$2^{|A|\times |B|}$个</p><p>定义域dom（domain），值域ran（range），R的域fld（field）</p><p>关系的标识方法：图形表示，矩阵表示</p><p>关系矩阵（relation matrix），邻接矩阵（adjacency matrix）</p><p>布尔矩阵的并和交运算，积运算</p><p>关系的并交差补运算、逆运算</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210322175051.png" alt="逆运算的性质"></p><p>关系可以具有的性质：自反性（Reflexivity）反自反性（Antireflexivity）对称性（Symmetry）反对称性（Antisymmetry）传递性（Transitivity）</p><p>等价关系：自反(R)、对称(S)、传递(T)</p><p>等价类，如[0]；商集A/R</p><p>偏序关系：自反(R)、反对称(AS)、传递(T)</p><p>哈斯图，最大元，最小元，极大元，极小元</p><p>上界，上确界、下界，下确界</p><p>拟序关系：反自反(AR)，传递(T)</p><p>全序关系，全序集，良序关系，良序集</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图G(V,E)，无向图，有向图，混合图</p><p>环路，孤立结点</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9020 </tag>
            
            <tag> 持续更新 </tag>
            
            <tag> 离散数学 </tag>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学课程笔记（6）</title>
      <link href="/2021/03/21/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-6/"/>
      <url>/2021/03/21/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-6/</url>
      
        <content type="html"><![CDATA[<h2 id="图-Graphs"><a href="#图-Graphs" class="headerlink" title="图 Graphs"></a>图 Graphs</h2><p><strong>图（Graph）</strong>：用$G(V,E)$表示，其中，$V$为顶点的集合，$E$为边的集合，且每一条边都与点$\{x_e,y_e\}$相关。</p><p><strong>无向图（Undirected Graph）</strong>：线的起终点没有方向</p><p>有方向的边称作<strong>弧（arc）</strong>，它与有序对$(x_a,y_a)$相关。</p><p><strong>有向图（Directed Graph）</strong>由点和弧构成。</p><p>当$x=y$时，边$\{x,y\}$与弧$(x,y)$组成<strong>环（loops）</strong>。一般的，我们仅讨论无环图。</p><p>有限集合的二元关系对应于有向图。对称关系对应于无向图。</p><h4 id="计算机科学中的图"><a href="#计算机科学中的图" class="headerlink" title="计算机科学中的图"></a>计算机科学中的图</h4><ul><li>WWW（万维网）可以看做由网页作为节点，超链接作为弧组成的超大图</li><li>一段程序可能的状态可以构成一个有向图</li><li>地图可以看做一个无向图，其中每个国家的边界由边表示</li></ul><h3 id="顶点的度-Vertex-Degrees"><a href="#顶点的度-Vertex-Degrees" class="headerlink" title="顶点的度 Vertex Degrees"></a>顶点的度 Vertex Degrees</h3><p>图$G$中顶点$v$的<strong>度数（Degree）</strong>定义为：$deg(v)=|\{w\in V(G):(v,w)\in E(G)\}|$，即与该顶点连接的边的数目</p><p><strong>正则图（Regular graph）</strong>：所有顶点的度数相同</p><p><strong>度数序列（Degree sequence）</strong>：$D_0,D_1,D_2,…,D_k$，其中度数为$i$的顶点的数量</p><p>$\sum_{v\in V}deg(v)=2\cdot|E(G)|$，即顶点的度数和为2倍的边的数量，因此，顶点的度数和一定为偶数。也就是说，顶点度数的集合中，只能有偶数个基数顶点度数。</p><h3 id="通路-Paths"><a href="#通路-Paths" class="headerlink" title="通路 Paths"></a>通路 Paths</h3><p><strong>通路（Path）</strong>是图中连接起来的边，其中边和点都不必须完全不同</p><p>通路的<strong>长度（Length）</strong>即边的数量：$n$</p><p>长度为r的<strong>子通路</strong>：$(e_m,e_{m+1},…,e_{m+r-1})$</p><p>长度为0的通路：单个顶点$v_0$</p><p><strong>连通图（Connected graph）</strong>：每个顶点都有通路连接</p><p>图$G$的连接<strong>组成component</strong>：G中没有比其更大的连通子图的连通子图</p><h3 id="回路-Cycles"><a href="#回路-Cycles" class="headerlink" title="回路 Cycles"></a>回路 Cycles</h3><p><strong>简单通路（simple path）</strong>：对路径中的每个边，$e_i\neq e_j(i\neq j)$</p><p><strong>闭合通路（closed path）</strong>：$v_0=v_n$</p><p><strong>回路（cycles）</strong>：闭合简单路径，除了$v_0=v_n$以外，所有$v_i$均不相同</p><p><strong>非回路通路（Acyclic path）</strong>：对于路径中的所有的顶点，$v_i\neq v_j(i\neq j)$</p><p><strong>注：</strong></p><p>当且仅当移除路径中的一条边以后，路径变为非回路通路，那么这个通路就是回路$C_n=(e_1,…,e_n)$</p><p>当边和顶点数相同，且没有恰当的子通路时，C是一个回路</p><p><strong>恰当的子通路（proper subpath）</strong>：没有环存在的子通路</p><p>比如，如果$|E(G)|=|V(G)|$，每个顶点都包含一个环时，那这就不是个回路</p><h3 id="树-Trees"><a href="#树-Trees" class="headerlink" title="树 Trees"></a>树 Trees</h3><p><strong>非回路图（Acyclic graph）</strong>：不包含回路的图</p><p><strong>树（Tree）</strong>：连接起来的非回路图</p><p>一个图当且仅当是森林时，是非回路图</p><p><strong>森林（Forest）</strong>：一系列不连接的树</p><p>图$G$是树，等价于以下描述：</p><ul><li>$G$是非回路的，且$|V(G)|=|E(G)|+1$</li><li><p>每两个顶点之间只有一条精确的通路</p></li><li><p>$G$是连通的，但如果移除任意一条边的话，就变成非连通图</p></li><li>$G$是非回路的，但如果在现有的顶点中增加任意一条边，就有回路出现</li></ul><p>对于$n$个顶点的树，$n\ge 3$，则：</p><ul><li><p>$|E(T)|$并不永远等于$n$</p></li><li><p>最少一个顶点的度数为2</p></li><li><p>最少有两个顶点，$deg(v_1)=deg(v_2)$</p></li></ul><p>有根的树叫<strong>根树（Rooted tree）</strong>，这指定了数的起源：总是从根开始，从父节点到子节点。这也定义了节点的层级，即离根的距离。</p><p>根树的<strong>高度（Height）</strong>是最大顶点层级。</p><p><strong>有向非环图DAG（directed, acyclic graph）</strong></p><h3 id="图同构-Graph-Isomorphisms"><a href="#图同构-Graph-Isomorphisms" class="headerlink" title="图同构 Graph Isomorphisms"></a>图同构 Graph Isomorphisms</h3><p>当$\iota :V(G)\rightarrow V(H)$是1-1映射且满射（或叫双射），当且仅当$\{\iota(x),\iota(y)\}\in E(H)$时，$\{x,y\}\in E(G)$，那么$\iota : G\rightarrow H$是<strong>图同构（graph isomorphism）</strong></p><p>当两个图之间存在至少一个图同构时，他们被称为同构图。</p><p>具有2、3、4、5个顶点的非同构树为：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210321194717.png" alt="具有2、3、4、5个顶点的非同构树" style="zoom: 33%;"></p><h3 id="自同构和不对称图-Automorphisms-and-Asymmetric-Graphs"><a href="#自同构和不对称图-Automorphisms-and-Asymmetric-Graphs" class="headerlink" title="自同构和不对称图 Automorphisms and Asymmetric Graphs"></a>自同构和不对称图 Automorphisms and Asymmetric Graphs</h3><p>同构图与自身相同的图称为自同构图<em>Automorphism</em></p><p>每个图都至少包含平凡自同构<em>trivial automorphism</em></p><p>没有非平凡自同构图 <em>non-trivial automorphisms</em> 的图叫做不对称图 <em>asymmetric</em>。</p><p>最小的非平凡不对称图有6个顶点：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210321195117.png" alt="一个最小的非平凡不同构图" style="zoom:33%;"></p><p>类似的图一共有8个。</p><h3 id="遍历边"><a href="#遍历边" class="headerlink" title="遍历边"></a>遍历边</h3><p><strong>欧拉通路（Euler path）</strong>：包含图G中每条边1次的通路</p><p><strong>欧拉回路（Euler circuit）</strong>：闭合欧拉通路</p><p>欧拉通路和欧拉回路的特性：</p><ul><li><p>对于每个顶点$v\in V(G)$，当且仅当$deg(V)$是偶数时，连通图G有欧拉回路。</p></li><li><p>当且仅当或者有欧拉回路，或者包含2个基数度顶点的连通图G有欧拉通路。</p></li></ul><p>对于有环的图，这两个特性仍然适用</p><p>对于有向图，欧拉回路存在的条件是$\forall v \in V(G)\ indeg(v)=outdeg(v)$</p><h3 id="特殊的图"><a href="#特殊的图" class="headerlink" title="特殊的图"></a>特殊的图</h3><p><strong>完全图（Complete graph）</strong>$K_n$，有$n$个顶点，全部相互连接，含有$\frac{n(n-1)}{2}$条边</p><p><strong>完全双边图（Complete bipartite graph）</strong>$K_{n,n}$，有$m+n$个顶点，分割为两个不连接的集合，一个包含n个顶点，另一个包含m个顶点。每个顶点都与另一组顶点连接，每组内的顶点相互不连接。其边的数量为$m\cdot n$</p><p><strong>完全k部图（Complete k-partite graph）$K_{m_1,…,m_k}$</strong></p><p>包含$m_1 + … + m_k$个顶点，分割成k个不相接的集合，分别为顶点$m_1,m_2…$。所有来自不同集合顶点相连，来自相同集合的顶点不相连。其边数为$\sum_{i&lt;j}m_im_j=\frac{1}{2}\sum_{i\neq j}m_im_j$</p><p>这些图生成完全图$K_n=\underbrace{K_1,…,1}_n$</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210321201445.png" alt="K5及K33图" style="zoom: 25%;"></p><p>当$n$为基数时，$K_n$有欧拉回路</p><p>当m和n都为偶数时，$K_{m,n}$有欧拉回路</p><p>当$p+q,p+r,q+r$全部为偶数时，或者说$p,q,r$同基或同偶时，$K_{p,q,r}$有欧拉回路</p><h3 id="顶点遍历"><a href="#顶点遍历" class="headerlink" title="顶点遍历"></a>顶点遍历</h3><p><strong>哈密顿路径（Hamiltonian path ）</strong>：访问每一个顶点一次</p><p><strong>哈密顿回路（Hamiltonian circuit）</strong>：除了最后一个顶点，访问每一个顶点一次，最后回到初始顶点</p><p>找到这个回路或证明它不存在很难——最坏的情况是NP完全问题</p><p>这两种情况下，存在哈密顿回路：对于$m\ge3$，$K_m$；如果$m=n且m,n\ge2时，K_{m,n}$</p><p>对于$K_{n,n}$图，一共有$c=2(n!)^2$个哈密顿回路。</p><p>没有什么明显的方法可以确定非平凡的图没有哈密顿回路。</p><p>相反，如果给定一个回路，就可以立即验证它是否是哈密顿回路。</p><h3 id="着色-Colouring"><a href="#着色-Colouring" class="headerlink" title="着色 Colouring"></a>着色 Colouring</h3><p>非正式用法：为每个顶点（例如电力网络或交通网络中的一个节点）指定一个“颜色”，使由一条边连接的顶点具有不同的颜色。</p><p>正式：映射$c： V→[1…n]$，对每个$e = {v,w}\in E$</p><script type="math/tex; mode=display">c(v)\neq c(w)</script><p>足以实现这种映射的最小$n$称为图$G = (E, V)$的色数，用$χ(G)$表示。</p><h3 id="色数的性质-Properties-of-the-Chromatic-Number"><a href="#色数的性质-Properties-of-the-Chromatic-Number" class="headerlink" title="色数的性质 Properties of the Chromatic Number"></a>色数的性质 Properties of the Chromatic Number</h3><script type="math/tex; mode=display">χ(K_n) = n</script><p>如果$G$有$n$个顶点，且$χ(G) = n$，那么$G = K_n$</p><p>如果$χ(G) = 1$那么$G$是完全不连通的，它有0条边</p><p>如果$χ(G) = 2\ G$是二部图</p><p>对于任意树$χ(T) = 2$</p><p>对于任何循环$C_n$，它的色数取决于$n$的奇偶性，对于当$n$为偶数时，$χ(C_n) = 2$，而当$n$为奇数时，$χ(C_n) = 3$</p><h3 id="团-Cliques"><a href="#团-Cliques" class="headerlink" title="团 Cliques"></a>团 Cliques</h3><p>图$(V’,E’)$是图$(V,E)$的子集，其中$V’ \subseteq V$且$E’ \subseteq E$</p><p><strong>团（clique）</strong>是G的完全子图。含有k个节点的团被称为k-团</p><p>最大的团数被称为图的团数，记作$\kappa(G)$</p><p>$\chi(G)\ge\kappa(G)$</p><p>然而，这是唯一的限制。对于任意给定的$k$，都存在$κ(G) = k$的图，而$χ(G)$可以任意大。</p><ul><li><p>$\kappa(K_n)=n,\kappa(K_{m,n})=2,\kappa(K_{m_1,…,m_r})=r$</p></li><li><p>如果$\kappa(G)=1$，那么$G$是完全非连接的</p></li><li>对于树$\kappa(T)=2$</li><li>对于回路$C_n$，$\kappa(C_3)=3$，$\kappa(C_4)=\kappa(C_5)=…=2$</li></ul><p>$\kappa(G)$与$\chi(G)$的差异是显然的，仅当$\kappa(G)=2$，这不意味着G是双边的。例如，环路$C_n$对每个基数n有$\chi(C_n)=3$</p><p>对于无向图，有$max_{v\in V}deg(v)+1\ge \chi(G) \ge \kappa(G)$</p><h3 id="平面图形-Planar-Graphs"><a href="#平面图形-Planar-Graphs" class="headerlink" title="平面图形 Planar Graphs"></a>平面图形 Planar Graphs</h3><p>如果一个图的各边不相交而能嵌入一个平面中，则该图是<strong>平面的（Planar）</strong>。</p><p>定理：如果图形是平面的，它可以嵌入一个平面（无自交），使其所有边都是直线。</p><p>两个最小的非平面图为：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210321214830.png" alt="K5和K33非平面图" style="zoom:33%;"></p><p>如果图$G$作为子图包含一个非平面图，则$G$本身是非平面的。</p><p>一个图的次要部分是指通过反复删除顶点、删除边和合并相邻顶点而得到的任何图。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210321215220.png" alt="image-20210321215219961" style="zoom:33%;"></p><p>如果一个图包含$K_5$或$K_{3,3}$为副图，它就是非平面的。</p><p>$n\ge5$时，$K_n$是非平面的。</p><p>当$m≥3$且$n≥3$时，$K_{m,n}$是非平面的。</p><p>所有的$K_{m,1}$，$K_{m,2}$  都是平面的。同样的 ，对于k部图，$K_{2,2,2}$，$K_{1,1,m}$是平面图。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>图Graphs, 树trees, 顶点的度vertex degree, 连通图connected graphs, 连通组成connected components, 通路paths, 回路cycles $C_n$</p><p>图同构Graph isomorphisms, 自同构automorphisms</p><p>特殊图Special graphs: 完全图complete $K_n$, 完全双边图complete bi-, k部图k-partite $K_{m_1,\cdots,m_k}$</p><p>遍历Traversals</p><p>欧拉通路和回路Euler paths and circuits (边遍历edge traversal)</p><p>汉密尔顿通路和回路Hamiltonian paths and circuits (点遍历vertex traversal)</p><p>图形特点Graph properties</p><p>着色数chromatic number $(G)$, 团数clique number $κ(G)$, 平面化planarity</p><blockquote><p><strong>参考资料</strong></p><p>Textbook (R &amp; W) - Ch. 3, Sec. 3.2; Ch. 6. Sec. 6.1-6.5</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9020 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 离散数学 </tag>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础实践记录（3）</title>
      <link href="/2021/03/18/unsw/comp9311/shu-ju-ku-ji-chu-shi-jian-ji-lu-3/"/>
      <url>/2021/03/18/unsw/comp9311/shu-ju-ku-ji-chu-shi-jian-ji-lu-3/</url>
      
        <content type="html"><![CDATA[<h2 id="实践目标"><a href="#实践目标" class="headerlink" title="实践目标"></a>实践目标</h2><ul><li>对一个相对简单的模式进行SQL查询</li><li>使用SQL聚合和分组操作符</li><li>编写SQL视图定义</li></ul><p><a href="http://www.postgresql.org/docs/9.3/interactive/index.html">PostgreSQL用户手册</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Web服务器的访问日志可能包含以下关键信息：</p><ul><li>发出页面请求的主机的IP地址</li><li>提出请求的确切日期/时间</li><li>请求的URL（相对于服务器文档根目录的路径名）</li><li>获取操作的状态（例如，200 =成功，404 =未找到）</li><li>传输到请求者的数据的字节数</li></ul><p>下面是一段日志样例：</p><pre class="line-numbers language-none"><code class="language-none">60.240.97.148 - - [01/Mar/2005:00:00:00 +1100] "GET /webcms/intro/view_intro.phtml?cid=845&amp;color=%23DEB887 HTTP/1.1" 200 34260.240.97.148 - - [01/Mar/2005:00:00:03 +1100] "GET /webcms/notice/view_notice.phtml?cid=845&amp;color=%23DEB887&amp;state=view HTTP/1.1" 200 364260.229.57.188 - - [01/Mar/2005:00:00:06 +1100] "GET /webcms/creation/index.phtml?tid=000000124004 HTTP/1.1" 200 88160.229.57.188 - - [01/Mar/2005:00:00:06 +1100] "GET /webcms/login/invalid.phtml HTTP/1.1" 200 140160.229.57.188 - - [01/Mar/2005:00:00:07 +1100] "GET /webcms/login/login.phtml HTTP/1.1" 200 488360.229.57.188 - - [01/Mar/2005:00:00:09 +1100] "POST /webcms/login/log_in.phtml HTTP/1.1" 302 560.229.57.188 - - [01/Mar/2005:00:00:09 +1100] "GET /webcms/creation/index.phtml?tid=000000124013 HTTP/1.1" 200 72060.229.57.188 - - [01/Mar/2005:00:00:09 +1100] "GET /webcms/creation/menu.phtml?tid=000000124013 HTTP/1.1" 200 189860.229.57.188 - - [01/Mar/2005:00:00:10 +1100] "GET /webcms/creation/welcome.phtml?tid=000000124013 HTTP/1.1" 200 548760.229.57.188 - - [01/Mar/2005:00:00:12 +1100] "GET /webcms/course/index.phtml?tid=000000124013&amp;cid=860 HTTP/1.1" 200 806<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一些基于Web的应用程序，如WebCMS，在用户与Web服务器的交互中引入了会话（Session）的概念。用户的所有操作信息会记录至日志中，因此，可以通过查找使用相同会话标识符的所有页面访问来跟踪单个用户对系统的访问。</p><p>假设我们想要找出人们在使用WebCMS的会话中所做的典型事情。可以猜到他们做了一些事：他们会查看布告栏，看看有没有新的课堂讲稿，阅读现有的实践练习，等等。这些信息可以帮助我们了解用户习惯，调优系统性能等等。</p><p>为了方便，可以先把数据都加载到关系数据库系统中，所以第一步是将包含关键信息的Web日志数据导入到关系模式中。由此，可以定义一个数据库模式来表示来自WebCMS web日志的数据：</p><ul><li>各种主机的IP地址和名称</li><li>关于使用WebCMS的每个会话的信息，包括它来自哪个主机，以及用户是否实际通过WebCMS登出页面登出（如果他们不登出，他们的会话最终会超时）</li><li>每个单独页面访问的详细信息，包括脚本的名称、参数、访问时间和访问所涉及的会话</li></ul><p>使用如下ER图：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210318211711.png" alt="ER图"></p><p>将此图转换为关系模式为：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create table Hosts (id          integer,ipaddr      varchar(20) unique,hostname    varchar(100),primary key (id));create table Sessions (id          int, host        integer,complete    boolean,primary key (id),foreign key (host) references Hosts(id));create table Accesses (session     int,seq         int,course      int,page        varchar(200),params      varchar(200),accTime     timestamp,nbytes      integer,primary key (session,seq),foreign key (session) references Sessions(id));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先已将某服务3天的日志准备好，同时也转换为了SQL文件。每个文件里现在都包含了大量的插入语句。</p><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">-rw-r--r--  1 YOU  YOU  5568874 31 Mar 16:58 Accesses.sql-rw-r--r--  1 YOU  YOU   172536 31 Mar 16:09 Hosts.sql-rw-r--r--  1 YOU  YOU   193407 31 Mar 21:03 Sessions.sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这些文件比较大，一般不会存储在本地，或者服务器的根目录下。</p><p>本次练习中，可以把他们放在自己的/srvr/YOU/目录下。</p><p>需要注意，自己的目录空间也是有限的，当出现磁盘不足提示时，就需要自己清理一些之前的无用文件。</p><p>构建数据库表结构的模式副本和模板文件<a href="https://www.cse.unsw.edu.au/~cs9311/21T1/lab/04/weblog.zip">模板文件</a>也已经准备好：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-rw-r--r--  1 YOU  YOU      657 31 Mar 16:10 schema.sql-rw-r--r--  1 YOU  YOU     2243 31 Mar 16:11 weblog.sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下载好这个文件后，为这次练习创建一个单独的目录，然后使用此命令解压文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">unzip weblog.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是在家练习，可以下载此文件：<a href="https://www.cse.unsw.edu.au/~cs9311/21T1/lab/04/weblog.zip">weblog.zip</a></p><h3 id="设置PostgreSQL数据库"><a href="#设置PostgreSQL数据库" class="headerlink" title="设置PostgreSQL数据库"></a>设置PostgreSQL数据库</h3><p>通过以下命令可以建立一个PostgreSQL数据库：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">% createdb weblogCREATE DATABASE% psql weblog -f schema.sql  ... should produce CREATE TABLE messages ...% psql weblog -f Hosts.sql  ... should produce lots of INSERT messages ...% psql weblog -f Sessions.sql  ... should produce lots of INSERT messages ...% psql weblog -f Accesses.sql  ... should produce lots of INSERT messages ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>导入数据时，会显示大量的<code>INSERT 0 1</code>，其中0表示没有生成唯一ID，1表示插入了1条数据。</p><p>另外一种导入数据的方式为：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">% createdb weblogCREATE DATABASE% psql weblogpsql (9.0.3)Type "help" for help.weblog=#  \i schema.sqlCREATE TABLECREATE TABLECREATE TABLEweblog=#  \i Hosts.sql... should produce lots of INSERT messages ...weblog=#  \i Sessions.sql... should produce lots of INSERT messages ...weblog=#  \i Accesses.sql... should produce lots of INSERT messages ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在导入数据时，不想查看这样全部的INSERT信息，在Linux或Mac OS系统下，可以按如下方式操作：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">% createdb weblogCREATE DATABASE% psql weblog -f schema.sql  ... should produce CREATE TABLE messages ...% (psql weblog -f Hosts.sql 2&gt;&amp;1) &gt; .errs  ... INSERT messages are added to file .errs ...% (psql weblog -f Sessions.sql 2&gt;&amp;1) &gt;&gt; .errs  ... INSERT messages are added to file .errs ...% (psql weblog -f Accesses.sql 2&gt;&amp;1) &gt;&gt; .errs  ... INSERT messages are added to file .errs ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，<code>&gt;</code>符号表示新增文件，<code>&gt;&gt;</code>符号表示追加信息至文件末尾，</p><p>通过以下命令，可以在.errs文件中查找ERROR信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">grep ERROR .errs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当全部数据载入完毕后，通过psql进行检查：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">% psql weblogpsql (9.0.3)Type "help" for help.weblog=# \dweblog=# select count(*) from hosts;weblog=# select count(*) from sessions;weblog=# select count(*) from accesses;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于数据量较大，因此执行SQL语句查询时可能耗时过长。可以通过以下命令开启计时功能：</p><pre class="line-numbers language-none"><code class="language-none">\timing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外，当你第一次对新建立的表做查询时，可能会耗时较长；当再次查询时，速度会快很多。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>从现在开始，你需要生成SQL语句来检索一些问题。为了简化操作，<a href="https://www.cse.unsw.edu.au/~cs9311/21T1/lab/04/weblog.sql">SQL模板文件</a>可以使用。</p><h3 id="PostgreSQL查询"><a href="#PostgreSQL查询" class="headerlink" title="PostgreSQL查询"></a>PostgreSQL查询</h3><blockquote><p>注：参考答案文件见文末</p></blockquote><p>问题1： 3月2日有多少次页面访问？</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select count(*) from accesses where acctime &gt;= '2005-03-02 00:00:00' and acctime &lt;='2005-03-02 24:00:00';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>问题2：有多少次使用了留言板搜索工具?<br></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select count(*) from accesses where page like 'messageboard%' and params like '%=search%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p>问题3：在哪个Tuba lab machines上有不完整的session?<br></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select distinct h.hostnamefrom   Hosts h, Sessions swhere  h.hostname like 'tuba%cse.unsw.edu.au' and s.host=h.idand not s.complete;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>问题4：在页面访问中传输的min,avg,max字节数<br></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select min(nbytes),avg(nbytes)::integer,max(nbytes)from   Accesses;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><p>问题5：CSE主机会话数<br></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create or replace view CSEHosts asselect *from   Hostswhere  hostname like '%cse.unsw.edu.au';select count(*)from   Sessions s, CSEHosts cwhere  s.host = c.id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>问题6：非CSE主机会话数<br></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create or replace view nonCSEHosts asselect *from   Hostswhere  hostname not like '%cse.unsw.edu.au';select count(*)from   Sessions s, nonCSEHosts cwhere  s.host = c.id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>问题7：在最长的会话中有多少个页面访问（页面访问的次数）?<br></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create or replace view sessLength asselect session,count(*) as lengthfrom   Accessesgroup by session;select session,lengthfrom   sessLengthwhere  length = (select max(length) from sessLength);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>问题8：给出页面访问频率，并排序<br></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select page,count(*)from   Accessesgroup by pageorder by count(*) desc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>问题9：模块访问频率<br></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create or replace view ModuleAccess asselect session, seq, substring(page from '^[^/]+') as modulefrom   Accesses;select module,count(*)from   ModuleAccessgroup by moduleorder by count(*) desc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>问题10：没有页面访问的”会话“<br></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select idfrom   Sessions swhere  not exists (select * from Accesses where session=s.id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><p><a href="[[Solution\]](https://www.cse.unsw.edu.au/~cs9311/21T1/lab/04/week5.sql">参考答案</a>)</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9311 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 实践操作 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础课程笔记（6）</title>
      <link href="/2021/03/16/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-6/"/>
      <url>/2021/03/16/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-6/</url>
      
        <content type="html"><![CDATA[<h2 id="关系数据库设计"><a href="#关系数据库设计" class="headerlink" title="关系数据库设计"></a>关系数据库设计</h2><p>通过分解关系设计，直到它们处于标准的形式，可以将异常从关系设计中移除。</p><p>关于分解，应该研究几个问题。</p><p>关系方案$R$的分解是一组关系方案$\{R_1，…，R_n\}$，使每个$i$符合$R_i \subseteq R$，且$\cup_{i=1}^{n}R_i=R$</p><p>注意，在一个分解${R_1，…R_n}$中，每一对$R_i$和$R_j$的交集不一为空。</p><p><strong>例</strong>：</p><p>$R=\{A,B,C,D,E\},R_1=\{A,B\},R_2=\{A,C\},R_3=\{C,D,E\}$</p><p>朴素分解：每个关系只有一个属性。</p><p>一个好的分解应该有以下两个特性。</p><p><strong>定义</strong>：当$F^+ = G^+$时，FD的两个集合F和G等价。</p><p>给定一个分解$R$为$\{R_1, . . . ,R_n\}$</p><script type="math/tex; mode=display">F_i=\{X\rightarrow Y: X \rightarrow Y \in F \& X \in R_i,Y\in R_i\}</script><p>分解$R\{R_1，…R_n\}$，使其对$F$保持依赖</p><script type="math/tex; mode=display">F^+=(\cup_{i=1}^{i=n}F_i)^+</script><p><strong>例</strong>1：</p><p>设$F = \{ A \rightarrow BC, D \rightarrow EG, M \rightarrow A \}, R = (A, B, C, D, E, G, M)$</p><p>1） 给定$R_1=\{A,B,C,M\}$，$R_2=\{C,D,E,G\}$，</p><p>$F_1 = \{A \rightarrow BC, M \rightarrow A \}$，$F_2 = \{ D\rightarrow EG\}$</p><p>$F=F_1 \cup F_2$，因此，依赖保留</p><p>2）假设$F’=F \cup \{M \rightarrow D\}$。</p><p>$R_1$和$R_2$与1）相同，$F_1$和$F_2$也与1）相同。</p><p>我们需要确认$M\rightarrow D$是否可以由$F_1\cup F_2$推出。</p><p>当$M^+ |_{F_1 \cup F_2}=\{M,A,B,C \}$，$M \rightarrow D$不能由$F_1 \cup F_2$推出</p><p>因此，$R_1$和$R_2$没有保留$F’$的依赖关系</p><p>3）$F’’ =\{ A \rightarrow BC, D \rightarrow EG, M \rightarrow A , M\rightarrow C, C\rightarrow D, M\rightarrow D\} $</p><p>$F_1 = \{A \rightarrow BC, M\rightarrow A, M\rightarrow C\}, F2  = \{D\rightarrow EG, C\rightarrow D\}$</p><p>可以证明$M\rightarrow D$可以由$F_1$和$F_2$推出</p><p>由此，$F’’^+ = (F_1 \cup F_2)^+$</p><p>因此，$R_1$和$R_2$对$F’’$保持依赖关系</p><h2 id="无损连接分解"><a href="#无损连接分解" class="headerlink" title="无损连接分解"></a>无损连接分解</h2><p>分解的第二个必要属性：</p><p>如果对于每个满足F的关系实例r，一个分解$R\{R_1，…，R_n\}$是对FD的集合F的<strong>无损连接分解</strong>（lossless join）：</p><script type="math/tex; mode=display">r=\pi R_1(r)\Join\dots\Join\pi R_n(r)</script><p>如果$r\subset \pi R_1(r)\Join\dots\Join\pi R_n(r)$，那么分解是<strong>有损的</strong>（lossy）。</p><p><strong>例2</strong>：</p><p>假设需要分解以下关系：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210316170638.png" alt="image-20210316170638673" style="zoom:33%;"></p><p>与依赖关系 $\{Name→Department, Name→Advisor, Advisor→Department\}$</p><p>将上表分为两个关系：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210316170657.png" alt="image-20210316170657465" style="zoom: 25%;"></p><p>如果我们把这些分解的关系连接起来，则有：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210316170839.png" alt="image-20210316170839598" style="zoom: 33%;"></p><p>这与原始关系不同(添加了带有*标记的元组)。因此分解是<strong>有损的</strong>（lossy）。</p><p><strong>定理</strong>：如果普通属性$R_1\cap R_2$构成$R_1$或$R_2$的超键，则$R$的分解$\{R_1,R_2\}$是无损的。</p><p><strong>例3</strong>：给定$R(A,B,C)$和$F = \{A→B\}$。因为$A→B$是$R_1$上的FD，所以分解为$R_1(A,B)$和$R_2(A,C)$是无损的。所以一般属性$A$是$R_1$的键。</p><h3 id="测试无损连接属性"><a href="#测试无损连接属性" class="headerlink" title="测试无损连接属性"></a>测试无损连接属性</h3><p><strong>TEST_LJ算法</strong></p><p>步骤1：创建一个矩阵$S$，每个元素$s_{i,j}∈S$对应关系$R_i$和属性$A_j$，使：</p><script type="math/tex; mode=display">s_{j,i} = a \text{如果} A_i∈ R_j, \text{否则} s_{j,i} = b</script><p>步骤2：重复下面的过程，直到$S$没有变化，或者有一行完全由“a”符号组成</p><p>步骤2.1：对于每个$X→Y$，选择与$X$对应的元素取值为a的行</p><p>步骤2.2：在那些选择的行中（必须至少有两行），如果其中一个选择的行在Y上取值a，那么对应于Y的元素也取值a</p><p>如果一行完全由“a”值组成，则分解是无损的。</p><p>（该算法可以在E/N书中找到——算法15.2）</p><p><strong>注意</strong>：本算法的正确性是基于此假设：Join属性不允许有空值。</p><p>当且仅当存在一个令$R_i\cap M_{i-1}$形式的顺序，$R_i$或$M_{i-1}$的超键，其中$M_{i-1}$是$R_1, R_2,\dots ,R_{i-1}$的结合</p><p><strong>例1</strong>：</p><p>$R = (A,B,C,D), F = \{A→B,A →C,C → D\}$</p><p>令$R_1 = (A,B,C), R_2 = (C,D)$</p><p>最初，$S$为</p><script type="math/tex; mode=display">\begin{array}{}  & A & B & C & D \\ R_1 & a & a & a & b \\ R_2 & b & b & a & a \end{array}</script><p>注意，$S$的第1行和第2行与$\{C\}$一致，即$C→D$的左手边。因此，改变第一行的D值为a，匹配第2行中的值。</p><p>现在第一行完全是a，所以分解是无损的。</p><p><strong>例2</strong>：</p><p>$R = (A,B,C,D,E)$，$F = \{AB →CD,A → E,C → D\}$</p><p>令$R_1 = (A,B,C), R_2 = (B,C,D), R_3 = (C,D,E)$</p><p><strong>例3：</strong></p><p>$R = (A,B,C,D,E,G)$，$F = {A → B,C → DE,AB → G}$</p><p>令$R_1 = (A,B)$，$R_2 = (C,D,E)$，$R_3 = (A,C,G)$</p><p><strong>例4：</strong></p><p>$R = (A,B,C,D,E,G)$，$F = \{AB →G, C → DE, A → B\}$<br>令$R_1 = (A,B)$，$R_2 = (C, D, E)$ ，$R_3 = (A,C,G)$</p><script type="math/tex; mode=display">\begin{array}{}     & A & B & C & D & E & G\\ R_1 & a & a & b & b & b & b\\ R_2 & b & b & a & a & a & b\\ R_3 & a & b & a & b & b & a\\     &   &   &   &   &   &  \\     &   &   &   &   &   &\end{array}\quad\begin{array}{}     & A & B & C & D & E & G & \\ R_1 & a & a & b & b & b & b & \\ R_2 & b & b & a & a & a & b & \Leftarrow\\ R_3 & a & b & a & \not{b} & \not{b} & a & \Leftarrow \\     &   &   &   &  \uparrow & \uparrow & & \\     &   &   &   &  a        &  a       & & \end{array} \quad\begin{array}{}     & A & B & C & D & E & G & \\ R_1 & a & a & b & b & b & b & \Leftarrow\\ R_2 & b & b & a & a & a & b & \\ R_3 & a & \not{b} & a & a & a & a & \Leftarrow \\     &   & \uparrow &  &   &   & & \\     &   & a &     &   &   &   & &\end{array}</script><h2 id="无损分解为BCNF"><a href="#无损分解为BCNF" class="headerlink" title="无损分解为BCNF"></a>无损分解为BCNF</h2><p><strong>TO_BCNF算法</strong>：</p><p>$D := {R_1,R_2, …R_n}$</p><p><strong>While</strong> $\exists a\ R_i\in D$，且$R_i$不在BCNF <strong>DO</strong></p><p>​    在$R_i$查找违反BCNF的$X\rightarrow Y$</p><p>​    用$(R_i-Y)$和$(X \cup Y)$替换$D$中的$R_i$</p><p><strong>例</strong>：</p><p>$F=\{A\rightarrow B,A\rightarrow C,A\rightarrow D,C\rightarrow E,E\rightarrow D,C\rightarrow G\}$，</p><p>$R_1=(C,D,E,G)$，$R_2=(A,B,C,D)$</p><p>$R_{11}=\{C,E,G\}$，$R_{12}=(E,D)$根据$E\rightarrow D$</p><p>$R_{21}=(A,B,C)$，$R_{22}=(C,D)$由于$C\rightarrow D$</p><p>因为违反BCNF的$X\rightarrow Y$并不总是在$F$中，主要的难点是验证$R_i$是否在BCNF中；</p><p>见下面的方法：</p><ol><li>对每个$R_i$的子集$X$，计算$X^+$</li><li>如果$ X^+|_{R_i}-X \neq \emptyset$且$R_i - X^+\neq \emptyset $ ,$X\rightarrow (X^+|_{R_i}-X)$违反BCNF</li></ol><p>这里，$ X^+|_{R_i}-X \neq \emptyset$意味着每个包含$X$的FD作为左半部分是平凡的（trivial）</p><p>$R_i - X^+\neq \emptyset $意味着$X$是$R_i$的一个超键</p><p><strong>例</strong>：</p><p>找到下面关系方案的BCNF分解</p><p>SHIPPING(Ship , Capacity , Date , Cargo , Value)<br>$F$为：<br>    Ship$→$ Capacity<br>    {Ship , Date}$→$ Cargo<br>    {Cargo , Capacity}$→$ Value</p><p>根据$Ship→ Capacity$，将$SHIPPING$分解为</p><p>$R_1$(Ship, Date, Cargo, Value)​</p><p>键：{Ship, Date}​</p><p>在$F^+$中的非平凡FD违反BCNF：</p><p>{Ship,Cargo\}\rightarrow$ Value</p><p>且</p><p>$R_2$(Ship,Capacity)​</p><p>键：{Ship}​</p><p>$F^+$只有一个非平凡FD：Ship$\rightarrow$ Capacity</p><p>$R_1$不在BCNF所以必须将它再次分解为</p><p>$R_{11}$(Ship,Date,Cargo)​</p><p>键：{Ship, Date}​</p><p>在右侧，$F^+$上只有一个包含单一属性的非平凡FD：{Ship, Date}$\rightarrow$ Cargo</p><p>且</p><p>$R_{12}$(Ship,Cargo,Value)</p><p>键：{Ship,Cargo}​</p><p>在右侧$F^+$上只有一个具有单一属性的非平凡FD：{Ship,Cargo}$\rightarrow$ Value</p><p>这在BCNF中，分解是无损的，但是没有保护依赖，FD{Capacity, Cargo}$\rightarrow$ Value丢失了</p><p>或者，可以选择{Cargo, Capacity}$\rightarrow$ Value，这可以得到：</p><p>$R_1$ (Ship , Capacity , Date , Cargo)​</p><p>键：{Ship,Date}​</p><p>$F^+$上一个非平凡FD违反BCNF：</p><p>Ship$\rightarrow$ Capacity</p><p>且</p><p>$R_2$(Cargo, Capacity, Value)​</p><p>键：{Cargo, Capacity}​</p><p>在右侧$F^+$上只有一个具有单一属性的非平凡FD：{Cargo,Capacity}$\rightarrow$ Value​</p><p>再根据Ship$\rightarrow$  Capacity​</p><p>$R_{11}$ (Ship , Date , Cargo)​<br>键：{Ship,Date\}​</p><p>在右侧$F^+$上只有一个具有单一属性的非平凡FD：{Ship , Date\}$ \rightarrow$ Cargo</p><p>且</p><p>$R_{12}$(Ship, Capacity)​</p><p>键：{Ship}</p><p>$F^+$上只有一个非平凡FD：Ship$ \rightarrow$ Capacity</p><p>且</p><p>$R_{12}$(Ship,Capacity)​</p><p>键：{Ship}​</p><p>$F^+$上只有一个非平凡FD：Ship $\rightarrow$ Capacity</p><p>这符合BCNF，而且分解即无损又保留依赖关系。</p><p>然而，有一些关系方案分解为BCNF后，没有无损、保持依赖关系的方法。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210316201403.png" alt="image-20210316201403853" style="zoom:25%;"></p><h2 id="无损和保持依赖分解为3NF"><a href="#无损和保持依赖分解为3NF" class="headerlink" title="无损和保持依赖分解为3NF"></a>无损和保持依赖分解为3NF</h2><p>具有任何$F$的任何$R$都可以无损且保持依赖关系的分解为3NF。</p><p>需要更多关于FD的定义。</p><p>FD的集合$F$是最小的，如果：</p><ol><li>每个$F$上的FD$X \rightarrow Y$是朴素的：$Y$由一个单一属性构成</li><li>每个$F$上的FD$X \rightarrow Y$是左减的（left-reduced）：没有恰当的子集$Y \subset X$使$X \rightarrow A$可以被替换为$Y\rightarrow A$，即，没有$Y \subset X$使$((F-\{X \rightarrow A\})\cup \{Y\rightarrow  A\})^+ = F^+$</li><li>没有FD可以被移除；没有F上的FD$X\rightarrow A$使$(F=\{X\rightarrow A\})^+=F^+$</li></ol><h3 id="计算最小覆盖"><a href="#计算最小覆盖" class="headerlink" title="计算最小覆盖"></a>计算最小覆盖</h3><p>F是FD的集合。</p><p>F的最小覆盖（或规范覆盖）是FD的$F_{min}$的最小集合，使$F^+=F^+_{min}$</p><p><strong>Min_Cover算法</strong></p><p>输入：F的函数依赖集合</p><p>输出：F的最小覆盖</p><p>步骤1：减少右侧。使用算法减少右侧至F</p><p>步骤2：减少左侧。适应算法减少左侧至步骤2的输出</p><p>步骤3：减少多余的FD。使用算法减少多余的依赖至步骤2的输出。输出结果是最小覆盖。</p><p>这3个步骤的详细算法为：</p><p><strong>算法减少右侧：</strong></p><p>输入：$F$</p><p>输出：右侧减少后的$F’$</p><p>对每个FD$X\rightarrow Y \in F$，其中$Y=\{A_1,A_2,…,A_k\}$，使用所有$X\rightarrow \{A_i\}(1\leq i \leq k)$来替换$X\rightarrow Y$</p><p><strong>算法减少左侧</strong>：</p><p>输入：减少后的右侧$F$</p><p>输出：右侧和左侧减少后的$F’$</p><p>对每个$X \rightarrow \{A\} \in F$，其中$X=\{A_i:1\leq i \leq K\}$，按以下操作：使i从1到k，如果$A\in (X-\{A_I\})^+$用$X-\{A_i\}$替换$X$</p><p><strong>算法减少多余</strong>：</p><p>输入：右侧和左侧减少后的$F$</p><p>输出：$F$的最小覆盖$F’$</p><p>对每个FD$X\rightarrow \{A\}\in F$，如果$A \in X^+$对于$F-\{X\rightarrow \{A\}\}$，将它从$F$移除</p><p><strong>例</strong>：</p><p>$R = (A, B, C, D, E, G)$<br>$F = \{A \rightarrow  BCD,  B  \rightarrow CDE, AC \rightarrow  E\}$</p><p>步骤1：</p><p>$F’ = \{A \rightarrow  B, A\rightarrow C, A \rightarrow  D, B\rightarrow  C, B\rightarrow  D, B\rightarrow  E, AC \rightarrow  E\}$</p><p>步骤2：</p><p>$AC\rightarrow E\quad C^+=\{C\}$</p><p>故由$F’$不能得出$C\rightarrow E$</p><p>因此，$AC\rightarrow E$不能替换为$A \rightarrow  E$</p><p>$A^+=\{A,B,C,D,E\}$，故由$F’$可得出$A\rightarrow E$</p><p>因此，$AC\rightarrow E$可以被替换为$A\rightarrow E$</p><p>$F’’ = \{A\rightarrow  B, A\rightarrow C, A\rightarrow  D, A\rightarrow  E, B\rightarrow C, B\rightarrow D, B\rightarrow  E\}$</p><p>步骤3：</p><p>$A^+|_{F’’ – \{A \rightarrow  B\}}= \{A, C, D, E\}$</p><p>故，由$F’’=\{A\rightarrow B\}$不能得出$A\rightarrow B$</p><p>所以$A\rightarrow B$是多余的</p><p>$A^+|F’’ – {A \rightarrow  C}= \{A, B, C, D, E\}$，故$A\rightarrow C$是多余的</p><p>故，将$A\rightarrow C$从$F’’$移除，变为$F’’’$</p><p>重复这个操作，可以得到$A\rightarrow D$和$A \rightarrow E$</p><p>故，$F_{min}=\{A\rightarrow  B, B\rightarrow  C, B\rightarrow  D, B\rightarrow E\}$</p><h2 id="3NF分解算法"><a href="#3NF分解算法" class="headerlink" title="3NF分解算法"></a>3NF分解算法</h2><p><strong>3NF的分解算法</strong></p><ol><li><p>求$F$的最小覆盖$F’$</p></li><li><p>对每一个在$F’$中出现的$X$，做：</p></li></ol><p>创建关系模式$X\cup A_1 \cup A_2 … \cup A_m$，其中$X\rightarrow \{A_1\},…,X\rightarrow \{A_m\}$全部为左侧$X$的$F’$的依赖</p><ol><li>如果关系模式均不包含$R$的键，建立一个对$R$键包含属性的多关系模式</li></ol><p><strong>例</strong>：</p><p>$R = (A, B, C, D, E, G)$<br>$F_{min}=\{A\rightarrow B, B\rightarrow C, B\rightarrow D, B\rightarrow E\}.$<br>候选键： $(A, G)$<br>$R_1 = (A, B), R_2 = (B, C, D, E)$<br>$R_3 = (A, G)$</p><p><strong>例</strong>：<br>还是从$SHIPPING$关系开始。函数依赖已经形成规范覆盖。</p><p>从$Ship→Capacity$，根据 $R_1(Ship,Capacity)$<br>从$\{Ship,Date\} → Cargo, derive$<br>$R_2(Ship , Date , Cargo)$<br>从 $\{Capacity,Cargo\} → Value, derive$<br>$R_3(Capacity , Cargo , Value)$<br>没有未包含的属性和原始键$\{Ship,Date\}$包含在$R_2$</p><p><strong>例</strong>：</p><p>将该算法应用到前面给出的LOTS中</p><p>最小覆盖为<br>$\{ Property_Id→Lot_No, Property_Id → Area, \{City,Lot_No\} → Property_Id, Area → Price, Area → City, City → Tax_Rate \}$</p><p>这可以分解为：<br>$R_1 (\underline{Property_Id} , Lot_No , Area)$<br>$R_2 (\underline{City , Lot_No} , Property_Id)$<br>$R_3 (\underline{Area} , Price , City)$<br>$R_4 (\underline{City} , Tax_Rate)$</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>数据冗余是不可取的，因为它们可能导致更新异常。</p><p>消除这种冗余的一种方法是在FD的指导下规范化设计。</p><p>BCNF根据FD删除所有多余属性，但不能总是找到保持依赖的分解</p><p>总是可以找到保持依赖关系，无损分解为3NF的方法，但一些冗余可能仍然存在</p><p>即使可以找到一个保留依赖关系的无损分解来删除所有冗余，出于效率的原因，可能也不可能删除所有冗余。</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9311 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础课程笔记（5）</title>
      <link href="/2021/03/16/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-5/"/>
      <url>/2021/03/16/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-5/</url>
      
        <content type="html"><![CDATA[<h2 id="关系数据库的范式"><a href="#关系数据库的范式" class="headerlink" title="关系数据库的范式"></a>关系数据库的范式</h2><p>优秀数据库设计的标准</p><p>通过函数(或其他)依赖形式化</p><h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h3><p>要求属性值是原子的，并且是关系模型定义的一部分。</p><p><strong>原子值</strong>：不允许多值属性、组合属性及其组合。</p><p>假设有如下表</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210316010754.png" alt="原始数据表" style="zoom: 67%;"></p><p>可以转化为:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210316010830.png" alt="1NF数据库表" style="zoom:67%;"></p><p>上图的表现存在以下缺点：</p><ul><li>一个教授在一个部门的信息可能重复</li><li>如果教授不教授课程，那么教授和部门之间的关系将没有记录</li><li>一个课程由某个部门提供，这个信息可能重复</li><li>如果没有人选课，那么课程和部门的信息就没有对应记录</li></ul><p>假设这些属性的FD是</p><script type="math/tex; mode=display">F = \{Prof →Fac\_Dept, Course → Crs\_Dept\}</script><p>注意，超键是一组这样的属性</p><script type="math/tex; mode=display">S → \{Prof,  Course,  Fac\_Dept, Crs\_Dept\} ∈ F^+</script><p>因此，这里唯一的候选关键字是$ \{Prof, Course\}$</p><p>产生这些问题，是因为$Fac_Dept$只取决于$Prof$而不取决于$Course$；同样，$Crs_Dept$只取决于$Course$而不取决于$Prof$。</p><p>我们可以使用函数依赖来识别和避免这些问题。</p><h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h3><p>主（prime）属性是候选键的一部分。其他属性均为非主属性。</p><p><strong>定义</strong>：在一个FD $X\rightarrow Y$中，如果没有$Z \subset X$使$Z \rightarrow Y$，那么$Y$是<strong>完全函数依赖</strong>于$X$（fully functionally dependent）的。否则$Y$部分依赖于$X$。</p><p><strong>定义</strong>（第二范式）：如果所有非主属性在功能上完全依赖于候选键，那么关系模式就是第二范式（2NF）。</p><p>如果数据库模式的所有关系都在2NF中，那么它就是在2NF中。</p><p>可能的2NF为：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210316012707.png" alt="2NF表结构" style="zoom:67%;"></p><p>问：什么关系代数表达式可以从这些关系中恢复$CRS_PREF$ ?</p><p>答：Join</p><p>2NF并没有完全消除我们之前看到的那些异常：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210316013448.png" alt="2NF仍未解决问题的表结构" style="zoom:67%;"></p><p>这符合2NF，但是：</p><p>如果另一个课程使用A532房间，那么A532的$Room_Cap$为45和$Enrol_Lmt$为40将存储两次。</p><p>如果删除了课程355，那么H940的$Room_Cap$为400，$enroll_lmt$为300就会丢失。</p><p>我们也可以通过增加对函数依赖关系的进一步限制来解决这个问题。</p><h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h3><p><strong>定义：</strong>如果$Z$不是任何键的子集，使$X \rightarrow Z$且$Z \rightarrow Y$且$Z \not\rightarrow X$成立，那么一个FD $X\rightarrow Y$是一个传递依赖，</p><p>属性$Y$传递依赖于$X$。</p><p>例如， 当 {Course} → {Room} 且 {Room} → {Room_Cap} 成立，且 {Room} 不是任意键的子集时，Room_Cap 传递依赖于{Course}。</p><p><strong>定义（第三范式）</strong>：如果对所有形式为X→A的非平凡（non-trivial）FD成立，或者X是超键或A是素数属性，则关系模式是第三范式(3NF)。</p><p>注意：如果Y是X的子集，那么FD X→Y就是平凡的（trivial）。</p><p><strong>转换定义</strong>：如果每个非主属性在功能上完全依赖于键，而不是传递地依赖于任何键，那么关系模式就是第三范式。</p><p>如果数据库模式的所有关系都在3NF中，那么它就是在3NF中。</p><p>TEACHES可以分解为3NF：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210316014833.png" alt="3NF数据库表" style="zoom:67%;"></p><p>另一个例子：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210316014903.png" alt="新例子表结构" style="zoom:67%;"></p><p>这不符合2NF，因为 City→Tax_Rate, Tax_Rate 不是prime，且 {City,Lot_No} 是键，使 Tax_Rate 部分依赖于键。</p><p>可以这样解决这个问题：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210316015049.png" alt="新例子2NF表结构" style="zoom:67%;"></p><p>现在符合2NF，但没有符合3NF，因为 Area → Price, {Area} 不是一个超键，而且Price 不是 prime。</p><p>注意，传递依赖 Property_Id→ Area → Price</p><p>我们也可以解决这个问题：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210316015223.png" alt="新场子3NF表结构" style="zoom:67%;"></p><p>还假设 Area→City。关系模式仍在3NF中，因为 City 是一个prime属性。然而，像以前一样，可能还是会有异常存在。所以仍然需要更多的限制来解决这些问题。</p><h3 id="博伊斯-科德范式-Boyce-Codd-Normal-Form-BCNF"><a href="#博伊斯-科德范式-Boyce-Codd-Normal-Form-BCNF" class="headerlink" title="博伊斯-科德范式 Boyce-Codd Normal Form (BCNF)"></a>博伊斯-科德范式 Boyce-Codd Normal Form (BCNF)</h3><p><strong>定义</strong> (Boyce-Codd Normal Form)：当X→A成立且X→A非平凡时，X是超键，那么关系模式就在Boyce-Codd范式中。</p><p>如果一个数据库模式的所有关系都在BCNF中，那么它就是在BCNF中。</p><p>可以把例子变成BCNF：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210316015728.png" alt="BCNF方案一" style="zoom:67%;"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210316015843.png" alt="BCNF方案二" style="zoom:67%;"></p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9311 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础PLpgSQL</title>
      <link href="/2021/03/15/unsw/comp9311/shu-ju-ku-ji-chu-plpgsql/"/>
      <url>/2021/03/15/unsw/comp9311/shu-ju-ku-ji-chu-plpgsql/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL语言已经具有的特点"><a href="#SQL语言已经具有的特点" class="headerlink" title="SQL语言已经具有的特点"></a>SQL语言已经具有的特点</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>原子类型</strong>： integer, float, character, boolean </p><p>可定义元组类型</p><p>可自定义新类型</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 基本类型CREATE DOMAIN DomainName [ AS ] DataType[ DEFAULT expression ][ CONSTRAINT ConstrName constraint ]-- 元组类型CREATE TYPE TypeName AS( AttrName1 DataType1 , AttrName2 DataType2 , ...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 定义一个基本类型create domain UnswCourseCode as textcheck ( value ~ '[A-Z]{4}[0-9]{4}' );create table Course (id integer ,code UnswCourseCode ,...);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 定义一个元组类型create type ComplexNumber as ( r float , i float );create type CourseInfo as (course UnswCourseCode ,syllabus text ,lecturer text);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="PLpgSQL（Structured-Query-Language）"><a href="#PLpgSQL（Structured-Query-Language）" class="headerlink" title="PLpgSQL（Structured Query Language）"></a>PLpgSQL（Structured Query Language）</h2><p>PLpgSQL = <strong>P</strong>rocedural <strong>L</strong>anguage extensions to <strong>P</strong>ost<strong>g</strong>re<strong>SQL</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE PROCEDURE ProcName ( Params )[ local declarations ]procedure body ;CREATE FUNCTION FuncName ( Params )RETURNS Type[ local declarations ]function body ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，Params有三种模式： IN, OUT, INOUT</p><h3 id="PostgreSQL-函数定义"><a href="#PostgreSQL-函数定义" class="headerlink" title="PostgreSQL 函数定义"></a>PostgreSQL 函数定义</h3><p><strong>语法：</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE OR REPLACE FUNCTION funcName(arg1type, arg2type, ....)RETURNS rettypeAS $$ DECLARE variable declarations BEGIN code for function END; $$ LANGUAGE plpgsql;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create or replace function withdraw(acctNum text, amount integer)returns textas $$ declarebal integer; begin select balance into bal from Accounts where acctNo = acctNum; if (bal &lt; amount) then return 'Insufficient Funds'; else update Accounts set balance = balance - amount where acctNo = acctNum; select balance into bal from Accounts where acctNo = acctNum; return 'New Balance: ' || bal; end if; end; $$ language plpgsql;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例：</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 指定啤酒的最大价格create or replace function maxPrice(text) returns float as $$ select max(price) from Sells where beer = $1; $$ language sql;-- 使用方法select maxPrice('New'); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 指定地址查询包含的酒吧create or replace function hotelsIn(text) returns setof Bars as $$ select * from Bars where addr = $1; $$ language sql;-- 使用方法select * from hotelsIn('The Rocks'); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 老式函数定义CREATE OR REPLACE FUNCTION cat(text, text) RETURNS text AS $$DECLARE x alias for $1; -- alias for parameter y alias for $2; -- alias for parameter result text; -- local variable BEGIN result := x||''''''''||y; return result; END; $$ LANGUAGE 'plpgsql';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 新式函数定义CREATE OR REPLACE FUNCTION add(x text, y text) RETURNS text AS $$DECLARE result text; -- local variable BEGIN result := x||''''||y; return result; END; $$ LANGUAGE 'plpgsql';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例：</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE OR REPLACE FUNCTIONadd ( x anyelement , y anyelement ) RETURNS anyelementAS $$BEGINreturn x + y ;END ;$$ LANGUAGE plpgsql ;-- 限制：要求x和y具有相同的“可添加”类型的值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PlpgSQL允许重载</p><p><strong>例：</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE FUNCTION add ( int , int ) RETURNS int AS$$ BEGIN return $1 + $2 ; END ; $$ LANGUAGE plpgsql ;CREATE FUNCTION add ( int , int , int ) RETURNS int AS$$ BEGIN return $1 + $2 + $3 ; END ; $$ LANGUAGE plpgsql ;CREATE FUNCTION add ( char (1) , int ) RETURNS int AS$$ BEGIN return ascii ( $1 )+ $2 ; END ; $$ LANGUAGE plpgsql ;-- 但此时，不能再定义返回其他类型值的add ( char (1) , int )CREATE FUNCTION add ( char (1) , int ) RETURNS char AS$$ BEGIN return chr ( ascii ( $1 )+ $2 ); END ; $$ LANGUAGE plpgsql ;-- cannot have two functions that look like add(char(1), int).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PostgreSQL允许的返回值类型为：</p><ul><li><p>void</p></li><li><p>原子类型（integer, text,…）</p></li><li>元组（table record类型或元组类）</li><li>一组原子类型</li><li>一组元组</li></ul><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 创建不同类型的返回值的示例create type Employee as (id integer, name text, salary float, ...);create function factorial(integer) returns integer ... create function EmployeeOfMonth(date) returns Employee ... create function allSalaries() returns setof float ... create function OlderEmployees() returns setof Employee ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不同类型的函数有不同的调用方式：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select factorial(5); -- returns one integer select EmployeeOfMonth('2008-04-01'); -- returns (x,y,z,...) select * from EmployeeOfMonth('2008-04-01'); -- one-row table select * from allSalaries(); -- single-column table select * from OlderEmployees(); -- subset of Employees<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过几种方式调用PLpgSQL函数</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 作为 SELECT 的一部分select myFunction ( arg1 , arg2 );select * from myTableFunction ( arg1 , arg2 );-- 作为其他 PLpgSQL 的一部分PERFORM myVoidFunction ( arg1 , arg2 );result := myOtherFunction ( arg1 );-- 通过 insert/delete/update 触发器create trigger T before update on Rfor each row execute procedure myCheck ();-- 通过从现有的数据库表派生类型account Accounts % ROWTYPE ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量还可以按照以下方式定义：</p><ul><li>现有变量或表列的类型</li><li>现有表行类型（隐式记录类型）</li></ul><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">quantity INTEGER ;start_qty quantity % TYPE ;employee Employees % ROWTYPE ;name Employees.name % TYPE ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p><strong>语法：</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">variable := expression;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>例</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">tax := subtotal * 0.06; my_record.user_id := 20;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><p><strong>语法：</strong></p><p>IF … THEN<br>IF … THEN … ELSE<br>IF … THEN … ELSIF … THEN … ELSE</p><p><strong>例</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">IF v_user_id &gt; 0 THEN UPDATE users SET email = v_email WHERE user_id = v_user_id; END IF;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="LOOP循环"><a href="#LOOP循环" class="headerlink" title="LOOP循环"></a>LOOP循环</h4><p><strong>语法：</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">LOOPSatement END LOOP ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>例</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">LOOP IF count &gt; 0 THEN -- some computations END IF; END LOOP;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h4><p><strong>语法：</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">FOR int_var IN low .. high LOOPSatementEND LOOP ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>例</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">FOR i IN 1..10 LOOP -- i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop END LOOP;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="SELECT-…-INTO"><a href="#SELECT-…-INTO" class="headerlink" title="SELECT … INTO"></a>SELECT … INTO</h4><p>可以捕获查询结果</p><p><strong>语法：</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT Exp1 , Exp2 , ... , ExpnINTO Var1 , Var2 , ... , VarnFROM TableListWHERE Condition ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- cost 是本地变量, price 是一个字段/属性SELECT price INTO costFROM StockListWHERE item = ' Cricket Bat ';cost := cost * (1 + tax_rate );total := total + cost ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="异常-Exceptions"><a href="#异常-Exceptions" class="headerlink" title="异常 Exceptions"></a>异常 Exceptions</h4><p><strong>语法</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">BEGINStatements ...EXCEPTIONWHEN Exceptions1 THENStatementsForHandler1WHEN Exceptions2 THENStatementsForHandler2...END ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 表 T 包含一行数据 ( ' Tom ' , ' Jones ')DECLAREx INTEGER := 3;BEGINUPDATE T SET firstname = ' Joe ' WHERE lastname = ' Jones ';-- 此时表 T 包含的数据为 ( ' Joe ' , ' Jones ')x := x + 1;  y := x / y;  ---- y: = # Staff 表中的 Tom JonesEXCEPTIONWHEN division_by_zero THEN-- 更新表 T 回滚至 ( ' Tom ' , ' Jones ')RAISE NOTICE ' Caught division_by_zero ';RETURN x ;-- 返回值为 4END ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RAISE操作可以生成服务器日志</p><p>例：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">RAISE DEBUG ' Simple message ';RAISE NOTICE ' User = % ' , user_id ;RAISE EXCEPTION ' Fatal : value was % ' , value ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>日志级别有以下几种</p><ul><li>DEBUG, LOG, INFO, NOTICE, WARNING, EXCEPTION</li></ul><p>并不是所有级别的日志都会在客户端生成消息</p><h3 id="Cursors-游标"><a href="#Cursors-游标" class="headerlink" title="Cursors 游标"></a>Cursors 游标</h3><p>游标是一个变量，可用于访问特定SQL查询的结果</p><p>最简单的使用方法是在FOR … IN中使用</p><p><strong>例</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE FUNCTION totsal () RETURNS REAL AS $$DECLAREemp RECORD ;total REAL := 0;BEGINFOR emp IN SELECT * FROM EmployeesLOOPtotal := total + emp . salary ;END LOOP ;RETURN total ;END ; $$ LANGUAGE plpgsql ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以优化为</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE FUNCTION totsal () RETURNS REAL AS $$DECLAREtotal REAL ;BEGINSELECT sum ( salary ) INTO total FROM Employees ;return total ;END ; $$ LANGUAGE plpgsql ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>游标的基本操作为：OPEN, FETCH, CLOSE</p><p>例：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 假设 ... 游标 e 为 SELECT * FROM Employees ;OPEN e ;LOOPFETCH e INTO emp ;EXIT WHEN NOT FOUND ;total := total + emp.salary ;END LOOP ;CLOSE e ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>FETCH操作也可以提取一行的组件:</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">FETCH e INTO my_id , my_name , my_salary ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Triggers-触发器"><a href="#Triggers-触发器" class="headerlink" title="Triggers 触发器"></a>Triggers 触发器</h3><p>触发器是存储在数据库中的过程，在响应数据库事件（例如更新）时被激活。</p><p>触发器提供事件-条件-动作(ECA)编程：</p><p>事件在激活时激活触发器，触发器检查条件（如果条件成立），执行过程（操作）</p><p>两种INSERT的触发器为</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create trigger X before insert on T Code1; create trigger Y after insert on T Code2; insert into T values (a,b,c,...);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>两种UPDATE的触发器为</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create trigger X before update on T Code1; create trigger Y after update on T Code2; update T set b=j,c=k where a=m;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>语法</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TRIGGER TriggerName {AFTER|BEFORE} Event1 [OR Event2 ...] ON TableName [ WHEN ( Condition ) ] FOR EACH {ROW|STATEMENT} EXECUTE PROCEDURE FunctionName(args...);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数触发器</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE OR REPLACE FUNCTION name () RETURNS TRIGGER ..<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果有以下数据库表结构</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create table Person ( id integer primary key, ssn varchar(11) unique,... e.g. family, given, street, town ... state char(2), ... ); create table States ( id integer primary key, code char(2) unique, ... e.g. name, area, population, flag ... );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例：</strong>确保只使用有效的州代码</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 在为每一行的人插入或更新之前创建触发校验状态create function checkState() returns trigger as $$ begin -- 标准化用户提供的值new.state = upper(trim(new.state)); if (new.state !~ '^[A-Z][A-Z]$') then raise exception 'Code must be two alpha chars'; end if; -- 实现参照完整性检查select * from States where code=new.state; if (not found) then raise exception 'Invalid code %',new.state;end if; return new; end; $$ language plpgsql;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例：</strong>部门工资总额</p><p>现有表结构为：</p><p>Employee(id, name, address, dept, salary, …)<br>Department(id, name, manager, totSal, …)</p><p>我们希望：Department.totSal = (select sum(e.salary) from Employee e where e.dept = d.id) )</p><p>具体来说，可能有以下四种情况</p><ul><li>新员工入职</li><li>员工加薪</li><li>员工从一个部门跳槽到另一个部门</li><li>员工离开公司</li></ul><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 新员工入职create trigger TotalSalary1 after insert on Employees for each row execute procedure totalSalary1(); create function totalSalary1() returns trigger as $$ begin if (new.dept is not null) then update Department set totSal = totSal + new.salary where Department.id = new.dept; end if; return new; end; $$ language plpgsql;-- 员工调整部门/调薪create trigger TotalSalary2 after update on Employee for each row execute procedure totalSalary2(); create function totalSalary2() returns triggeras $$ begin update Department set totSal = totSal + new.salary where Department.id = new.dept; update Department set totSal = totSal - old.salary where Department.id = old.dept; return new; end; $$ language plpgsql;-- 员工离职create trigger TotalSalary3 after delete on Employee for each row execute procedure totalSalary3(); create function totalSalary3() returns trigger as $$ begin if (old.dept is not null) then update Department set totSal = totSal - old.salary where Department.id = old.dept; end if; return old; end; $$ language plpgsql;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9311 </tag>
            
            <tag> 手册 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学课程笔记（5）</title>
      <link href="/2021/03/12/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-5/"/>
      <url>/2021/03/12/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-5/</url>
      
        <content type="html"><![CDATA[<h2 id="等价关系与划分"><a href="#等价关系与划分" class="headerlink" title="等价关系与划分"></a>等价关系与划分</h2><p>如果关系$\mathcal{R}$满足(R)，(S)，(T)，那么它被叫做<strong>等价关系（equivalence relation）</strong></p><p>每个等价关系$\mathcal{R}$在其定义域$S$上定义<strong>等价类equivalence classes</strong>。</p><p>元素$s \in S$的等价类[s] （写作$\mathcal{R}$）为：</p><script type="math/tex; mode=display">[s]_{\mathcal{R}}=\{t\in S :t\mathcal{R}s\}</script><p>这个概念只适用于等价关系$\mathcal{R}$。所有等价类的集合是$S$的一个<strong>分区（partition）</strong>:</p><script type="math/tex; mode=display">S=\dot\bigcup_{s\in S}[s]\mathcal{R} \\</script><p>其中，$\dot\bigcup$表示不相交的结合</p><p>等价类是不相交的，并且共同覆盖整个域。每个元素都属于且仅属于一个等价类。</p><p>我们用$s_1,s_2,\dots$代表不同的等价类，对于$s,t \in S$，要么当$s\mathcal{R}t$时，$[s] = [t]$，要么当$s\not\mathcal{R}t$时，$[s]\cap[t] =\emptyset$。</p><p>当$s,t$在同一个等价类中时，我们通常写$s\sim_\mathcal{R} t$。</p><p>相对的，一个集合的划分定义了该集合上的等价关系。</p><p>如果$S=S_1\dot\cup \dots \dot\cup S_k$，那么当s和t属于同一个$S_i$时，会有$s \sim t$。</p><p>如果关系$\sim$在$S$上等价，且$[S]$是相应的划分，那么</p><script type="math/tex; mode=display">\nu : S \rightarrow [S], \nu : s \mapsto [s] = \{x \in S:x \sim s\}</script><p>被叫做自然图（natural map）。他总是满射的。</p><p>只有当$\sim$在$S$上有一致性（identity）的时候，$\nu$是1-1映射。</p><p>函数$f:S\rightarrow T$ 在$S$上定义一个等价关系，通过</p><p>$s_1 \sim s_2$当且仅当$f(s_1)=f(s_2)$</p><p>非空的集合$f^{\leftarrow}(t),t\in T$形成相应的划分</p><script type="math/tex; mode=display">S=\bigcup_{t\in T}f^{\leftarrow}(t)</script><p>只有当$f$是满射的时候，$f^{\leftarrow}(t)\neq \emptyset$</p><h3 id="同余关系-Congruence-Relations"><a href="#同余关系-Congruence-Relations" class="headerlink" title="同余关系 Congruence Relations"></a>同余关系 Congruence Relations</h3><p>$\mathbb{Z}\rightarrow \mathbb{Z}_p$：将$\mathbb{Z}$划分为具有相同余数（mod p）的数类；这对于素数（prime）$p$来说特别重要</p><script type="math/tex; mode=display">\mathbb{Z}=\{0,1,\dots,p-1\}</script><p>我们可以为素数$p$在$\mathbb{Z}_p$上定义所有四种算术运算（具有通常的性质）；当$p$不是质数时除法是有限制的。</p><p>标准符号：$\mathbf{m}\equiv \mathbf{n}\ (mod\ \mathbf{p})$</p><p>$\overset{def}=$m除以$p$的余数= $n$除以$p$的余数</p><p><strong>注</strong></p><p>$(\mathbb{Z}_p,+,\cdot,0,1)$是称为<strong>环（rings）</strong>的基本代数结构。<br>这些结构在编码理论和密码学中非常重要。</p><h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><p>$\mathbb{Z}_5=\{0,1,2,3,4\}$</p><script type="math/tex; mode=display">\begin{array}{c|c,c,c,c}+_5 & 0 & 1 & 2 & 3 & 4 \\\hline0 & 0 & 1 & 2 & 3 & 4 \\1 & 1 & 2 & 3 & 4 & 0 \\2 & 2 & 3 & 4 & 0 & 1 \\3 & 3 & 4 & 0 & 1 & 2 \\4 & 4 & 0 & 1 & 2 & 3\end{array}\quad\begin{array}{c|c}n & -n \\\hline0 & 0  \\1 & 4  \\2 & 3  \\3 & 2  \\4 & 1 \end{array}\quad\begin{array}{c|c,c,c,c}*_5 & 0 & 1 & 2 & 3 & 4 \\\hline0 & 0 & 0 & 0 & 0 & 0 \\1 & 0 & 1 & 2 & 3 & 4 \\2 & 0 & 2 & 4 & 1 & 3 \\3 & 0 & 3 & 1 & 4 & 2 \\4 & 0 & 4 & 3 & 2 & 1\end{array}\quad\begin{array}{c|c}n & n^{-1} \\\hline0 & -  \\1 & 1  \\2 & 3  \\3 & 2  \\4 & 1 \end{array}</script><p>注：逆运算的算法为</p><p>$1<em>1=1;2</em>3=1;3<em>2=1;4</em>4=1$</p><h3 id="几何中的等价类"><a href="#几何中的等价类" class="headerlink" title="几何中的等价类"></a>几何中的等价类</h3><p>从矩形开始</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210313010047.png" alt="一个矩形" style="zoom:67%;"></p><p>将$[a, b]$区间内的点与$[c, d]$区间内的点（在这个方向上）识别为一个圆柱体，同时将$[a, c]$和$[b, d]$识别为一个环面。</p><p>矩形内部的点没有“粘”在一起；因此等效类（圆柱体）有一个或两个元素，而环面也有一个类有四个元素（哪四个？）</p><p>将$[a, b]$与$[d, c]$（该方向）识别为单侧莫比斯带（Moebius strip）；此外，将它与标识$[a, c$]和$[b, d]$放在一起，给出了一个单边封闭表面（“克莱因瓶Klein bottle”）。</p><p>克莱因瓶不能嵌入三维空间而没有自交。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210313010644.png" alt="克莱因瓶" style="zoom:50%;"></p><p>通常需要在$[S]$上定义一个函数，对每个等价类$[S]$中的$t\in [S]$进行描述。</p><p>如果$\phi: [S]\rightarrow X$是这样定义的，那么必须</p><ul><li><p>定义$\phi(t)$对所有$t\in S$，确定$\phi(t) \in X$</p></li><li><p>当$t_1 \sim t_2$时，确定$\phi(t_1) = \phi (t_2)$，例如当$[t_1]=[t_2]$</p></li><li><p>定义 $\phi([s])\overset{def}= \phi(s)$</p></li></ul><p>第二个条件对于定义良好的$\phi$至关重要。</p><h2 id="顺序关系-Order-Relations"><a href="#顺序关系-Order-Relations" class="headerlink" title="顺序关系 Order Relations"></a>顺序关系 Order Relations</h2><h3 id="全序（Total-order）"><a href="#全序（Total-order）" class="headerlink" title="全序（Total order）"></a>全序（Total order）</h3><p><strong>全序（Total order）</strong>$\le$在$S$</p><p>(R)$x \le x$对于所有的$x \in S$</p><p>(AS) $x \le y, y\le x \Rightarrow x = y$</p><p>(T)$x\le y, y\le z \Rightarrow x\le z$</p><p>(L)线性-任何两个元素是可比较的：对于所有的$x,y$，要么$x\le y$或$y \le x$，要么$x=y$</p><p>在有限集上，所有的全序都是”<strong>同构的（isomorphic）</strong>”。</p><script type="math/tex; mode=display">x_1 \le x_2 \le \cdots \le x_n</script><p>在一个无限的集合上，有相当多的可能性。</p><h3 id="偏序（Partical-Order）"><a href="#偏序（Partical-Order）" class="headerlink" title="偏序（Partical Order）"></a>偏序（Partical Order）</h3><p>$S$上的一个偏序（partial order）$\preceq$满足(R)，(AS)，(T)，不需要(L)</p><p>$(S,\preceq)$叫做<strong>偏序集（poset）</strong>，即偏序的集合</p><p>对于每一个（偏）序，可以关联一个唯一的拟序<strong>（quasi-order）</strong></p><script type="math/tex; mode=display">x \prec y 当且仅当 x \preceq y 且 x \neq y</script><p>这满足(AS)和(T)；如果它对应于一个全序（我们可以称它为一个全拟序total quasi-order）它满足(L)；对任意一对$x,y$它都不满足(R)</p><h3 id="哈斯图"><a href="#哈斯图" class="headerlink" title="哈斯图"></a>哈斯图</h3><p>每个优先的偏序集都可以用哈斯图来表示，其中，如果$x \prec y $且没有$z$使$x \prec z \prec y$，那么就从$x$到$y$画一条向上的线。</p><h2 id="排序的概念"><a href="#排序的概念" class="headerlink" title="排序的概念"></a>排序的概念</h2><p><strong>定义</strong></p><p>极小元素和极大元素（它们总是存在于每个有限偏序集中）</p><p>最小和最大——唯一的最小和最大元素</p><p>一个子集$A \subseteq S $的元素中，<strong>lub</strong>（最小上界least upper bound）和<strong>glb</strong>（最大下界greatest lower bound）</p><p>$lub(A)$——最小元素$x \in S$，例如，$x \succeq a$ 对于所有的$a\in A$</p><p>$glb(A)$——最大元素$x \in S$，例如，$x \preceq a $对于所有的$a\in A$</p><p><strong>晶格Lattice</strong>每一对元素都存在lub和glb的偏序集（通过归纳法，每个有限元素子集都存在晶格）</p><p><strong>注意</strong></p><p>无限格不需要对其元素的任意无限子集有lub(或没有glb)，特别是对其所有元素不可能存在这样的边界。</p><p><strong>例子</strong></p><p>$\mathbb{Z}$——即不是lub也不是glb</p><p>$\mathbb{F}(\mathbb{N})$——所有有限子集，不具有任意lub性质；glb存在，它是交集，因此总是有限的；</p><p>$\mathbb{I}(\mathbb{N})$——所有的无限子集，可能不具有任意的glb；lub是存在的，它是无限的集合。</p><h3 id="有序集合-Well-Ordered-Sets"><a href="#有序集合-Well-Ordered-Sets" class="headerlink" title="有序集合 Well-Ordered Sets"></a>有序集合 Well-Ordered Sets</h3><p><strong>有序集合</strong>：每个子集都有最小的元素。</p><p><strong>注意：</strong></p><p>最大的元素不是必需的。</p><p>有序集合是证明程序终止的重要数学工具。</p><h3 id="偏序集排序-拓扑排序"><a href="#偏序集排序-拓扑排序" class="headerlink" title="偏序集排序-拓扑排序"></a>偏序集排序-拓扑排序</h3><p>对一个偏序集$(S,\preceq)$，任意线性顺序$\leq$与$\prec$是一致的，这叫做<strong>拓扑排序</strong>。一致性意味着$a \preceq b \Rightarrow a \leq b$</p><h3 id="结合排序"><a href="#结合排序" class="headerlink" title="结合排序"></a>结合排序</h3><p><strong>乘积排序（product order）</strong>——可以组合任何部分顺序。一般来说，它只是一个部分的顺序，即使把全部的顺序结合起来。</p><p>对于$s,s’ \in S$，且$t,t’ \in T$，定义</p><script type="math/tex; mode=display">(s,t) \preceq (s',t') \quad 如果s \preceq s' 且 t \preceq t'</script><h3 id="函数排序"><a href="#函数排序" class="headerlink" title="函数排序"></a>函数排序</h3><p>$T$——任意集合（没有顺序要求）</p><p>$S$——偏序集合</p><p>$M=\{f:T\rightarrow S\}$——所有从$T$到$S$的集合</p><p>这是一个自然偏序</p><script type="math/tex; mode=display">f \preceq g \quad 当且仅当 \forall t \in T(f(t)\preceq g(t))</script><p>实际上，它是$S^{|T|}$上的一个乘积排序。在大多数应用中，$T$是线性排序的；然而，它并不影响在$T$上定义的函数的顺序（只对S上的顺序有影响）。</p><h3 id="实际的序Practical-Orderings"><a href="#实际的序Practical-Orderings" class="headerlink" title="实际的序Practical Orderings"></a>实际的序Practical Orderings</h3><p>它们实际上是有序集的乘积上的总排序。</p><p><strong>词典顺序（Lexicographic order）</strong>——在所有的$\sum^*$上定义。它扩展了已经假定存在于$\sum$上的一个总序。</p><p><strong>Lenlex顺序</strong> ——在整个$\sum^*$上的排序，其中的元素先按照长度排序</p><p>$\sum^{1}\prec \sum^{2}\prec \sum^{3}\prec \cdots$，其中每个$\sum^{(k)}$为字典序。在实践中，它仅被应用于$\sum^*$的有限子集</p><p><strong>锉顺序（Filing order）</strong>——字典顺序限制为相同长度的字符串。 它为每一个$i$分别定义了$\Sigma ^i$的总阶数。</p><p>只有当$|\Sigma|=1$时，词典顺序和Lenlex顺序相同</p><h3 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h3><p>如果$\Sigma$是全序的，那么相关的词典顺序或Lenlex顺序偏序$\Sigma^*$也是全序的</p><p>每个有限偏序集有一个哈斯图，同时有一个拓扑排序</p><p>每个有限偏序集不一定有最小值</p><p>每个有限全序集一定有最大值</p><p>一个无限偏序集也可以有最大值</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>等价关系$\sim$，等价类$[S]$</p><p>$\mathbb{Z}$上的特别等价关系：符号$m \equiv n (\mod p)$；$\mathbb{Z}_p$</p><p>排序：全，偏；lub，glb，格lattice，拓扑排序</p><p>哈斯图</p><p>特别排序：乘积排序，字典排序，lenlex排序</p><p>等价类：(R)(S)(T)</p><p>全序：(R)(AS)(T)(L)</p><p>偏序：(R)(AS)(T)</p><blockquote><p> <strong>参考资料</strong></p><p>Textbook (R &amp; W) - Ch. 3, Sec. 3.4-3.5; Ch. 11. Sec. 11.1-11.2</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9020 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 离散数学 </tag>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础课程笔记（2）</title>
      <link href="/2021/03/08/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-2/"/>
      <url>/2021/03/08/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<h2 id="关系数据模型-Relational-Data-Model"><a href="#关系数据模型-Relational-Data-Model" class="headerlink" title="关系数据模型 Relational Data Model"></a>关系数据模型 Relational Data Model</h2><p>关系数据模型采用简单统一的数据结构，且已在大多数商业数据库系统中实现，具有坚实的理论基础。</p><h3 id="结构-Structures"><a href="#结构-Structures" class="headerlink" title="结构 Structures"></a>结构 Structures</h3><p>在关系模型中，一切都是使用关系来描述的。关系可以看作是一个指定的表。表的每一列都对应一个命名的属性。属性允许的值集合称为它的域。表中的每一行被称为关系的一个元组。</p><p>注意，列或行没有顺序要求。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308202702.png" alt="关系数据模型的样例" style="zoom: 25%;"></p><p>从数学上说，域$D$是一组表示某种语义的原子值（具有某种固定的数据类型）。属性$A$是域$dom(A)$所扮演的角色名称。关系模式$R$，表示为$R(A_1,A_2,\dots ,A_n)$，由一组属性组成 $R = {A_1,A_2,\dots,A_n}$。</p><p>注意，不允许复合和多值属性！</p><p>元组$t(A_1,A_2,\dots ,A_n)$是$dom(A_1) \times \dots \times dom(A_n)$中的一个点，其中每个$dom(A_j)$的域是$A_j$</p><p>一个关系（或一个关系实例）是一组元组，是$dom(A_1) \times \dots \times dom(A_n)$的子集</p><p>关系模式用于描述关系。关系的<strong>度（degree）</strong>是关系模式中属性的数量。</p><h3 id="关系数据模型与ER模型对比"><a href="#关系数据模型与ER模型对比" class="headerlink" title="关系数据模型与ER模型对比"></a>关系数据模型与ER模型对比</h3><p>关系模式（内涵）⇄实体或关系类型模式（内涵）</p><p>属性⇄属性</p><p>元组⇄实体/关系实例</p><p>关系(实例，扩展)⇄实体/关系扩展</p><p>在ER模型中允许复合和多值属性，但在关系数据模型中不允许</p><p><strong>键（keys）</strong>用于标识关系中的元组</p><p><strong>超键（superkey）</strong>是一组唯一确定元组的属性</p><p>请注意，这是关系的一个属性，它不依赖于当前的关系实例</p><p><strong>候选键（candidate key）</strong>是一个超键，它的<strong>恰当的（proper）</strong>子集都不是超键。</p><p>键是由应用程序决定的</p><p>例如，如果 {Name} 是唯一的，那么它是PLAYER的候选键；否则，我们需要使用整个元组，或者创建一个候选键，比如PID</p><p>{Goals}通常不能成为候选关键，因为不同的玩家<strong>可能</strong>拥有相同数量的目标</p><p>{Name, Goals}是超键，但如果{Name}是键，则不是候选键。</p><p><strong>主键（primary key, PK）</strong>是指定的候选键。在许多应用程序中，如果没有一个自然的主键，那么有必要发明一个主键——通常这将是一个非负整数，例如Person_number。当一个关系模式有几个候选键时，通常最好选择一个具有单个属性或少量属性的主键。</p><h3 id="完整性约束-Integrity-constraints"><a href="#完整性约束-Integrity-constraints" class="headerlink" title="完整性约束 Integrity constraints"></a>完整性约束 Integrity constraints</h3><p>完整性约束有几种类型，是关系模型不可或缺的一部分：</p><ul><li>键约束（Key constraint）：候选键值对于每个关系实例必须是唯一的</li><li>实体完整性（Entity integrity）：作为主键的一部分的属性不能为空</li><li>参照完整性（Referential integrity）：这种约束与”外键”有关</li><li>引用完整性：FK的值必须出现在另一个关系中，否则完全为Null</li></ul><p><strong>外键（Foreign keys, FK）</strong>用于引用另一个关系中的元组。</p><p>如果一个关系模式的属性$R_1$是外键，则其需要满足：</p><ul><li>这些属性与另一个关系模式$R_2$的主键中的属性具有相同的域</li><li>元组$t_1 (R_1)$中的FK值要么作为$R_2$中某个元组$t_2$的PK值，要么为Null</li></ul><h4 id="检查更新的约束-Checking-constraints-on-updates"><a href="#检查更新的约束-Checking-constraints-on-updates" class="headerlink" title="检查更新的约束 Checking constraints on updates"></a>检查更新的约束 Checking constraints on updates</h4><p>为了维护数据库的完整性，我们需要在进行更新之前对要更新的数据进行检查，检查其是否违反完整性约束</p><p>例如，假设我们有如下的带有外键的模式：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308205555.png" alt="检查更新的约束" style="zoom:33%;"></p><p><strong>插入（Insertions）</strong>：当插入数据时，我们需要检查候选键是否已经存在，同时每个外键的值要么为NULL，要么在引用的关系中存在。</p><p><strong>删除（Deletions）</strong>: 删除时，我们需要检查引用完整性——检查主键是否出现在另一个关系中。</p><p>如果要删除的值做为外键被其他表引用，则可以：</p><ul><li>删除引用它的数据（注意，这需要进行另一次完整性检查，可能导致级联删除）</li><li>将外键值设置为NULL（注意，如果它是主键的一部分，就不能这样做）</li><li>将外键值设置为另一个可接受的值</li></ul><p><strong>修改（Modifications）</strong>：如果修改的属性是主键，那么情况就似于删除然后重新插入。如果修改的是外键，那就检查新值是否指向已经存在的元组。如果不是以上两种情况，那么一般就不会出现问题。</p><h4 id="关系数据库的定义-Relational-database-definition"><a href="#关系数据库的定义-Relational-database-definition" class="headerlink" title="关系数据库的定义 Relational database definition"></a>关系数据库的定义 Relational database definition</h4><p>一个关系数据库模式，是一组关系模式${R_1,\dots,R_m}$和一组完整性约束。</p><p>一个关系数据库实例是一组关系实例${r_1,\dots,r_m}$，使每个$r_i$都是$R_i$的一个实例，并且满足完整性约束。</p><h3 id="ER图到关系数据模型映射"><a href="#ER图到关系数据模型映射" class="headerlink" title="ER图到关系数据模型映射"></a>ER图到关系数据模型映射</h3><p>数据库设计的一种技术是首先使用高级数据模型设计概念模式，然后将其映射到所选DBMS数据模型中的概念模式。这里我们将介绍一种将ER映射到关系数据模型的方法。它包括以下7个步骤。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308212016.png" alt="ER图转RDB" style="zoom: 25%;"></p><h5 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h5><p>对于每个常规（非弱）实体类型$E$，创建与$R$的关系</p><ul><li>Attributes：$E$的所有简单属性（以及复合属性的简单组件）创建一个关系R</li><li>Key：选择$E$的一个键作为该关系的主键</li></ul><p>对于具有父实体类型$P$的每个专门化实体类型$E$，创建与$R$的关系</p><ul><li>属性：$P$的键的属性，加上$E$的简单属性</li><li>键：P的键</li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308213007.png" alt="创建实体$E$" style="zoom:25%;"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308214001.png" alt="创建实体E" style="zoom:25%;"></p><h5 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h5><p>对于每个弱实体类型$W$，所有者实体类型$E$，创建与$R$的关系</p><ul><li><p>属性：$W$的所有简单属性（以及复合属性的简单组件），包括$E$派生的关系的主属性作为外键</p></li><li><p>键：外键加上$W$的部分键</p></li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308213757.png" alt="弱实体类型W" style="zoom:25%;"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308214041.png" alt="创建弱实体$W$" style="zoom:25%;"></p><h5 id="步骤三："><a href="#步骤三：" class="headerlink" title="步骤三："></a>步骤三：</h5><p>对于每种1:1关系类型$B$，设$E$和$F$为参与的实体类型。让$S$和$T$是对应的关系。</p><ul><li>从$S$和$T$中选择一个（最好是完全参与的），比如$S$</li><li>将$T$的主键的属性添加到$S$中作为外键</li><li>将$B$的简单属性（以及复合属性的简单组件）添加为$S$的属性</li></ul><p>另一种选择是，将两种实体类型和关系合并为一个关系，特别是在两者都参与而不参与其他关系的情况下。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308214644.png" alt="1:1关系$B$" style="zoom:25%;"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308214847.png" alt="创建1:1关系$B$" style="zoom:25%;"></p><h5 id="步骤四："><a href="#步骤四：" class="headerlink" title="步骤四："></a>步骤四：</h5><p>对于每一个规则的1:N关系类型$B$，设$E$和$F$为参与的实体类型，$E$在1边，$F$在N边。$S$和$T$是对应的关系，将$S$的主键的属性添加到$T$作为外键。向关系$T$添加简单属性（或复合属性的简单组件）。</p><p>注意，这并没有添加任何新的元组，只是添加了属性。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308215447.png" alt="1:N关系$B$" style="zoom:25%;"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308215629.png" alt="创建1:N关系$B$" style="zoom:25%;"></p><h5 id="步骤五："><a href="#步骤五：" class="headerlink" title="步骤五："></a>步骤五：</h5><p>对于每个N:M关系类型$B$，创建一个新的关系$R$，让$E$和$F$作为参与的实体类型，让$S$和$T$是对应的关系。</p><ul><li>属性：将$S$键和$T$键作为外键，再加上$B$的简单属性（以及复合属性的简单组件）</li><li>key：$S$键和$T$键</li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308220215.png" alt="N:M关系$R$" style="zoom:25%;"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308220259.png" alt="创建N:M关系$R$" style="zoom:25%;"></p><h5 id="步骤六："><a href="#步骤六：" class="headerlink" title="步骤六："></a>步骤六：</h5><p>对于每个多值属性$A$，创建一个新的关系$R$，设$A$为$E$的一个属性。</p><ul><li>属性A（如果A是一个简单属性）和$E$的键作为外键；A的简单组件（如果A是一个复合属性），以及作为外键的键$E$</li><li>键：所有属性</li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308220733.png" alt="多值属性$A$" style="zoom:25%;"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308220818.png" alt="创建多值属性$A$关系$R$" style="zoom:25%;"></p><h5 id="步骤七："><a href="#步骤七：" class="headerlink" title="步骤七："></a>步骤七：</h5><p>对于每个n元关系类型（n &gt; 2），创建一个新的关系：</p><ul><li>属性：与步骤五相同</li><li>键：与步骤五相同，除非其中一个参与实体类型的参与率为1，它的键可以用作新关系的键。</li></ul>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9311 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础课程笔记（1）</title>
      <link href="/2021/03/08/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-1/"/>
      <url>/2021/03/08/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h2 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h2><h4 id="教师及联系方式"><a href="#教师及联系方式" class="headerlink" title="教师及联系方式"></a>教师及联系方式</h4><p>Xuemin Lin<br>School of Computer Science and Engineering<br>Office: K17-503<br>E-mail: lxue@cse.unsw.edu.au<br>Ext: 6493<br><a href="http://www.cse.unsw.edu.au/~lxue">http://www.cse.unsw.edu.au/~lxue</a></p><h4 id="开课信息"><a href="#开课信息" class="headerlink" title="开课信息"></a>开课信息</h4><p><strong>演讲：</strong><br>    17:00 - 19:00 （周一，澳大利亚时间）           第 1 – 9 周上课<br>    16:00 - 18:00 （周二，澳大利亚时间）           第 1 – 9 周上课<br>共9周。</p><p><strong>实验：</strong></p><p>通过Moodle(<a href="https://moodle.telt.unsw.edu.au/)在线进行，在“讲座和录音”中（COMP9311">https://moodle.telt.unsw.edu.au/)在线进行，在“讲座和录音”中（COMP9311</a> – Database Systems 2021 T1）<br>第2 - 5、7 - 10周上课（第11周周一复活节补课）<br>咨询：TBA<br>Q&amp;A论坛： <a href="https://groups.google.com/group/comp9311-21t1">https://groups.google.com/group/comp9311-21t1</a><br>课程的电子邮件： comp9311unsw@gmail.com</p><h4 id="作业安排"><a href="#作业安排" class="headerlink" title="作业安排"></a>作业安排</h4><p>2 个大作业（assignments），1 个项目（project）。所有的作业都需要个人独立完成！</p><ul><li>大作业（50%）：<br>大作业1（Ass 1）：数据建模 + 关系代数（20%）（第2-4周）<br>大作业2（Ass 2）：数据库设计理论 + 数据库存储结构 + 事务处理（30%）（第7-9周）</li><li><p>项目（project） (50%)<br>项目 1: SQL &amp; PLpgSQL (50%)  ( 4-7 周为SQL, 第 8 周为PLpgSQL)<br>逾期提交的惩罚：<br>作业：迟交作业0分<br>项目：迟交第一天扣10%，然后每天扣30%。</p></li><li><p>期末考试：100%<br>如果考试当天你生病了，就不要参加考试。如果已经尝试考试，将不允许再提出医疗特殊考虑要求。</p></li></ul><h4 id="最终成绩计算规则"><a href="#最终成绩计算规则" class="headerlink" title="最终成绩计算规则"></a>最终成绩计算规则</h4><p>最终成绩 = $\sqrt{(ass1+ass2+proj1)∗exam}$</p><h4 id="教科书"><a href="#教科书" class="headerlink" title="教科书"></a>教科书</h4><p>Elmasri &amp; Navathe, Fundamentals of Database Systems, Benjamin/Cummings, 6th Edition, 2010.</p><p>（Elmasri &amp; Navathe，《数据库系统基础》，Benjamin/Cummings，第6版，2010年版）</p><h4 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h4><p>J. D. Ullman &amp; J. Widom, 《数据库系统概论》，武汉大学出版社，1997年版。<br>R. Ramakrishan,《数据库管理系统》，北京:科学出版社，1997年版<br>D. Maier《关系数据库理论》，计算机科学出版社，1983年版</p><h4 id="教学安排"><a href="#教学安排" class="headerlink" title="教学安排"></a>教学安排</h4><div class="table-container"><table><thead><tr><th><strong>Time</strong></th><th><strong>Monday</strong></th><th><strong>Tuesday</strong></th></tr></thead><tbody><tr><td>Week 1</td><td>Subject Introduction, Conceptual DB Design (ER)</td><td>Conceptual DB Design (continue), Relational Data Model</td></tr><tr><td>Week 2</td><td>Relational Data Model(continue), Relational Algebra</td><td>SQL</td></tr><tr><td>Week 3</td><td>SQL(continue), PLpgSQL</td><td>Functional Dependencies</td></tr><tr><td>Week 4</td><td>Functional Dependencies (continue), Normal Forms</td><td>Normal Forms (continue)</td></tr><tr><td>Week 5</td><td>Relational DB design</td><td>Relational DB design (continue)</td></tr><tr><td>Week 6</td><td>Disks, Files</td><td>Index</td></tr><tr><td>Week 7</td><td>Transaction Management</td><td>Transaction Management (continue)</td></tr><tr><td>Week 8</td><td>Graph Data and Graph Database</td><td>Graph Pattern Matching</td></tr><tr><td>Week 9</td><td>Towards Big Graph Processing: applications and challenges</td><td>Revisions</td></tr></tbody></table></div><h2 id="数据库概念设计"><a href="#数据库概念设计" class="headerlink" title="数据库概念设计"></a>数据库概念设计</h2><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LRa[应用 Appl] --&gt; e[E-R图] --&gt; r[关系数据库 Relational DB]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="实体关系模型"><a href="#实体关系模型" class="headerlink" title="实体关系模型"></a>实体关系模型</h3><p><strong>实体关系模型</strong>（Entity-Relationship Model，ER）是一种高级概念数据模型。其ER主要用作设计工具。</p><p><strong>实体类型（Entity type）</strong>：具有相同属性的对象组</p><p><strong>实体（Entity）</strong>：实体类型的成员-类似于对象。</p><p><strong>属性（Attribute）</strong>：对象的一个属性</p><p><strong>关系（Relationship）</strong>：对象之间的关系</p><p>ER图可以建模n-元（n-way）关系，通过一个关系对两个对象见建立连接</p><h3 id="实体和属性-Entity-and-Attributes"><a href="#实体和属性-Entity-and-Attributes" class="headerlink" title="实体和属性 Entity and Attributes"></a>实体和属性 Entity and Attributes</h3><p>实体代表现实世界中的事物。属性描述实体的属性。属性可以是：</p><ul><li>简单（原子），例如 sex = ‘ Female ‘</li><li>复合（composite），例如姓名由头衔(Dr)、首字母(C.C.)、姓(Chen)组成</li></ul><p>每个实体都有每个属性的值。属性可以是：</p><ul><li>单值，例如 学生编号，姓名</li><li>多值，例如 关键字=神经网络, 计算机图形, 数据库</li></ul><p>每个简单属性都有一个值集（value set）或叫域（domain），表示该属性可能值的集合。</p><p>在一个复合属性中$A = (A_1,\dots ,A_n)$，假设$V_1,\dots,V_n$为$A_1,\dots ,A_n$的域</p><p>$A$的定义域$V$是$V_1 \times \dots \times V_n$。</p><p>数学上，实体$E$的属性$A$是一个函数</p><script type="math/tex; mode=display">A: E \rightarrow ℘(V)</script><p>其中$V$是$A$的定义域，$℘(V)$是$V$的单值属性的幂集，$A(E)$必须是一个单值函数。</p><p>一个属性可以有一个空值，例如：</p><ul><li>没有合适的值，例如，一个学生可能没有兴趣，那么keywords = null</li><li>还不知道真实的值，例如，一个人的结婚日期还不知道：结婚日期= null</li></ul><p>派生属性的值可以从其他属性和实体派生出来，比如学生人数。</p><p><strong>实体类型（entity type）</strong>是一组具有相同属性的实体。它由<strong>实体模式（entity schema）</strong>描述。实体模式由一个名称和一个属性列表构成。</p><p>在特定时刻，单个实体<strong>实例（instances）</strong>集称为实体类型的扩展。</p><p>模型和实例的对比如下：</p><div class="table-container"><table><thead><tr><th><strong>模型Schema (Intension)</strong></th><th><strong>RESEACHER</strong><br> <strong>Name,</strong> <strong>Payroll_no**</strong>,<strong> </strong>No_of_students<strong>**, Keywords</strong></th><th><strong>DEPARTMENT Name</strong></th></tr></thead><tbody><tr><td>实例Instances (Extension)</td><td>(Dr C.C. Chen, 230-0013, 3, Neural Networks)  (Dr R. Wilkinson, 231-0091, 1, Databases)</td><td>Computer Science Psychology Management</td></tr></tbody></table></div><p>实体类型通常有一个<strong>主键（key）</strong>，即可唯一标识实体的属性组。例如：<br>{工资号}是研究员的主键<br>{名称}是部门的主键</p><p>一个实体可已有多个主键</p><p>一个重要的约束是键约束：在实体类型的任何扩展中，不能有两个实体的键属性具有相同的值。</p><p>模式（schemata）可以用以下两种方式描述：</p><ul><li><p>符合属性()</p></li><li><p>多值属性{}</p></li></ul><div class="table-container"><table><thead><tr><th><strong>CAR **</strong>Registration(Registration No, State), Make, Model, Year, {Colour}**</th></tr></thead><tbody><tr><td>((ARQ) 595, Vic), Datsun, 120Y, 1972, {green}) ((8HR) 696, WA), Mazda, 929, 1979, {grey, black})</td></tr></tbody></table></div><p>实体及其属性也可以用实体-关系图（ERDs）来描述。例如：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308170830.png" alt="实体-关系图" style="zoom: 25%;"></p><h3 id="关系-Relationships"><a href="#关系-Relationships" class="headerlink" title="关系 Relationships"></a>关系 Relationships</h3><p><strong>关系（relationship ）</strong>表示事物之间的关联。</p><p>$n$个实体类型$E_1,\dots E_n$之间的关系类型$R$，是这些实体类型之间的一组关联。</p><p>数学上，实体类型$E_1,\dots E_n$之间的关系类型$R$是$E_1 \times \dots \times E_n$的子集。</p><p>每个实例$r = (e_1,\dots , e_n)$在$R$中是一种关系。</p><p>我们说$E_1,\dots E_n$<strong>参与（participate）</strong>$R$ .</p><p>同样，如果$r = (e_1,\dots, e_n)$是$R$的一个实例，我们说每个$e_i$参与$r$。</p><p>$R$的<strong>度（degree）</strong>是参与的实体类型的数量。例如，</p><p>招生可以是研究员、学生和课程之间的三元（3度）关系。</p><p>可以用一个事件图来说明这一点：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308170905.png" alt="事件图" style="zoom:25%;"></p><p>实体及其关系也可以用实体-关系图来表示：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308171024.png" alt="实体-关系图" style="zoom:25%;"></p><p>参与关系的每种实体类型在关系中扮演特定的<strong>角色（role）</strong>。</p><p>实体类型可以在不同的关系中扮演不同的角色，或者在一个关系中扮演多个角色。</p><p>可以使用角色名来区分它们。</p><p>例如，ENROLMENT可以是PERSON（作为研究员）、PERSON（作为学生）和COURSE之间的关系，如下图所示:</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210504223013.png" alt="实体类型扮演多种角色" style="zoom: 50%;"></p><p>或者，使用ERD：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308171200.png" alt="ERD图" style="zoom:25%;"></p><p>这称为递归关系。</p><h3 id="弱实体类型-Weak-entity-types"><a href="#弱实体类型-Weak-entity-types" class="headerlink" title="弱实体类型 Weak entity types"></a>弱实体类型 Weak entity types</h3><p>有些实体类型没有自己的键，这种实体类型称为弱实体类型。</p><p>弱实体类型的实体可以通过部分键和与另一个实体类型所有者相关联来标识。</p><p>弱实体类型与其所有者之间的关系类型是弱实体类型的<strong>标识关系（dentifying relationship）</strong>。</p><p>例如，一个纳税人TAX PAYER 实体可能与几个由其名称确定的独立实体DEPENDENT相关。在本例中，DEPENDENT称为弱实体，{Name}是它的部分键。</p><p>DEPENDENT和TAX PAYER之间的标识关系是IS DEPENDENT OF。</p><p>TAX PAYER被称为<strong>自己的（own）</strong> DEPENDENT</p><h3 id="关系类型的约束-Constraints-on-relationship-types"><a href="#关系类型的约束-Constraints-on-relationship-types" class="headerlink" title="关系类型的约束 Constraints on relationship types"></a>关系类型的约束 Constraints on relationship types</h3><p>关系类型通常具有某些约束，这些约束用来限制实体在组合实例时的组成方法。它们应该反映正确的因素<br><strong>基数比率约束（Cardinality ratio constraint）</strong>：指定实体可以参与的关系实例的数量。</p><p>例如，一个研究补助金只能支持一个研究项目，但一个研究项目可能需要多个补助金来支持。那么，PROJECT:GRANT就是1:N的关系。</p><p>如下图所示：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308174655.png" alt="关系约束示例" style="zoom:25%;"></p><p>可以在ERD中展示为：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210504223315.png" alt="ERD-1:N" style="zoom:50%;"></p><p>例如：考虑一个AFL(这里替代你最喜欢的团队运动)统计数据的数据库。主教练与俱乐部的关系就是1:1关系的一个例子。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308175257.png" alt="AFL关系图" style="zoom:25%;"></p><p>其ERD为：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308180801.png" alt="ERD-1:1" style="zoom:25%;"></p><p>例子：一个表示作者和出版社之间N: M关系的实例</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308175812.png" alt="N:M关系实例" style="zoom:25%;"></p><p>其等价ERD为：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308180844.png" alt="ERD-N:M" style="zoom:25%;"></p><p>另一种可以使用ER模型表示的约束是<strong>参与约束（Participation constraint）</strong></p><p>一个实体在关系中的参与可以是：</p><p>合计（total）：每个实体都必须参与，例如每个出版物都有一个作者</p><p>部分的（partical）：不一定全部。不是每个人都有出版物。</p><p>这可以用ERD表示为：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308180922.png" alt="ERD-N:=M" style="zoom:25%;"></p><h3 id="关系类型的属性-Attributes-of-relationship-types"><a href="#关系类型的属性-Attributes-of-relationship-types" class="headerlink" title="关系类型的属性 Attributes of relationship types"></a>关系类型的属性 Attributes of relationship types</h3><p>关系类型可以有属性。</p><p>例如：一个研究人员可以从事几个项目。她花在一个特定项目上的时间可能是关系WORKS ON的一个属性。</p><p>这可以在ERD中显示如下：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308181143.png" alt="关系的属性" style="zoom: 25%;"></p><p>Elmasre/Navathe总结了ERDs所用的符号：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308181316.png" alt="ERD图使用符号" style="zoom:50%;"></p><h3 id="增强ER模型EER-Enhanced-ER-EER-model"><a href="#增强ER模型EER-Enhanced-ER-EER-model" class="headerlink" title="增强ER模型EER Enhanced ER (EER) model"></a>增强ER模型EER Enhanced ER (EER) model</h3><p>设计者必须使用另外的建模概念来尽可能准确（accurately）和明确地（explicitly）表示应用程序的需求。</p><p>ER模型有许多扩展。</p><p>专门化（Specialisation）：定义实体类型的一组子类的过程；这种实体类型称为专门化的超类。</p><p>概括：专业化的逆向过程。</p><p>子类继承父类的所有属性。</p><p>专门化涉及以下几个方面：<br>定义实体类型的一组子类，将额外的特定属性与每个子类关联起来。在每个子类和其他实体类型或其他子类之间建立额外的特定关系类型。一个子类可以有多个超类。专门化可以是全部的也可以是部分的；既可以是不相交的，也可以是重叠的。</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210308181909.png" alt="专门化EER示例" style="zoom:25%;"></p><h3 id="设计原则-Design-Principles"><a href="#设计原则-Design-Principles" class="headerlink" title="设计原则 Design Principles"></a>设计原则 Design Principles</h3><p>诚实（Faithfulness）：反映现实需要（reflect reality）</p><p>避免冗余（Avoid redundancy）</p><p>选择正确的元素（element）</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9311 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础课程笔记（4）</title>
      <link href="/2021/03/07/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-4/"/>
      <url>/2021/03/07/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-4/</url>
      
        <content type="html"><![CDATA[<h2 id="关系依赖"><a href="#关系依赖" class="headerlink" title="关系依赖"></a>关系依赖</h2><p>”好的”数据库模式不应该导致更新异常：</p><ul><li>更新异常</li><li>函数依赖</li><li>阿姆斯特朗原理</li><li>关闭</li></ul><h3 id="更新异常（Update-Anomalies）"><a href="#更新异常（Update-Anomalies）" class="headerlink" title="更新异常（Update Anomalies）"></a>更新异常（Update Anomalies）</h3><p>数据库中的<strong>冗余</strong>（Redundancy ）是指将一段数据多次存储。</p><p>出于效率和语义方面的原因，冗余通常是有用的，但也可能造成一致性问题。</p><p>不完善的冗余控制可能会导致更新异常。</p><p>例如，在此表中，可能会出现：</p><div class="table-container"><table><thead><tr><th><strong>STUDENTS</strong></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Name</td><td>Course</td><td>Phone_no</td><td>Major</td><td>Prof</td><td>Grade</td></tr><tr><td>Jones</td><td>353</td><td>237-4539</td><td>Comp Sci</td><td>Smith</td><td>A</td></tr><tr><td>Ng</td><td>329</td><td>427-7390</td><td>Chemistry</td><td>Turner</td><td>B</td></tr><tr><td>Jones</td><td>328</td><td>237-4539</td><td>Comp Sci</td><td>Clark</td><td>B</td></tr><tr><td>Martin</td><td>456</td><td>388-5183</td><td>Physics</td><td>James</td><td>A</td></tr><tr><td>Dulles</td><td>293</td><td>371-6259</td><td>Decision Sci</td><td>Cook</td><td>C</td></tr><tr><td>Duke</td><td>491</td><td>823-7293</td><td>Mathematics</td><td>Lamb</td><td>B</td></tr><tr><td>Duke</td><td>356</td><td>823-7293</td><td>Mathematics</td><td>Bond</td><td>UN</td></tr><tr><td>Jones</td><td>492</td><td>237- 4539</td><td>Comp Sci</td><td>Cross</td><td>UN</td></tr><tr><td>Baxter</td><td>379</td><td>839-0827</td><td>English</td><td>Broes</td><td>C</td></tr></tbody></table></div><p><strong>修改异常（Modification anomalies）</strong>：例如，Jones的电话号码出现了3次。更改电话号码时，必须在3处全部更改，否则数据会不一致。</p><p><strong>插入异常（Insertion anomalies）</strong>：如果Jones报名另一门课程，输入的电话号码不一样，数据也会不一致。</p><p>此外，如果在这个关系中存储课程和教授之间的关联，如果这是唯一方式的话，那我们只能在有人注册该课程时才知道教授信息。</p><p><strong>删除异常（Deletion anomalies）：</strong>如果删除了某门课的最后一个学生，那么教授和这门课之间的关联就丢失了。</p><h3 id="函数依赖性的定义"><a href="#函数依赖性的定义" class="headerlink" title="函数依赖性的定义"></a>函数依赖性的定义</h3><p>函数$f$从$S_1$到$S_2$的具有这样的性质：</p><p>如果$x, y \in S_1$，而且$x =y$，那么$f(x)=f(y)$</p><p>设$X$和$Y$是$R$中的属性集合，</p><p>$X$（函数式）决定$Y$，$X \rightarrow Y$，当且仅当$t_1[X] = t_2[X]$意味着$t_1[Y] = t_2[Y]$。即，$f (t(X)) = t [Y]$</p><p>我们也说$X\rightarrow Y$有函数依赖性，并且$Y$在函数上依赖于$X$。</p><p>$X$被称为设X和Y是r中的属性集合。</p><p>X(函数式)决定Y, X→Y, iff t1[X] = t2[X]意味着t1[Y] = t2[Y]。即。， f (t(X)) = t [Y]</p><p>我们也说X→Y是一个函数依赖性，并且Y在函数上依赖于X。</p><p>X被称为左边的依赖性，Y被称为右边的依赖性。（left side），$Y$被称为<strong>右边依赖性</strong>（right side）。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li>每个名字都有一个唯一的电话号码和专业，假设名字是唯一的</li><li>每个课程都有一个唯一的教授</li><li>每个名字和课程都有一个唯一的成绩</li></ul><p>整理其关系为：</p><p>{Name} →{Phone_no , Major}<br>{Course} → {Prof}<br>{Name , Course} → {Grade}</p><p>也可以用这样的图表来展示</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210307221958.png" alt="image-20210307221958124" style="zoom: 25%;"></p><p>请注意，其他字段遵循以下规则：</p><p>{Name} → {Major}<br>{Course , Grade} → {Prof , Grade}</p><p>设$F$是字段的集合</p><p>定义1：$X\rightarrow Y$是从$F$推断出来的（或者$F$推断$X\rightarrow Y$)，写成</p><script type="math/tex; mode=display">F \vDash X \rightarrow Y</script><p>如果满足$F$的任何关系实例也必须满足$X→Y$。</p><p>不可能列出每一个关系来验证X→Y是否从F推导而来。</p><p>需要一组推导规则$ρ$，如:</p><p>根据定义1，$F$可推倒出$X→Y$，当且仅当用$ρ$推导时。</p><p><strong>符号</strong>：如果$X$和$Y$是属性的集合，我们用$XY$表示它们的并集。</p><h3 id="属性依赖性运算规则"><a href="#属性依赖性运算规则" class="headerlink" title="属性依赖性运算规则"></a>属性依赖性运算规则</h3><p>例如，设$ X = \{A, B\},  Y = \{B, C\}, XY = \{A, B, C\} $，那么有：</p><script type="math/tex; mode=display">\begin{array}{}F1 & (Reflexivity) & 如果  X ⊇ Y 那么 X →Y \\F2 & (Augmentation) & \{X → Y \} \vDash XZ → Y Z \\F3 & (Transitivity) & \{X → Y , Y → Z\} \vDash X → Z \\F4 & (Additivity) & \{X→ Y , X → Z\} \vDash X → Y Z \\F5 & (Projectivity) & \{X → Y Z\} \vDash X → Y \\F6 & (Pseudotransitivity) & \{X → Y , YZ → W\} \vDash XZ → W\end{array}</script><p><strong>例子</strong></p><p>给定$F = \{A→B,A→C,BC→D\}$，可推导出$A→D$</p><p>实际上，F4、F5、F6可以从F1、F2、F3中推倒出来。</p><h3 id="阿姆斯特朗原理（Armstrong’s-axioms）"><a href="#阿姆斯特朗原理（Armstrong’s-axioms）" class="headerlink" title="阿姆斯特朗原理（Armstrong’s axioms）"></a>阿姆斯特朗原理（Armstrong’s axioms）</h3><p>我们可以证明阿姆斯特朗的公理是正确和完整的：</p><p>声明：如果$F$用阿姆斯特朗公理导出$A→B$，那么根据定义1，$F \vDash A→B$。</p><p>完全：根据定义1，$F \vDash M→N$，则$F$利用阿姆斯特朗公理导出$M→N$。</p><h3 id="检查FD的算法"><a href="#检查FD的算法" class="headerlink" title="检查FD的算法"></a>检查FD的算法</h3><p>已知$F$，如何检查$X→Y$是否在$F^+$中?</p><p>$F^+$表示$FD$的最小集合</p><ul><li>包含F</li><li>在阿姆斯特朗公理下是封闭的（closed ）</li></ul><p>$F^+$是$F$的闭包。</p><p>如果$F = \{ A → B, B → C, A → C \}$，那么</p><script type="math/tex; mode=display">F^+ = \{AB \rightarrow A, AB \rightarrow B, AB \rightarrow C, AC \rightarrow A, AC \rightarrow B, \\AC \rightarrow C,  ABC \rightarrow A, ABC \rightarrow B, ABC \rightarrow C, AB \rightarrow AB, \\AB \rightarrow BC, AB \rightarrow AC, \dots \}</script><p>$F^+$对于$|F|$总是有一个指数大小。</p><p>为了计算成员资格，计算$F^+$太过复杂。实际上，我们可以计算$X$在$F$下的闭包$X^+$， $X^+$是由$X$函数决定的最大的属性集。</p><p>这是因为：</p><script type="math/tex; mode=display">\begin{array}{}S1: & X^+ = \cup_{\forall x \rightarrow A \in F^+}A \\S2: & X\rightarrow Y \in F^+ 当且仅当 Y \subseteq X^+\end{array}</script><h3 id="计算-X-的算法"><a href="#计算-X-的算法" class="headerlink" title="计算$X^+$的算法"></a>计算$X^+$的算法</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">X+ := X;change := true;while change dobeginchange := false;for each FD W → Z in F dobeginif (W ⊆ X+) and (Z    X+) then dobeginX+ := X+ ∪ Z;change := true;endendend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计算候选键的算法"><a href="#计算候选键的算法" class="headerlink" title="计算候选键的算法"></a>计算候选键的算法</h3><p>给定一个关系模式$R$和一组函数依赖$R$的$F$。</p><p>$R$的键$X$必须具有$X^+ = R$的性质。</p><p><strong>计算候选键的算法</strong></p><p>第一步：在$F$中给$X$赋一个超键</p><p>第二步：迭代地从$X$中移除属性，同时保留属性$X^+ = R$，直到$X$上没有裁减。</p><p>其余的$X$就是候选键。</p><h3 id="计算所有候选键的算法"><a href="#计算所有候选键的算法" class="headerlink" title="计算所有候选键的算法"></a>计算所有候选键的算法</h3><p>给定关系模式$R$和函数依赖$R$的集合$F$，计算所有候选键的算法如下:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">T := ∅Main:        X := S where S is a super key which does not contain any candidate key in T        remove := true        While remove do                 For each attribute A ∈ X                Compute {X-A}+ with respect to F                If {X-A}+ contains all attributes of R then                         X := X – {A} Else                          remove := false        T :=T ∪ X<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重复Main直到找不到可用的S为止。最后，T包含所有候选键。</p><p><strong>例子</strong></p><p>$R = \{A, B, C, D\} $，且$ F = \{ A → B, BC → D, A → C \} $</p><p>$X = \{A, B, C\} $ 如果$F$的左边是一个超级键。</p><p>不能删除$A$，因为$ \{BC\}^+ = \{B, C, D\} ≠ R$</p><p>$B$ 可以移除，因为$\{AC\}^+ = \{A, B, C, D\} = R\rightarrow     X = \{ A, C\}$</p><p>$C$ 可以进一步移除，因为$ \{A\}^+ = \{A, B, C, D\} \rightarrow X = \{A\}$</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9311 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNSW 课程笔记索引</title>
      <link href="/2021/03/07/unsw/unsw-ke-cheng-bi-ji-suo-yin/"/>
      <url>/2021/03/07/unsw/unsw-ke-cheng-bi-ji-suo-yin/</url>
      
        <content type="html"><![CDATA[<h2 id="课程标签"><a href="#课程标签" class="headerlink" title="课程标签"></a>课程标签</h2><p><a href="/tags/COMP9020/">COMP9020  Foundations of Computer Science 计算机科学基础/离散数学</a></p><p><a href="/tags/COMP9021/">COMP9021 Principles of Programming 编程原理</a></p><p><a href="/tags/COMP9024/">COMP9024 Data Structures and Algorithm 数据结构与算法</a></p><p><a href="/tags/COMP9311/">COMP9311 Database Systems 数据库系统/数据库基础</a></p><p><a href="/tags/COMP9331/">COMP9331 Computer Networks and Applications 计算机网络与应用</a></p><p><a href="/tags/COMP9414/">COMP9414 Artificial Intelligence 人工智能</a></p><h2 id="课程链接"><a href="#课程链接" class="headerlink" title="课程链接"></a>课程链接</h2><h3 id="COMP9024-Data-Structures-and-Algorithm-数据结构与算法"><a href="#COMP9024-Data-Structures-and-Algorithm-数据结构与算法" class="headerlink" title="COMP9024 Data Structures and Algorithm 数据结构与算法"></a>COMP9024 Data Structures and Algorithm 数据结构与算法</h3><p><a href="https://elgar.cse.unsw.edu.au/~cs9024/21T2/">课程综合信息首页</a><br><a href="https://cgi.cse.unsw.edu.au/~cs9024/21T2/outline/">课程大纲</a><br><a href="https://www.handbook.unsw.edu.au/postgraduate/courses/2021/COMP9024">课程手册</a></p><h3 id="COMP9331-Computer-Networks-and-Applications-计算机网络与应用"><a href="#COMP9331-Computer-Networks-and-Applications-计算机网络与应用" class="headerlink" title="COMP9331 Computer Networks and Applications 计算机网络与应用"></a>COMP9331 Computer Networks and Applications 计算机网络与应用</h3><p><a href="https://webcms3.cse.unsw.edu.au/COMP3331/21T2/outline">课程大纲</a><br><a href="https://edstem.org/courses/5963/discussion/">ED-9331</a></p><h3 id="COMP9414-Artificial-Intelligence-人工智能"><a href="#COMP9414-Artificial-Intelligence-人工智能" class="headerlink" title="COMP9414 Artificial Intelligence 人工智能"></a>COMP9414 Artificial Intelligence 人工智能</h3><p><a href="https://www.cse.unsw.edu.au/~cs9414/">课程大纲</a></p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9020 </tag>
            
            <tag> COMP9021 </tag>
            
            <tag> COMP9024 </tag>
            
            <tag> COMP9311 </tag>
            
            <tag> COMP9331 </tag>
            
            <tag> COMP9414 </tag>
            
            <tag> 手册 </tag>
            
            <tag> 持续更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学课程笔记（4）</title>
      <link href="/2021/03/07/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-4/"/>
      <url>/2021/03/07/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-4/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵（Matrices）"><a href="#矩阵（Matrices）" class="headerlink" title="矩阵（Matrices）"></a>矩阵（Matrices）</h2><p>$m\times n$矩阵是一个有m个水平行n个垂直列的数组</p><script type="math/tex; mode=display">\mathbf{A} = \begin{bmatrix}a_{11} & a_{12} & \cdots & a_{1n} \\a_{21} & a_{22} & \cdots & a_{2n} \\\vdots & \vdots &        & \vdots \\a_{m1} & a_{m2} & \cdots & a_{mn} \\\end{bmatrix}</script><p>对计算机科学来说，矩阵大有用处，如：</p><ul><li>优化（optimisation）</li><li>图形和计算机视觉（graphics and computer vision）</li><li>密码学（cryptography）</li><li>信息检索和网络搜索（information retrieval and web search）</li><li>机器学习（machine learning）</li></ul><h3 id="基本矩阵运算（Basic-Matrix-Operations）"><a href="#基本矩阵运算（Basic-Matrix-Operations）" class="headerlink" title="基本矩阵运算（Basic Matrix Operations）"></a>基本矩阵运算（Basic Matrix Operations）</h3><p><strong>转置矩阵</strong>（transpose）</p><p>对于$m\times n$的矩阵$\mathbf{A}=[a_{ij}]$，它的转置矩阵$\mathbf{A^T}$就是一个$n\times m$矩阵，其第$i$行第$j$列为$a_{ji}$</p><p>例如，</p><script type="math/tex; mode=display">\mathbf{A}=\begin{bmatrix} 2 & -1 & 0 & 4 \\3 & 2 & -1 & 2 \\4 & 0 & 1 &3\end{bmatrix}\quad\mathbf{A^T}=\begin{bmatrix} 2 & 3 & 4 \\-1 & 2 & 0 \\0 & -1 & 1 \\4 & 2 & 3\end{bmatrix}</script><p>如果$\mathbf{M^T}=\mathbf{M}$，那么这个矩阵$\mathbf{M}$叫做<strong>对称矩阵</strong>（symmetric）</p><p>两个$m\times n$矩阵$\mathbf{A}=[a_{ij}]$和$\mathbf{B}=[b_{ij}]$<strong>相加</strong>（<strong>sum</strong>）后，结果也是一个$m\times n$矩阵，其第$i$行第$j$列的值为$a_{ij}+b_{ij}$</p><p>事实上，$\mathbf{A}+\mathbf{B}=\mathbf{B}+\mathbf{A}$，且$(\mathbf{A}+\mathbf{B})+\mathbf{C}=\mathbf{A}+(\mathbf{B}+\mathbf{C})$</p><p>给定$m \times n$矩阵$\mathbf{A}=[a_{ij}]$，且$c\in \mathbb{R}$，<strong>标量乘积</strong>（<strong>scalar product</strong>）$c\mathbf{A}$是$m\times n$矩阵，其第$i$行第$j$列的值为$c\cdot a_{ij}$</p><p>$m \times n$矩阵$\mathbf{A}=[a_{ij}]$和$n \times p$矩阵$\mathbf{B}=[b_{jk}]$的积（product）为$m \times p$矩阵$\mathbf{C}=[c_{ik}]$</p><p>定义为</p><script type="math/tex; mode=display">c_{ik}=\sum_{j=1}^{n}a_{ij}b_{jk}\quad \text{对于}1\leq i \leq m \text{且} 1\leq k \leq p</script><p>注意，$\mathbf{A}$的列数和$\mathbf{B}$的行数必须相同</p><p>$1\times n$矩阵和$n\times 1$矩阵相乘通常叫<strong>n维向量</strong>（<strong>n-dimensional vectors</strong>）<strong>内积</strong></p><p>一般情况下，$\mathbf{A}\cdot\mathbf{B}\neq\mathbf{B}\cdot\mathbf{A}$</p><h4 id="例子：计算机图形"><a href="#例子：计算机图形" class="headerlink" title="例子：计算机图形"></a>例子：计算机图形</h4><p>旋转物体w.r.t. $x$轴旋转角度$\alpha$</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 0 & 0 \\0 & \cos{\alpha} & -\sin{\alpha} \\0 & \sin{\alpha} & \cos{\alpha}\end{bmatrix}\cdot\begin{bmatrix}5 & 5 & 7 & 7 & 5 & 7 & 5 & 7 \\1 & 1 & 1 & 1 & 3 & 3 & 3 & 3 \\9 & 7 & 7 & 9 & 7 & 7 & 9 & 9 \\\end{bmatrix}</script><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210305193328.png" alt="3维空间物体旋转"></p><h2 id="关系及其表达"><a href="#关系及其表达" class="headerlink" title="关系及其表达"></a>关系及其表达</h2><p>关系是一种抽象的概念，用于捕获特定领域(通常是多个对象的同一领域)的相关对象。这些对象可能是：</p><ul><li>相互影响（彼此为二元关系；自我(?)一元）</li><li>共享一些共同的属性</li><li>当满足某些约束时，它们就会精确地对应起来</li></ul><p>一般来说，关系形式化了来自不同领域的对象之间相互作用的概念；但是，对于每种类型的对象必须有一个指定的域。</p><p>一个<strong>n元关系</strong>是n个集合的笛卡尔积的子集。</p><script type="math/tex; mode=display">\mathcal{R}\subseteq S_1 \times S_2 \times \dots \times S_n</script><script type="math/tex; mode=display">x \in \mathcal{R} \Rightarrow x = (x_1,x_2,\dots,x_n)\text{其中，每个}x_i \in S_i</script><p>如果$n=2$，则有二元关系$\mathcal{R}\subseteq S \times T$</p><p>等价标记：$(x_1,x_2,\dots x_n)\in \mathcal{R} \Leftrightarrow \mathcal{R}(x_1,x_2,\dots x_n)$</p><p>对二元关系：$(x,y)\in \mathcal{R} \Leftrightarrow \mathcal{R}(x,y) \Leftrightarrow x\mathcal{R}y$</p><h3 id="数据库实例"><a href="#数据库实例" class="headerlink" title="数据库实例"></a>数据库实例</h3><p>若S为学生的一个子集，C是课程的一个子集，E为选课，则E可表示为$E=\{(s,c):s\ 选了\ c\}$</p><script type="math/tex; mode=display">E \subseteq S \times C</script><p>在实践中，在数据库关系上几乎总是存在各种各样的“onto”(非空性)和1-1(唯一性)约束。</p><p>若C为课程，T为开始时间，R为教室，S为课程安排，则</p><script type="math/tex; mode=display">S=\{(c,t,r):c 在t时间在r教室\} \subseteq C \times T \times R</script><p>又比如，在运动状态里</p><script type="math/tex; mode=display">\mathcal{R}\subseteq 比赛 \times 成绩 \times 年份 \times 运动员</script><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>关系在计算机科学中普遍存在</p><ul><li>数据库是关系的集合</li><li>常见的数据结构（例如图）是关系</li><li>任何顺序都是一个关系</li><li>函数/程序/程序计算其输入和输出之间的关系</li></ul><h3 id="n元关系（n-ary-Relations）"><a href="#n元关系（n-ary-Relations）" class="headerlink" title="n元关系（n-ary Relations）"></a>n元关系（n-ary Relations）</h3><p>关系可以定义同时连接$k≥1$个域$D_1,\dots,D_k$。</p><p>在数据库中允许1元关系(n=1)。</p><p>更多的时候是<strong>二元关系(binary relations)</strong></p><script type="math/tex; mode=display">\mathcal{R} \subseteq S \times T; \mathcal{R}=\{(s,t):某些属性连接s,t\}</script><p>有关联的$s,t$可以写作$(s,t)\in \mathcal{R}$或$s\mathcal{R}t$，没有关联的项目记作$(s,t)\not\in \mathcal{R}$或$s\not\mathcal{R}t$</p><p>$\mathcal{R}$可定义为</p><ul><li><p>相关k元组的显式枚举(二元关系中的有序对)；</p></li><li><p>标识整个$D_1 \times D_2 \times \dots D_k$相关元组的属性</p></li><li><p>从其他关系建立</p></li></ul><h3 id="函数和关系"><a href="#函数和关系" class="headerlink" title="函数和关系"></a>函数和关系</h3><p>任何函数$f:S\rightarrow T$可以被视为二元关系$\{(s,f(s)):s\in S\}\subseteq S \times T$</p><p>如果S × T的一个子集对应于一个函数，它必须满足一定的条件</p><h3 id="二元关系（Binary-Relations）"><a href="#二元关系（Binary-Relations）" class="headerlink" title="二元关系（Binary Relations）"></a>二元关系（Binary Relations）</h3><p>一个二元关系$\mathcal{R}\subseteq S \times T$，可以被表示为一个矩阵，行(元素)由S枚举，列为T</p><p>例如，设$S=\{s_1,s_2,s_3\}$，同时$T=\{t_1,t_2,t_3,t_4\}$，那么可能有</p><script type="math/tex; mode=display">\begin{bmatrix}\bullet & \circ & \bullet & \bullet \\\circ & \bullet & \bullet & \bullet \\\bullet & \bullet & \circ & \circ\end{bmatrix}</script><h3 id="单个域上的关系（Relations-on-a-Single-Domain）"><a href="#单个域上的关系（Relations-on-a-Single-Domain）" class="headerlink" title="单个域上的关系（Relations on a Single Domain）"></a>单个域上的关系（Relations on a Single Domain）</h3><p>特别重要的是同一集合的元素之间的二元关系。我们说’ R是S上的二元关系’，如果$\mathcal{R}\subseteq S \times S$</p><h3 id="特殊（简单的）关系-（Special-Trivial-Relations）"><a href="#特殊（简单的）关系-（Special-Trivial-Relations）" class="headerlink" title="特殊（简单的）关系 （Special (Trivial) Relations）"></a>特殊（简单的）关系 （Special (Trivial) Relations）</h3><p><strong>一致性（Identity）</strong>$E=\{(x,x):x \in S\}$</p><p><strong>空（Empty）</strong>：$\empty$</p><p><strong>普遍性（Universal）</strong>$U = S \times S$</p><h3 id="二元关系的重要特性"><a href="#二元关系的重要特性" class="headerlink" title="二元关系的重要特性"></a>二元关系的重要特性</h3><p>对于$\mathcal{R}\subseteq S \times S$，可能有以下属性</p><script type="math/tex; mode=display">\begin{array}{1}(R) & \text{自反性（reflexive）} & (x,x) \in \mathcal{R} & \forall x \in S \\(AR) & \text{反自反性（antireflexive）} & (x,x) \not\in \mathcal{R} & \forall x \in S \\(S) & \text{对称性（symmetric）} & (x,y) \in \mathcal{R} \Rightarrow (y,x) \in \mathcal{R} & \forall x \in S \\(AS) & \text{反对称性（antisymmetric）} & (x,y),(y,x)\in \mathcal{R} \Rightarrow x =y & \forall x,y \in S \\(T) & \text{传递性（ transitive）} & (x,y),(y,z) \in \mathcal{R} \Rightarrow (x,z) \in \mathcal{R} & \forall x,y,z \in S\end{array}</script><p>如果一个对象、概念等的任何实例都没有违反该属性的任何定义语句，那么它就被认为满足该属性。</p><h3 id="属性的交互（Interaction-of-Properties）"><a href="#属性的交互（Interaction-of-Properties）" class="headerlink" title="属性的交互（Interaction of Properties）"></a>属性的交互（Interaction of Properties）</h3><p>关系既可以是对称的（symmetric），也可以是反对称的（ antisymmetric）。即当$R$仅由某些对$(x, x)$组成时，$x∈S$。</p><p>一种关系不能同时是自反的（reflflexive ）和反自反的（antireflflexive），除非$S=\empty$</p><p>注意：</p><p>nonrelexive $\neq$ antireflexive/irreflexive</p><p>nonsymmetric $\neq$ antisymmetric</p><p>一个关系可以是 nonreflflexive但不是antireflflexive。<br>一个关系可以是 nonsymmetric 而不是 antisymmetric。</p><h4 id="S上的一些重要的关系"><a href="#S上的一些重要的关系" class="headerlink" title="S上的一些重要的关系"></a>S上的一些重要的关系</h4><ul><li>全序，如$\leq 在数字上$</li></ul><script type="math/tex; mode=display">\begin{bmatrix}\bullet & \bullet & \bullet \\\circ & \bullet & \bullet  \\\circ & \circ & \bullet\end{bmatrix}</script><ul><li>偏序，如$\subseteq在集合$</li></ul><script type="math/tex; mode=display">\begin{bmatrix}\bullet & \bullet & \bullet \\\circ & \bullet & \circ  \\\circ & \circ & \bullet\end{bmatrix},\begin{bmatrix}\bullet & \bullet & \circ \\\circ & \bullet & \circ  \\\circ & \circ & \bullet\end{bmatrix}</script><ul><li><p>等价</p><script type="math/tex; mode=display">\begin{bmatrix}\bullet & \bullet & \circ \\\bullet & \bullet & \circ  \\\circ & \circ & \bullet\end{bmatrix}</script></li><li><p>同一性</p></li></ul><script type="math/tex; mode=display">\begin{bmatrix}\bullet & \circ & \circ \\\circ & \bullet & \circ  \\\circ & \circ & \bullet\end{bmatrix}</script><p>注意，其中一些是其他情况的特殊情况，如“”部分顺序”的“总顺序”，“等价”的“恒等”。</p><h3 id="把-mathcal-R-作为S和T的对应关系"><a href="#把-mathcal-R-作为S和T的对应关系" class="headerlink" title="把$\mathcal{R}$作为S和T的对应关系"></a>把$\mathcal{R}$作为S和T的对应关系</h3><p>逆关系$\mathcal{R}^{\leftarrow}$:</p><script type="math/tex; mode=display">\mathcal{R}^{\leftarrow}=\{(t,s)\in T \times S: (s,t)\in \mathcal{R}\}</script><p>记为$\mathcal{R}^{\leftarrow}\subseteq T \times S$</p><p>很明显，$(\mathcal{R}^{\leftarrow})^{\leftarrow}=\mathcal{R}$</p><p>对于子集：</p><p>$\mathcal{R}(A)\overset{def}=\{t\in T:(s,t)\in \mathcal{R} \text{对一些}s\in A \subseteq S\}$</p><p>$\mathcal{R}^{\leftarrow}(B)\overset{def}=\{s\in S:(s,t)\in\mathcal{R}对一些t\in B \subseteq T\}$</p><p>注意，$\mathcal{R}$可以是$Pow(S)$到$Pow(T)$的关系，但是并不是所有的$Pow(S)\rightarrow Pow(T)$都可以一一映射。</p><p>注意，$S$和$T$的轴的顺序是重要的。对于$\mathcal{R}\subseteq S \times S$，它的逆矩阵$\mathcal{R}^{\leftarrow}$通常与$\mathcal{R}$非常不同</p><h3 id="结合关系-Combining-Relations"><a href="#结合关系-Combining-Relations" class="headerlink" title="结合关系 Combining Relations"></a>结合关系 Combining Relations</h3><p>$\mathcal{R}_1,\mathcal{R}_2 \in (R) \Rightarrow \mathcal{R}_1\cup \mathcal{R}_2 \in (R)$</p><p>$\mathcal{R}_1,\mathcal{R}_2 \in (S) \Rightarrow \mathcal{R}_1\cup \mathcal{R}_2 \in (S)$</p><p>$\mathcal{R}_1,\mathcal{R}_2 \in (T) \not\Rightarrow \mathcal{R}_1\cup \mathcal{R}_2 \in (R)$</p><h3 id="关系的合成-Composition-of-Relations"><a href="#关系的合成-Composition-of-Relations" class="headerlink" title="关系的合成 Composition of Relations"></a>关系的合成 Composition of Relations</h3><p><strong>定义</strong></p><p>二元关系复合$R_1 \subseteq S \times T$且$R_2 \subseteq T \times U$</p><p>$R1;R2=\{(s,u):(s,t)\in R_1 \land (t,u) \in R_2 \text{对于一些}t \in T\} \subseteq S \times U$</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>函数：(co-)domain, image, composition $f\circ q, f^{-1}, f^{\leftarrow}$</p><p>函数的属性：onto, 1-1</p><p>数组操作：transposition, sum, scalar product, product</p><p>二元关系特性：R, AR, S, AS, T</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9020 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 离散数学 </tag>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全部标签和分类</title>
      <link href="/2021/03/05/shi-yong-gong-ju/quan-bu-biao-qian-he-fen-lei/"/>
      <url>/2021/03/05/shi-yong-gong-ju/quan-bu-biao-qian-he-fen-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="快速复制"><a href="#快速复制" class="headerlink" title="快速复制"></a>快速复制</h2><h3 id="全部标签"><a href="#全部标签" class="headerlink" title="全部标签"></a>全部标签</h3><pre class="line-numbers language-none"><code class="language-none">- COMP9020- COMP9021- COMP9311- 数据库- 离散数学- Python- SQL- Hexo- Java- Linux- 游戏- 英语- 监控系统- 理财- 工具- 手册- 教程- 课程笔记- 实践操作- 生活感悟- 编辑中- 持续更新- 已完稿<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全部分类"><a href="#全部分类" class="headerlink" title="全部分类"></a>全部分类</h3><pre class="line-numbers language-none"><code class="language-none">UNSW实用工具技术学习最佳实践学习笔记生活纪实<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="UNSW课程"><a href="#UNSW课程" class="headerlink" title="UNSW课程"></a>UNSW课程</h3><ul><li>COMP9020：UNSW课程代码，课程名称为计算机基础（Foundations of Computer Science ）</li><li>COMP9021：UNSW课程代码，课程名称为编程原理（Principles of Programming）</li><li>COMP9311：UNSW课程代码，课程名称为数据库系统（Database Systems ）</li></ul><h3 id="内容与技术"><a href="#内容与技术" class="headerlink" title="内容与技术"></a>内容与技术</h3><ul><li>数据库：数据库与其操作相关</li><li>离散数学：离散数学相关</li><li>Python：Python计算机语言相关</li><li>SQL：SQL语言相关</li><li>Hexo：Hexo技术相关</li><li>游戏：游戏开发相关</li><li>英语：英语学习相关</li></ul><h3 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h3><ul><li>工具：用于本站的记录与维护</li><li>手册：主要用户资料查询的文档</li><li>教程：用于介绍操作流程等性质的文档</li><li>课程笔记：记录课堂所学内容的文档</li><li>实践操作：记录实践操作相关的文档</li></ul><h3 id="文档状态"><a href="#文档状态" class="headerlink" title="文档状态"></a>文档状态</h3><ul><li>编辑中：当前文档正在编辑状态，即还未编写完成</li><li>持续更新：当前文档已包含一定信息，并将在未来持续更新其内容</li><li>已完稿：当前文档已编写完成，未来仅在疏漏、补遗时修改</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>UNSW：澳大利亚新南威尔士大学课程相关</li><li>实用工具：可用于实际操作的内容</li><li>技术学习：用于计算机技术学习</li></ul>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持续更新 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学课程笔记（3）</title>
      <link href="/2021/03/04/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-3/"/>
      <url>/2021/03/04/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-3/</url>
      
        <content type="html"><![CDATA[<h2 id="函数（Functions）"><a href="#函数（Functions）" class="headerlink" title="函数（Functions）"></a>函数（Functions）</h2><p>我们把函数作为集合论的概念来处理，它是两个集合之间的一种特殊的对应。</p><p>$f: S→T$描述了集合的配对，即$f$给每个元素$s∈S$都赋一个唯一的元素$t∈T$。</p><p>$S$——$f$域（domain），符号$Dom(f)$</p><p>$T$——$f$上域（codomain），符号Codom(f)</p><p>$\{f(x):x \in Dom(f)\}$——$f$镜像(image)，符号$Im(f)$</p><script type="math/tex; mode=display">Im(f)\subseteq Codom(f)</script><p>每个函数都把它的定义域映<strong>into</strong>射到它的上域，但只是映射<strong>onto</strong>到它的像上。</p><h3 id="复合函数（Composition-of-Functions）"><a href="#复合函数（Composition-of-Functions）" class="headerlink" title="复合函数（Composition of Functions）"></a>复合函数（Composition of Functions）</h3><p>$f:x \mapsto y, f:A \mapsto B$</p><p>第一个式子表示x映射到y，第二个式子表示B是在f下A的映射，$f:B=\{f(s):s \in A\}$</p><p><strong>定义</strong>：复合函数描述为$g\circ f:x\mapsto g(f(x))$，要求$Im(f)\subseteq Dom(g)$</p><p>如果一个函数将集合映射到自身，例如，当$Dom(f)=Codom(f)$，同时也因此$Im(f)\subseteq Dom(f)$，那么该函数可以与自身组合，这被叫做<strong>迭代iterated</strong></p><script type="math/tex; mode=display">f \circ f, f\circ f \circ f, \dots, \text{也写做} f^2,f^3,\dots</script><p>组合是<strong>联合的associative</strong></p><script type="math/tex; mode=display">h \circ (g \circ f) = (h \circ g) \circ f, \text{可写作}h \circ g \circ f</script><p>S函数的<strong>同一性identity</strong></p><script type="math/tex; mode=display">Id_S(x)=x,x\in S; Dom(i)=Codom(i)=Im(i)=S</script><p>对于$g:s\rightarrow T \quad g\circ Id_S = g, Id_T \circ g =g$</p><h4 id="gcd例子"><a href="#gcd例子" class="headerlink" title="gcd例子"></a>gcd例子</h4><p>考虑gcd为高阶函数，定义为</p><script type="math/tex; mode=display">gcd(f)(m,n)=\begin{cases} m & \text{if} \quad m=n \\f(m-n,n) & \text{if} \quad m>n \\f(m,n-m) & \text{if} \quad m<n\end{cases}</script><p>它的类型是$gcd:(\mathbb{P}^2 \not \rightarrow \mathbb{P})\rightarrow (\mathbb{P}^2 \not\rightarrow \mathbb{P})$</p><p>也就是说，它将每个部分函数(从一对正整数到一个正整数)映射到同一类型的(部分)函数。这种函数中最糟糕的是“无处定义”的函数。</p><script type="math/tex; mode=display">f_\bot (m,n)=\bot</script><p>偏函数（partial function）$f: S \not \rightarrow T$ 是一个函数$f:S’ \rightarrow T 当 S’\subseteq S$</p><h2 id="函数的性质"><a href="#函数的性质" class="headerlink" title="函数的性质"></a>函数的性质</h2><h3 id="满射onto"><a href="#满射onto" class="headerlink" title="满射onto"></a>满射onto</h3><p>如果上域codomain的每个元素被域中至少一个x映射到，则函数叫做<strong>onto</strong>(或满射<strong>surjective</strong>)。</p><script type="math/tex; mode=display">Im(f) = T</script><h3 id="1-1-函数"><a href="#1-1-函数" class="headerlink" title="1-1 函数"></a>1-1 函数</h3><p>如果不同的x对应不同的y，则叫做<strong>1-1 one-to-one</strong>或<strong>单射injective</strong>函数</p><script type="math/tex; mode=display">f(x)=f(y)\Rightarrow x=y</script><h3 id="逆函数-Inverse-Functions"><a href="#逆函数-Inverse-Functions" class="headerlink" title="逆函数 Inverse Functions"></a>逆函数 Inverse Functions</h3><p><strong>定义</strong></p><p>对给定的函数$f:S\rightarrow T$，$f^{-1}:T\rightarrow S$，满足$f^{-1}\circ f=Id_S$</p><p>例如， $f^{-1}(f(x))=x，\forall x \in S$</p><p>当$f$既为1-1又为满射时存在</p><p><strong>逆镜像</strong>（inverse image）$f^{\leftarrow}(B)=\{s \in S : f(s) \in B\} \subseteq S$</p><p>对于$t \in T$ ，写作$f^{\leftarrow}(t)$对于集合$f^{\leftarrow}(\{t\})$</p><p>如果$f^{-1}$存在，那么$f^{\leftarrow}(t)=\{f^{-1}(t)\}$</p><p>$f(\empty)=\empty , f^{\leftarrow}(\empty)=\empty$</p><p>对于有限的集合$S$和$f：S\rightarrow S $，满射和1-1 是等价的（equivalent）</p><blockquote><p> <strong>参考资料</strong></p><p>Textbook (R &amp; W) - Ch. 1, Sec. 1.7; Ch. 3. Sec. 3.1, 3.3</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9020 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 离散数学 </tag>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础实践记录（2）</title>
      <link href="/2021/03/04/unsw/comp9311/shu-ju-ku-ji-chu-shi-jian-ji-lu-2/"/>
      <url>/2021/03/04/unsw/comp9311/shu-ju-ku-ji-chu-shi-jian-ji-lu-2/</url>
      
        <content type="html"><![CDATA[<h2 id="实践目标"><a href="#实践目标" class="headerlink" title="实践目标"></a>实践目标</h2><ul><li>使用SQL数据定义语言指定模式</li><li>定义数据约束</li><li>将元组加载到数据库</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="http://www.postgresql.org/docs/9.3/interactive/index.html">PostgreSQL 用户手册</a></p><ul><li><p>本次任务的目的是为有很多部门的公司建立一个简单的数据库。要求如下：</p></li><li><p>每个部门有一个管理者（manager）</p></li><li><p>每个部门有一条使命宣言（mission statement），其由一组关键词构成，如承诺、服务、创新等</p></li><li><p>公司使用数字标识各个部门</p></li><li><p>对每个员工，需要记录姓名及税务档案编号（tax file number），以及他们每周的工作时长，单位小时</p></li><li><p>每个员工可能任职于多个部门，需要记录他们在每个部门花费的时长占总时长的比例</p></li><li><p>每个员工最少就职于一个部门</p></li><li><p>部门的管理者任全职</p></li></ul><p>据此，ER图可设计如下：</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210304010802.png" alt="ER图"></p><p>本次实验依据此图做数据库表结构设计</p><p>假设该公司的具体情况如下：</p><ul><li>有三个部门：行政（Administration）、研发（Research）、销售（Sales）</li><li>行政部门编号为 #001</li><li>行政部门的使命是：创新（innovation）、可靠（reliability）、盈利（profit）</li><li>研发部门编号为 #003</li><li>研究的使命是：创新（innovation）、科技（technology）</li><li>销售部有编号为 #002</li><li>销售的使命是：以客户为中心（customer-focus），不断成长（growth）</li><li>行政管理工作由John Smith负责，他每周工作40小时</li><li>研发工作由Walter Wong负责，他每周工作50小时</li><li>销售经理是Pradeep Sharma，她每周工作30个小时</li><li>Tom Robbins每周工作35小时，一半时间做行政工作，一半时间做销售</li><li>Adam Spencer每周工作50小时，大部分时间(90%)在销售部门，其余时间在行政部门</li><li>Susan Ryan每周在行政部门工作60个小时</li><li>Steven Smooth是一名全职销售人员(每周45小时)</li><li>Max Schmidt, Maria Orlowska和Yusif Budianto全职从事研发工作(每周40小时)</li></ul><p>以下数据来自澳大利亚税务局，给出了上述每个雇员的税务档案号码:</p><div class="table-container"><table><thead><tr><th><strong>Employee</strong></th><th><strong>Tax File #</strong></th></tr></thead><tbody><tr><td>Yusif Budianto</td><td>777-654-321</td></tr><tr><td>Maria Orlowska</td><td>123-987-654</td></tr><tr><td>Tom Robbins</td><td>323-626-929</td></tr><tr><td>Susan Ryan</td><td>993-893-864</td></tr><tr><td>Max Schmidt</td><td>419-813-573</td></tr><tr><td>Pradeep Sharma</td><td>222-333-444</td></tr><tr><td>John Smith</td><td>123-234-456</td></tr><tr><td>Steven Smooth</td><td>632-647-973</td></tr><tr><td>Adam Spencer</td><td>747-400-123</td></tr><tr><td>Walter Wong</td><td>326-888-711</td></tr></tbody></table></div><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="1-下载3个SQL文件"><a href="#1-下载3个SQL文件" class="headerlink" title="1. 下载3个SQL文件"></a>1. 下载3个SQL文件</h3><p>  其中:<br>  schema.sql：含上述ER设计的关系模式，只是它缺少图中建议的所有约束，也缺少一些常识或应用程序约束</p><p>data.sql：包含一组有效的元组，根据上面的描述填充这个模式，并满足所有的域约束</p><p>bad.sql：包含此模式的无效元组集合</p><p>以上文件位于/home/cs9311/web/21T1/lab/02中，复制这些文件到私有目录下，并查阅编辑。</p><h3 id="2-创建一个新数据库来保存公司信息"><a href="#2-创建一个新数据库来保存公司信息" class="headerlink" title="2. 创建一个新数据库来保存公司信息"></a>2. 创建一个新数据库来保存公司信息</h3><p>登录grieg服务器，使用<code>createdb</code>命令创建company数据库</p><h3 id="3-将模式加载到数据库"><a href="#3-将模式加载到数据库" class="headerlink" title="3. 将模式加载到数据库"></a>3. 将模式加载到数据库</h3><p>输入以下命令，载入模式文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">psql company -f schema.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行此命令后，正常情况下，将会创建出4个表。</p><p>如果再次执行此命令，应该会得到一些ERROR级别信息。</p><p>在PostgreSQL控制台中通过文件载入SQL文件的方法为：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">psql company# 先进入到PostgreSQL控制台中，并指定company数据库company=# \i schema.sql# 通过\i 命令，载入文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入以下命令，查看现有数据库表信息：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">company=# \d# 查看所有表结构company=# \d Employees# 查看Employees表结构company=# select * from Employees;# 查看Employees表数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-将有效数据加载到模式中"><a href="#4-将有效数据加载到模式中" class="headerlink" title="4. 将有效数据加载到模式中"></a>4. 将有效数据加载到模式中</h3><p>将data.sql加载到数据库中</p><pre class="line-numbers language-none"><code class="language-none">psql company -f data.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，可通过PostgreSQL控制台查看表数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from Employees;# 查询所有Employees表数据select count(*) from Departments;# 统计部门总数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>根据输出结果，试着回答以下问题：</p><ul><li>哪位员工每周工作时间最长?</li><li>销售部经理姓什么?</li><li>每个员工每周在每个部门工作多少小时?</li></ul><h3 id="5-将无效数据加载到模式中"><a href="#5-将无效数据加载到模式中" class="headerlink" title="5. 将无效数据加载到模式中"></a>5. 将无效数据加载到模式中</h3><p>运行以下命令，将bad.sql加载到模式中</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">psql company -f bad.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看数据库表，可知这些数据为垃圾数据，能够被加入到数据库中，是因为数据库中的各个主键、约束等都没有设置。</p><p>现在，使用<code>drop</code>命令，删除company数据库。</p><h3 id="6-向模式中添加约束"><a href="#6-向模式中添加约束" class="headerlink" title="6. 向模式中添加约束"></a>6. 向模式中添加约束</h3><p>原始的模式配置文件没有任何约束，仅做了如下的定义：</p><ul><li>Employees.hoursPweek属性必须是一个浮点数</li><li>Employees.givenName是一个长度不超过30个字符的字符串</li><li>员工税务文件编号为11个字符的字符串</li></ul><p>现在，你自己考虑如何增加限制，使错误数据无法添加到数据库中</p><p>从ER图看，有一些缺失显而易见，比如缺少主键和外键约束。</p><p>现在，你需要实现的需求是：</p><ul><li>所有的TFN都是’ddd-ddd-ddd’的形式，其中每个d代表一个数字</li><li>每个人都有名，但不一定有姓(如Prince)。</li><li>没有人可以每周工作超过一周的时间(每周有7*24 = 168小时)</li><li>每周工作负小时是没有意义的</li><li>所有部门代码都是由三位数字组成的</li><li>两个部门不能有相同的名称或相同的经理</li><li>员工在部门工作的时间百分比必须大于零</li><li>一个员工可能会在一个特定的部门中花费他们全部的时间</li></ul><p>修改schema.sql文件，来实现上述要求。</p><p>可以使用以下命令，重复执行来检查/载入schema.sql文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ createdb company$ psql company -f schema.sql ... Produces error messages .... ... Fix schema definition using editor in other window ...$ dropdb company$ createdb company$ psql company -f schema.sql...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于PostgreSQL在创建和销毁数据库的时候花费时间太长，你可以运行drop.sql，直接清空数据库，而无需重新创建和销毁数据库。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ createdb company   ... You only need to do this once ...$ psql company...company=# \i schema.sql ... Produces notices about creating tables, etc ... ... along with error messages if there are problems with your schema definition ...company=# \i drop.sql ... Produces a bunch of DROP TABLE messages ... ... May also produce ERRORS if some tables weren't created above ... ... These ERRORS can obviously be ignored ...company=# \i schema.sql ... Produces notices about creating tables, etc ... ... along with error messages if there are problems with your schema definition ...company=# \i drop.sql... ... Continue like this until the schema loads successfully ... ... i.e. until \i schema.sql produces no ERROR messages ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，根据PostgreSQL的规则，有时其在提示错误信息时给出的行号不是实际问题的行号。因此当出现错误信息时，需要自行判断问题所在位置。</p><h3 id="7-将有效数据加载到新数据库中"><a href="#7-将有效数据加载到新数据库中" class="headerlink" title="7. 将有效数据加载到新数据库中"></a>7. 将有效数据加载到新数据库中</h3><p>当成功载入schema后，运行以下命令，加载数据库数据</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">psql company    ...company=# \i data.sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于数据库增加了限制，在加载这些数据时可能会产生错误。思考如何修改这些数据，使他们能够加载成功。</p><p>实现这些功能的一种常规操作步骤如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ createdb company$ psql company -f schema.sql$ psql company -f data.sql ... Produces error messages ... ... Fix data.sql using editor in other window ...$ dropdb company$ createdb company$ psql company -f schema.sql$ psql company -f data.sql...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于这种操作方式太过繁琐，因此建议使用clean.sql脚本，直接清除数据库表中的全部数据</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ psql company...company=# \i data.sql ... If it produces error messages ... ... fix data.sql using editor in other window ...company=# \i clean.sql ... Produces messages about deleting tuples ...company=# \i data.sql ... Repeat until this step produces no errors ......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当成功载入数据后，接下来就该准备载入bad.sql中的数据。</p><p>注意，你可以试着修改clean.sql中的语句顺序，执行后看看会有什么区别。</p><p>drop.sql的作用是删除全部数据库表，clean.sql的作用是删除全部表中的数据。</p><h3 id="8-拒绝插入无效数据"><a href="#8-拒绝插入无效数据" class="headerlink" title="8. 拒绝插入无效数据"></a>8. 拒绝插入无效数据</h3><p>当完整插入data数据后，尝试插入bad数据：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ psql company...company=# \i bad.sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所有bad中的数据在插入数据库时均应出现ERROR错误提示。如果有数据被插入到数据库，说明schema中限制条件不足。</p><p>重复以下操作，直到数据库拒绝全部bad.sql中的数据</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ psql company...company=# \i schema.sql ... Produces notices about creating tables, etc ...company=# \i data.sql ... Produces INSERT messages; loads valid data ...company=# \i bad.sql ... If it produces any INSERT messages, your schema is incorrect, so you should use a text editor to change schema.sql ...company=# \i drop.sql ... Produces DROP TABLE messages; leaves empty database ...company=# \i schema.sql ... Produces notices about creating tables, etc ...company=# \i data.sql ... Produces INSERT messages; loads valid data...company=# \i bad.sql... ... Continue like this until your schema is correct i.e. until you receive only ERROR messages from \i bad.sql ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-挑战-复杂的约束1"><a href="#9-挑战-复杂的约束1" class="headerlink" title="9. 挑战:复杂的约束1"></a>9. 挑战:复杂的约束1</h3><p><strong>练习:</strong></p><p>考虑如何实现以下约束:</p><ul><li>没有一个工人可以有超过100%的时间分配</li></ul><p>可以使用以下语句，作为测试SQL，插入非法数据：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">insert into WorksFor values ('747-400-123','003',10);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提示:你将需要使用<a href="http://www.postgresql.org/docs/9.3/static/plpgsql.html">PLpgSQL</a>和 <a href="http://www.postgresql.org/docs/9.3/static/triggers.html">triggers</a>，我们将在几周的课程中讨论。</p><h3 id="10-挑战-复杂的约束2"><a href="#10-挑战-复杂的约束2" class="headerlink" title="10. 挑战:复杂的约束2"></a>10. 挑战:复杂的约束2</h3><p>考虑上述ER设计的一个变体，其中每个员工只为一个部门工作:</p><p><img src="https://www.cse.unsw.edu.au/~cs9311/21T1/lab/02/Pic/schema2.png" alt="ER图-变体"></p><p>这可能会对关系模式造成的改变如下：</p><ul><li><p>现在员工和部门之间的关系是n:1而不是n:m</p></li><li><p>WorksFor表将被Employees表中的一个非空外键所取代(非空，因为每个员工都必须为一个部门工作)</p></li><li><p>属性“fraction”可以被删除，因为该分数总是100%</p></li></ul><p>修改现有模式，使其正确地实现新的ER模型，然后尝试插入一些数据。</p><p>正确修改后，可能会出现这样的问题：如果想要增加新员工，比如已经存在一个部门才能与这个员工关联；；但是，在没有可以作为部门经理的员工前，不能插入任何部门元组。</p><p>如何解决这个问题呢?</p><p>有两种应对策略：</p><ul><li><p>移除一些与Employees.worksFor属性或Departments.manager属性相关联的约束</p><ul><li><p>好处：</p><p>1）这将允许在插入employee元组或Departments元组时，另一个元组非必须存在</p></li><li><p>缺点：</p><p>1） 这样做意味着ER模型所隐含的一些语义，如员工必须为某些部门工作，而部门必须有一个经理被删除了</p><p>2）在填充数据库之后，可以通过alter table命令添加约束，但是此时，如果已经存在无效数据的话，这些数据将被保留。</p><p>3）如果需要添加由新员工管理的新部门，则需要再次删除约束，将添加的内容添加到数据库，然后恢复约束。</p></li></ul></li><li><p>更好的方法是，同时插入一个新雇员和一个新部门，这两个操作合并为一组操作进行处理。延迟约束检查到两个元组都插入完成之后。如果两个元组都满足coinstaints，那么操作是成功的。如果约束不满足，那么两个元组都应该被删除。将多个更新作为一个操作处理的方法称为事务。</p></li></ul><p>PostgreSQL有一个方法可以指定约束检查延迟到事务结束时进行。在create table语句的文档中有关于可延迟约束的描述，在set constraints文档中有更多的解释。现在可以开始阅读这些文档，然后找出实现方法。</p><p><strong>练习</strong>: 尝试实现这两种方案来处理“相互依赖的”外键约束。</p><h2 id="本练习需要用到的技术总结"><a href="#本练习需要用到的技术总结" class="headerlink" title="本练习需要用到的技术总结"></a>本练习需要用到的技术总结</h2><h4 id="Shell及数据库命令："><a href="#Shell及数据库命令：" class="headerlink" title="Shell及数据库命令："></a>Shell及数据库命令：</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">createdb company# 创建company数据库dropdb company# 删除company数据库psql company# 进入company数据库psql company -f schema.sql# 数据库company载入schema.sql文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="PostgreSQL命令："><a href="#PostgreSQL命令：" class="headerlink" title="PostgreSQL命令："></a>PostgreSQL命令：</h4><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">company=# \d// 查看所有表结构company=# \d Employees// 查看Employees表结构company=# \i schema.sql// 在PostgreSQL控制台中载入SQL文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from Employees;# 查询所有Employees表数据select count(*) from Departments;# 统计部门总数create table tablename(attributes)  # 建表语句insert into WorksFor values ('747-400-123','003',10);# 向表中插入数据delete from WorksFor;# 删除表数据drop table WorksFor;# 删除表定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SQL表定义及约束"><a href="#SQL表定义及约束" class="headerlink" title="SQL表定义及约束"></a>SQL表定义及约束</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">// 属性定义相关char(11)// 字符，长度11varchar(30)// 变长字符，长度30float// 浮点类型// 属性约束相关PRIMARY KEY// 增加主键约束NOT NULL// 非空约束UNIQUE// 唯一性约束REFERENCE tablename(keyname)// 外键约束CHECK(condition)// 内容约束，其中condition是约束条件// CHECK约束条件表达式相关key LIKE 'express'// 按SQL表达式约束key SIMILAR TO 'express'// 按正则表达式约束key &gt;= and or &lt;= value// 键的值在数值范围内的约束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SQL样例"><a href="#SQL样例" class="headerlink" title="SQL样例"></a>SQL样例</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">// 建表语句create table Employees (tfn         char(11) PRIMARY KEY check(tfn SIMILAR TO '\d{3}-\d{3}-\d{3}'),givenName   varchar(30) NOT NULL,familyName  varchar(30),hoursPweek  float check(hoursPweek &gt;=0 and hoursPweek &lt;=168));create table Departments (id          char(3) PRIMARY KEY check( id SIMILAR TO '\d{3}'),name        varchar(100) UNIQUE,manager     char(11) UNIQUE references Employees(tfn));create table DeptMissions (department  char(3) REFERENCES Departments(id),keyword     varchar(20) not null);create table WorksFor (employee    char(11) REFERENCES Employees(tfn) not null,department  char(3) REFERENCES Departments(id) not null,percentage  float check(percentage&gt;=0 and percentage&lt;=100));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">// 清空表数据delete from WorksFor;delete from DeptMissions;delete from Departments;delete from Employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">// 删除表定义drop table WorksFor;drop table DeptMissions;drop table Departments;drop table Employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9311 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 实践操作 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础实践记录（1）</title>
      <link href="/2021/03/03/unsw/comp9311/shu-ju-ku-ji-chu-shi-jian-ji-lu-1/"/>
      <url>/2021/03/03/unsw/comp9311/shu-ju-ku-ji-chu-shi-jian-ji-lu-1/</url>
      
        <content type="html"><![CDATA[<h2 id="实践目标"><a href="#实践目标" class="headerlink" title="实践目标"></a>实践目标</h2><ul><li>设置虚拟主机</li><li>在虚拟主机上安装PostgreSQL数据库服务器</li><li>创建、填充和检查一个非常小的数据库</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>学校的CSE服务器名字为<code>grieg</code>，使用它可以创建私有数据库PostgreSQL</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="场景一：建立一个虚拟机"><a href="#场景一：建立一个虚拟机" class="headerlink" title="场景一：建立一个虚拟机"></a>场景一：建立一个虚拟机</h3><h4 id="登录虚拟机"><a href="#登录虚拟机" class="headerlink" title="登录虚拟机"></a>登录虚拟机</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ssh grieg# 使用学校网络登录ssh CSEUsername@grieg.cse.unsw.edu.au# 使用外网登录  CSEUsername为 z学号hostname# 查看主机名称priv srvr# 创建私有目录# 创建完成后，私有目录位置在/srvr/YOU/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="场景二：建立PostgreSQL服务"><a href="#场景二：建立PostgreSQL服务" class="headerlink" title="场景二：建立PostgreSQL服务"></a>场景二：建立PostgreSQL服务</h3><p>运行已编写完成的脚本，安装PostgreSQL服务</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">~cs9311/bin/pginit# 初始化PostgreSQL服务，仅运行一次即可<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行此命令后，将在/srvr/YOU/目录下创建一个名为pgsql的子目录，同时在/srvr/YOU/目录下生成一个名为env的文件。</p><p>pginit脚本已经检查了一些可能的错误，一般情况下能够正确安装服务。如果安装时出现警告提示，忽略即可。但如果有错误ERROR，一定要关注并解决。</p><p>安装完成后，根据脚本提示，运行以下命令，启动或关闭PostgreSQL服务</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">source /srvr/YOU/env# 载入环境变量pgs start# 启动PostSQL服务pgs stop# 停止PostSQL服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>PostgreSQL的日志文件在</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pgsql/pg_xlog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，此目录和pgsql/base目录文件下的内容切勿手动修改，否则可能导致PostgreSQL无法正常运行。</p><p>如果想重新安装PostgreSQL，可使用以下方法</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rm -rf /srvr/*YOU*/pgsql# 删除pgsql目录下的全部内容pginit# 重新安装pgsql服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以后每次进入grieg，都应先载入env环境变量。因此，可以将以下代码粘贴到<code>.bash_profile</code> 或 <code>.bashrc</code> 或 <code>.profile</code> 文件中，使登录系统后，自动载入。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">if [ `hostname` = "grieg" ]then    source /srvr/YOU/envfi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="场景三：使用PostgreSQL服务器"><a href="#场景三：使用PostgreSQL服务器" class="headerlink" title="场景三：使用PostgreSQL服务器"></a>场景三：使用PostgreSQL服务器</h3><p>一般地，每次使用PostgreSQL服务器，应按照以下流程操作：</p><ul><li>登录Grieg</li><li>启动PostgreSQL服务器</li><li>进行工作</li><li>停止PostgreSQL服务器</li><li>退出Grieg</li></ul><p><strong>注意，不要离开之前，使PostgreSQL服务始终运行！</strong></p><p>操作PostgreSQL的命令有：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">source /srvr/YOU/env# 载入环境变量pgs start # 启动pgs服务pgs status# 查看pgs运行状态pgs stop# 关闭pgs服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>进入PostgreSQL的命令为：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">psql MyDatabase# 进入指定数据库中，其中，MyDatabase名字为要进入的数据库名称psql -l# 查看已有数据库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h4><p>输入以下命令，可查看PostsqlSQL当前是否正在运行</p><pre class="line-numbers language-none"><code class="language-none">psql -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入到PostgreSQL中的某个数据库后，命令提示符为</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">dbName=## 管理员命令提示符dbName=&gt;# 其他用户命令提示符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此处为PostgreSQL的<a href="http://www.postgresql.org/docs/">官网使用手册</a></p><p>PostgreSQL的运行日志文件在</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">/srvr/YOU/pgsql/Log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="小练习-1"><a href="#小练习-1" class="headerlink" title="小练习"></a>小练习</h4><p>尝试启动和停止服务器几次，并在服务器运行和不运行时运行psql，然后分别查看屏幕显示的消息，查看内容有和区别。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>典型的操作虚拟主机和PostgreSQL服务器的会话是这样的:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">... on any CSE workstation ...$ ssh grieg... grieg login stuff ...... the following are all on grieg ...$ source /srvr/YOU/env $ pgs start$ psql MyDatabase... use another xterm for editting ...$ pgs stop$ logout... back to your original workstation ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习1：创建一个数据库"><a href="#练习1：创建一个数据库" class="headerlink" title="练习1：创建一个数据库"></a>练习1：创建一个数据库</h3><p>登录服务器并启动PostgreSQL服务后，输入以下命令，创建数据库</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">createdb mydb# 创建指定名称的数据库，mydb为要创建的数据库命令psql mydb# 进入到mydb数据库中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在PostgreSQL控制台，输入以下命令，控制数据库</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mydb=# \d# 查看已有关系（数据库表）mydb=# \q# 退出数据库控制台<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="练习2：填充数据库"><a href="#练习2：填充数据库" class="headerlink" title="练习2：填充数据库"></a>练习2：填充数据库</h3><p>使用现有SQL创建数据库表及数据</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">psql mydb -f ~cs9311/public_html/21T1/lab/01/mydb.sql  # 使用现有SQL文件向数据库导入数据psql mydb -f -q 文件名                                  # 开启静默模式( psql mydb -f ~cs9311/public_html/21T1/lab/01/mydb.sql 2&gt;&amp;1 ) | grep ERROR    # 导入数据时仅显示ERROR信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="练习3：检查数据库"><a href="#练习3：检查数据库" class="headerlink" title="练习3：检查数据库"></a>练习3：检查数据库</h3><p>在SQL标准中，标识符将忽略大小写。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mydb=# \d Staff# 查看指定数据库表定义mydb=# \q# 退出数据库控制台mydb=# select * from Staff;     # 查看指定数据库表中的全部数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="小练习-2"><a href="#小练习-2" class="headerlink" title="小练习"></a>小练习</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from Students where degree=3978;    # 查询degree为3978的全部学生select count(*) from Students where degree=3978;# 查询degree为3978的学生总数select * from Staff where position like '%Professor%';# 查询全部教授数据select course,count(*) from Enrolment group by course;# 查询每种课程的选课人数select c.code, c.title# 查询指定姓名教师的授课名称from   Courses c, Staff swhere  s.name='Andrew Taylor' and c.lecturer=s.userid;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><h4 id="无法重启PostgreSQL服务器"><a href="#无法重启PostgreSQL服务器" class="headerlink" title="无法重启PostgreSQL服务器"></a>无法重启PostgreSQL服务器</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pgs stop# 正常关闭PostgreSQL服务器的命令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解决思路</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tail -2 /srvr/YOU/logfile# 查看日志psql -l# 查看当前服务状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>PostgreSQL运行时生成的PID为位置在<code>/srvr/YOU/pgsql/postmaster.pid</code></p><p>正常关闭时，PostgreSQL将自动删除此文件。若上次PostgreSQL未正常关闭，需要手动删除此文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rm /srvr/YOU/pgsql/postmaster.pid# 手动删除pid文件rm /srvr/YOU/pgsql/.s*# 删除socket文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9311 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 实践操作 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pygame游戏开发查询手册</title>
      <link href="/2021/03/02/ji-zhu-xue-xi/python/pygame-you-xi-kai-fa-cha-xun-shou-ce/"/>
      <url>/2021/03/02/ji-zhu-xue-xi/python/pygame-you-xi-kai-fa-cha-xun-shou-ce/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考教程：<a href="https://eyehere.net/2011/python-pygame-novice-professional-index/">https://eyehere.net/2011/python-pygame-novice-professional-index/</a></p></blockquote><h2 id="pygame模块"><a href="#pygame模块" class="headerlink" title="pygame模块"></a>pygame模块</h2><p><strong>pygame模块一览表</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">模块名</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">pygame.cdrom</td><td style="text-align:left">访问光驱</td></tr><tr><td style="text-align:left">pygame.cursors</td><td style="text-align:left">加载光标</td></tr><tr><td style="text-align:left">pygame.display</td><td style="text-align:left">访问显示设备</td></tr><tr><td style="text-align:left">pygame.draw</td><td style="text-align:left">绘制形状、线和点</td></tr><tr><td style="text-align:left">pygame.event</td><td style="text-align:left">管理事件</td></tr><tr><td style="text-align:left">pygame.font</td><td style="text-align:left">使用字体</td></tr><tr><td style="text-align:left">pygame.image</td><td style="text-align:left">加载和存储图片</td></tr><tr><td style="text-align:left">pygame.joystick</td><td style="text-align:left">使用游戏手柄或者 类似的东西</td></tr><tr><td style="text-align:left">pygame.key</td><td style="text-align:left">读取键盘按键</td></tr><tr><td style="text-align:left">pygame.mixer</td><td style="text-align:left">声音</td></tr><tr><td style="text-align:left">pygame.mouse</td><td style="text-align:left">鼠标</td></tr><tr><td style="text-align:left">pygame.movie</td><td style="text-align:left">播放视频</td></tr><tr><td style="text-align:left">pygame.music</td><td style="text-align:left">播放音频</td></tr><tr><td style="text-align:left">pygame.overlay</td><td style="text-align:left">访问高级视频叠加</td></tr><tr><td style="text-align:left">pygame</td><td style="text-align:left">就是我们在学的这个东西了……</td></tr><tr><td style="text-align:left">pygame.rect</td><td style="text-align:left">管理矩形区域</td></tr><tr><td style="text-align:left">pygame.sndarray</td><td style="text-align:left">操作声音数据</td></tr><tr><td style="text-align:left">pygame.sprite</td><td style="text-align:left">操作移动图像</td></tr><tr><td style="text-align:left">pygame.surface</td><td style="text-align:left">管理图像和屏幕</td></tr><tr><td style="text-align:left">pygame.surfarray</td><td style="text-align:left">管理点阵图像数据</td></tr><tr><td style="text-align:left">pygame.time</td><td style="text-align:left">管理时间和帧信息</td></tr><tr><td style="text-align:left">pygame.transform</td><td style="text-align:left">缩放和移动图像</td></tr></tbody></table></div><p>注：有些模块在一些平台上可能不存在</p><h2 id="pygame模块及函数"><a href="#pygame模块及函数" class="headerlink" title="pygame模块及函数"></a>pygame模块及函数</h2><h3 id="根模块相关"><a href="#根模块相关" class="headerlink" title="根模块相关"></a>根模块相关</h3><h4 id="init"><a href="#init" class="headerlink" title="init()"></a>init()</h4><p>初始化pygame</p><p>pygame.init()</p><h4 id="Surface"><a href="#Surface" class="headerlink" title="Surface()"></a>Surface()</h4><p>设置或获取pygame的surface</p><p>all_colors = pygame.Surface((4096,4096), depth=24)</p><p>bland_surface = pygame.Surface((256, 256))</p><p>bland_alpha_surface = pygame.Surface((256, 256), flags=SRCALPHA, depth=32)</p><h3 id="display模块"><a href="#display模块" class="headerlink" title="display模块"></a>display模块</h3><h4 id="blit"><a href="#blit" class="headerlink" title="blit()"></a>blit()</h4><p>在屏幕上绘制图像</p><p>screen = pygame.display.set_mode((640, 480), 0, 32)</p><p>screen.blit(background, (0,0))</p><p>screen.blit(ogre, (300, 200), (100 * frame_no, 0, 100, 100))</p><h4 id="flip"><a href="#flip" class="headerlink" title="flip()"></a>flip()</h4><p>交替显示画面</p><p>pygame.display.flip()</p><h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h4><p>为Surface填充颜色</p><p>screen = pygame.display.set_mode((640, 480), 0, 32)</p><p>screen.fill((255, 255, 255))</p><h4 id="get-at"><a href="#get-at" class="headerlink" title="get_at()"></a>get_at()</h4><p>获取Surface指定位置颜色</p><p>screen.set_at(rand_pos)</p><p>注：全屏/硬件模式下，该方法调用速度很慢！</p><h4 id="get-clip"><a href="#get-clip" class="headerlink" title="get_clip()"></a>get_clip()</h4><p>获取剪裁区域</p><p>screen.get_clip()</p><h4 id="list-modes"><a href="#list-modes" class="headerlink" title="list_modes()"></a>list_modes()</h4><p>显示当前主机支持的显示模式</p><p>pygame.display.list_modes()</p><h4 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h4><p>锁住Surface</p><p>screen.lock()</p><h4 id="set-at"><a href="#set-at" class="headerlink" title="set_at()"></a>set_at()</h4><p>设置Surface指定位置颜色</p><p>screen.set_at(rand_pos, rand_col)</p><h4 id="set-caption"><a href="#set-caption" class="headerlink" title="set_caption()"></a>set_caption()</h4><p>设置标题</p><p>pygame.display.set_caption(“Pygame”)</p><h4 id="set-clip"><a href="#set-clip" class="headerlink" title="set_clip"></a>set_clip</h4><p>设置剪裁区域</p><p>screen.set_clip(0, 400, 200, 600)</p><h4 id="set-mode"><a href="#set-mode" class="headerlink" title="set_mode()"></a>set_mode()</h4><p>pygame.display.set_mode((640, 480), 0, 32)</p><p>screen = pygame.display.set_mode((640, 480), FULLSCREEN, 32)</p><p>set_mode可选模式</p><div class="table-container"><table><thead><tr><th style="text-align:left">标志位</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">FULLSCREEN</td><td style="text-align:left">创建一个全屏窗口</td></tr><tr><td style="text-align:left">DOUBLEBUF</td><td style="text-align:left">创建一个“双缓冲”窗口，建议在HWSURFACE或者OPENGL时使用</td></tr><tr><td style="text-align:left">HWSURFACE</td><td style="text-align:left">创建一个硬件加速的窗口，必须和FULLSCREEN同时使用</td></tr><tr><td style="text-align:left">OPENGL</td><td style="text-align:left">创建一个OPENGL渲染的窗口</td></tr><tr><td style="text-align:left">RESIZABLE</td><td style="text-align:left">创建一个可以改变大小的窗口</td></tr><tr><td style="text-align:left">NOFRAME</td><td style="text-align:left">创建一个没有边框的窗口</td></tr></tbody></table></div><h4 id="subsurface"><a href="#subsurface" class="headerlink" title="subsurface()"></a>subsurface()</h4><p>设置子Surface</p><p>my_font_image = Pygame.load(“font.png”)<br>letters = []<br>letters[“a”] = my_font_image.subsurface((0,0), (80,80))<br>letters[“b”] = my_font_image.subsurface((80,0), (80,80))</p><h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h4><p>解锁Surface</p><p>screen.unlock()</p><h4 id="update"><a href="#update" class="headerlink" title="update()"></a>update()</h4><p>更新画面</p><p>pygame.display.update()</p><h3 id="draw模块"><a href="#draw模块" class="headerlink" title="draw模块"></a>draw模块</h3><h4 id="aaline"><a href="#aaline" class="headerlink" title="aaline()"></a>aaline()</h4><p>绘制平滑直线</p><h4 id="aalines"><a href="#aalines" class="headerlink" title="aalines()"></a>aalines()</h4><p>绘制多条平滑直线</p><h4 id="arc"><a href="#arc" class="headerlink" title="arc()"></a>arc()</h4><p>绘制弧</p><p>pygame.draw.arc(Surface, color, Rect, start_angle, stop_angle, width=1)</p><h4 id="circle"><a href="#circle" class="headerlink" title="circle()"></a>circle()</h4><p>绘制圆形</p><p>pygame.draw.circle(Surface, color, pos, radius, width=0)</p><p>pygame.draw.circle(screen, (0, 0, 0), (int(factor * 639.0), 120), 10)</p><h4 id="ellipse"><a href="#ellipse" class="headerlink" title="ellipse()"></a>ellipse()</h4><p>绘制椭圆</p><p>pygame.draw.ellipse(Surface, color, Rect, width=0)</p><h4 id="line"><a href="#line" class="headerlink" title="line()"></a>line()</h4><p>绘制直线</p><p>pygame.draw.line(Surface, color, start_pos, end_pos, width=1)</p><h4 id="lines"><a href="#lines" class="headerlink" title="lines()"></a>lines()</h4><p>绘制多条直线</p><p>pygame.draw.lines(Surface, color, closed, pointlist, width=1)</p><h4 id="rect"><a href="#rect" class="headerlink" title="rect()"></a>rect()</h4><p>绘制矩形</p><p>pygame.draw.rect(Surface, color, Rect, width=0)</p><h4 id="polygon"><a href="#polygon" class="headerlink" title="polygon()"></a>polygon()</h4><p>绘制多边形</p><p>tri = [ (0, 120), (639, 100), (639, 140) ]</p><p>pygame.draw.polygon(Surface, color, pointlist, width=0)</p><p>pygame.draw.polygon(screen, (0, 255, 0), tri)</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">rect</td><td style="text-align:left">绘制矩形</td></tr><tr><td style="text-align:left">polygon</td><td style="text-align:left">绘制多边形（三个及三个以上的边）</td></tr><tr><td style="text-align:left">circle</td><td style="text-align:left">绘制圆</td></tr><tr><td style="text-align:left">ellipse</td><td style="text-align:left">绘制椭圆</td></tr><tr><td style="text-align:left">arc</td><td style="text-align:left">绘制圆弧</td></tr><tr><td style="text-align:left">line</td><td style="text-align:left">绘制线</td></tr><tr><td style="text-align:left">lines</td><td style="text-align:left">绘制一系列的线</td></tr><tr><td style="text-align:left">aaline</td><td style="text-align:left">绘制一根平滑的线</td></tr><tr><td style="text-align:left">aalines</td><td style="text-align:left">绘制一系列平滑的线</td></tr></tbody></table></div><h3 id="event-模块"><a href="#event-模块" class="headerlink" title="event 模块"></a>event 模块</h3><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><p>获取全部事件</p><p>pygame.event.get()</p><h4 id="set-allowed"><a href="#set-allowed" class="headerlink" title="set_allowed()"></a>set_allowed()</h4><p>设置允许事件</p><p>pygame.event.set_allowed()</p><h4 id="set-blocked"><a href="#set-blocked" class="headerlink" title="set_blocked()"></a>set_blocked()</h4><p>设置阻止事件</p><p>pygame.event.set_blocked(事件名)</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h4><p>返回真实事件</p><p>pygame.event.poll()</p><div class="table-container"><table><thead><tr><th style="text-align:left">事件</th><th style="text-align:left">产生途径</th><th style="text-align:left">参数</th></tr></thead><tbody><tr><td style="text-align:left">QUIT</td><td style="text-align:left">用户按下关闭按钮</td><td style="text-align:left">none</td></tr><tr><td style="text-align:left">ATIVEEVENT</td><td style="text-align:left">Pygame被激活或者隐藏</td><td style="text-align:left">gain, state</td></tr><tr><td style="text-align:left">KEYDOWN</td><td style="text-align:left">键盘被按下</td><td style="text-align:left">unicode, key, mod</td></tr><tr><td style="text-align:left">KEYUP</td><td style="text-align:left">键盘被放开</td><td style="text-align:left">key, mod</td></tr><tr><td style="text-align:left">MOUSEMOTION</td><td style="text-align:left">鼠标移动</td><td style="text-align:left">pos, rel, buttons</td></tr><tr><td style="text-align:left">MOUSEBUTTONDOWN</td><td style="text-align:left">鼠标按下</td><td style="text-align:left">pos, button</td></tr><tr><td style="text-align:left">MOUSEBUTTONUP</td><td style="text-align:left">鼠标放开</td><td style="text-align:left">pos, button</td></tr><tr><td style="text-align:left">JOYAXISMOTION</td><td style="text-align:left">游戏手柄(Joystick or pad)移动</td><td style="text-align:left">joy, axis, value</td></tr><tr><td style="text-align:left">JOYBALLMOTION</td><td style="text-align:left">游戏球(Joy ball)?移动</td><td style="text-align:left">joy, axis, value</td></tr><tr><td style="text-align:left">JOYHATMOTION</td><td style="text-align:left">游戏手柄(Joystick)?移动</td><td style="text-align:left">joy, axis, value</td></tr><tr><td style="text-align:left">JOYBUTTONDOWN</td><td style="text-align:left">游戏手柄按下</td><td style="text-align:left">joy, button</td></tr><tr><td style="text-align:left">JOYBUTTONUP</td><td style="text-align:left">游戏手柄放开</td><td style="text-align:left">joy, button</td></tr><tr><td style="text-align:left">VIDEORESIZE</td><td style="text-align:left">Pygame窗口缩放</td><td style="text-align:left">size, w, h</td></tr><tr><td style="text-align:left">VIDEOEXPOSE</td><td style="text-align:left">Pygame窗口部分公开(expose)?</td><td style="text-align:left">none</td></tr><tr><td style="text-align:left">USEREVENT</td><td style="text-align:left">触发了一个用户事件</td><td style="text-align:left">code</td></tr></tbody></table></div><p>鼠标及键盘事件：<strong>MOUSEMOTION、MOUSEBUTTONDOWN、MOUSEBUTTONUP、KEYDOWN、KEYUP</strong></p><p>键盘值：<strong>K_xxx，如K_A、K_SPACE、K_RETURN</strong></p><p>控制按键：<strong>KMOD_CTRL、KMOD_SHIFT、KMOD_ALT</strong></p><h4 id="post"><a href="#post" class="headerlink" title="post()"></a>post()</h4><p>发送事件给pygame</p><p>my_event = pygame.event.Event(KEYDOWN, key=K_SPACE, mod=0, unicode=u’ ‘)</p><p>my_event = pygame.event.Event(KEYDOWN, {“key”:K_SPACE, “mod”:0, “unicode”:u’ ‘})</p><p>CATONKEYBOARD = USEREVENT+1</p><p>my_event = pygame.event.Event(CATONKEYBOARD, message=”Bad cat!”)</p><p>pgame.event.post(my_event)</p><h4 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h4><p>等待事件</p><p>pygame.event.wait()</p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h3 id="font模块"><a href="#font模块" class="headerlink" title="font模块"></a>font模块</h3><h4 id="Font"><a href="#Font" class="headerlink" title="Font()"></a>Font()</h4><p>使用自定义字体</p><p>my_font = pygame.font.Font(“my_font.ttf”, 16)</p><h4 id="get-fonts"><a href="#get-fonts" class="headerlink" title="get_fonts()"></a>get_fonts()</h4><p>获取系统现有字体</p><p>pygame.font.get_fonts()</p><h4 id="get-linesize"><a href="#get-linesize" class="headerlink" title="get_linesize()"></a>get_linesize()</h4><p>获取字体高度</p><p>font = pygame.font.SysFont(“arial”, 16);</p><p>font_height = font.get_linesize()</p><h4 id="SysFont"><a href="#SysFont" class="headerlink" title="SysFont()"></a>SysFont()</h4><p>设置字体</p><p>font = pygame.font.SysFont(“arial”, 16);</p><h3 id="image模块"><a href="#image模块" class="headerlink" title="image模块"></a>image模块</h3><h4 id="convert-convert-alpha"><a href="#convert-convert-alpha" class="headerlink" title="convert()/convert_alpha()"></a>convert()/convert_alpha()</h4><p>将图像数据都转化为Surface对象</p><p>background = pygame.image.load(background_image_filename).convert()</p><h4 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h4><p>显示文字</p><p>font.render(text, True, (0, 0, 0)), (0, y)</p><p>text_surface = my_font.render(“Pygame!”, True, (0,0,0), (255, 255, 255))</p><h4 id="save"><a href="#save" class="headerlink" title="save()"></a>save()</h4><p>保存图片</p><p>pygame.image.save(name_surface, “name.png”)</p><h3 id="mouse模块"><a href="#mouse模块" class="headerlink" title="mouse模块"></a>mouse模块</h3><h4 id="get-pos"><a href="#get-pos" class="headerlink" title="get_pos()"></a>get_pos()</h4><p>获取鼠标位置</p><p>pygame.mouse.get_pos()</p><h3 id="Locals模块"><a href="#Locals模块" class="headerlink" title="Locals模块"></a>Locals模块</h3><h4 id="Rect"><a href="#Rect" class="headerlink" title="Rect()"></a>Rect()</h4><p>定义矩形</p><p>rect1 = Rect(100, 100, 200, 150)</p><p>rect2 = Rect((100, 100), (200, 150))</p><h2 id="pygame基础使用规则"><a href="#pygame基础使用规则" class="headerlink" title="pygame基础使用规则"></a>pygame基础使用规则</h2><h3 id="关于初始化"><a href="#关于初始化" class="headerlink" title="关于初始化"></a>关于初始化</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pygame# 引入pygame模块pygame.init()# 初始化pygamepygame.quit()# 退出pygame<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))# 创建游戏窗口pygame.display.update()# 更新窗口显示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="关于时钟与刷新帧率"><a href="#关于时钟与刷新帧率" class="headerlink" title="关于时钟与刷新帧率"></a>关于时钟与刷新帧率</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">clock = pygame.time.Clock()# 获取pygame时钟clock.tick(60)# 数字为刷新帧率<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="关于绘制图像"><a href="#关于绘制图像" class="headerlink" title="关于绘制图像"></a>关于绘制图像</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">bg = pygame.image.load("background.png")# 加载背景图像screen.blit(bg, (0, 0))# 绘制图像到窗口rect = pygame.Rect(200, 800, 140, 178)  # 定义元素矩形，参数依次为X，Y，width，height<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="关于事件"><a href="#关于事件" class="headerlink" title="关于事件"></a>关于事件</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">pygame.event.get()# 获取pygame的全部事件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="pygame定义的事件常量"><a href="#pygame定义的事件常量" class="headerlink" title="pygame定义的事件常量"></a>pygame定义的事件常量</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">pygame.QUIT# 退出事件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="精灵和精灵组"><a href="#精灵和精灵组" class="headerlink" title="精灵和精灵组"></a>精灵和精灵组</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">pygame.sprite.Sprite# 精灵类pygame.sprite.Group# 精灵组类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="继承精灵类"><a href="#继承精灵类" class="headerlink" title="继承精灵类"></a>继承精灵类</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pygameclass MySprite(pygame.sprite.Sprite):    """自定义游戏精灵"""    def __init__(self, image_name, speed=1):        super().__init__()        self.image = pygame.image.load(image_name)        self.rect = self.image.get_rect()        self.speed = speed# speed为自定义的精灵属性    def update(self):        self.rect.y += self.speed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用精灵类和精灵组"><a href="#使用精灵类和精灵组" class="headerlink" title="使用精灵类和精灵组"></a>使用精灵类和精灵组</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sprites.my_sprites import *# 引用自定义精灵组类my_sprite = PlaneSprite("sprite.png")# 实例化精灵sprite_group = pygame.sprite.Group(my_sprite)# 实例化精灵组enemy_group.update()# 调用精灵组中的精灵的全部update方法enemy_group.draw(screen)# 绘制精灵组到屏幕<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="游戏循环"><a href="#游戏循环" class="headerlink" title="游戏循环"></a>游戏循环</h2><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph TDH[游戏初始化]H --&gt; I[设置游戏窗口]I --&gt; J[创建游戏时钟]J --&gt; K[创建精灵/精灵组]F[游戏循环]F --&gt; A[设置刷新帧率]A --&gt; B[事件监听]B --&gt; C[碰撞检测]C --&gt;  D[更新/绘制精灵组]D --&gt; E[更新屏幕显示]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手册 </tag>
            
            <tag> 编辑中 </tag>
            
            <tag> Python </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机技术英语生词本</title>
      <link href="/2021/03/01/ji-zhu-xue-xi/ji-suan-ji-ji-zhu-ying-yu-sheng-ci-ben/"/>
      <url>/2021/03/01/ji-zhu-xue-xi/ji-suan-ji-ji-zhu-ying-yu-sheng-ci-ben/</url>
      
        <content type="html"><![CDATA[<h2 id="2021-03-01"><a href="#2021-03-01" class="headerlink" title="2021-03-01"></a>2021-03-01</h2><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p><strong><em>anomaly</em></strong> n. 异常；不规则；反常事物</p><p><strong><em>update anomalies</em></strong> 更新异常</p><p><strong><em>insertion anomalies</em></strong> 插入异常</p><p><strong><em>deletion anomalies</em></strong> 删除异常</p><p><strong><em>semantic</em></strong> adj. 语义的；语义学的</p><p><strong><em>modification</em></strong>  n. 修改，修正；改变</p><p><strong><em>inconsistent</em></strong> adj. 不一致的；前后矛盾的</p><p><strong><em>insertion</em></strong> n. 插入；嵌入；插入物</p><p><strong><em>deletion</em></strong> n. 删除</p><p><strong><em>generalization</em></strong> n. 概括；普遍化；一般化</p><p><strong><em>FD</em></strong> (Functional Dependency) 函数依赖</p><p><strong><em>derivation</em></strong> n. 概括；普遍化；一般化</p><p><strong><em>augmentation</em></strong> n. 增加，增大；增加物</p><p><strong><em>transitivity</em></strong> n. 传递性；动词的及物性；转移性</p><p><strong><em>additivity</em></strong> n. 添加；相加性</p><p><strong><em>projectivity</em></strong> n. 投射心理；射影对应性；投射倾向</p><p><strong><em>pseudotransitivity</em></strong> 伪递移法则</p><p><strong><em>denote</em></strong> vt. 表示，指示</p><p><strong><em>closure</em></strong> n. 关闭；终止，结束</p><p><strong><em>relational schema</em></strong> 关系模式</p><h2 id="2021-03-04"><a href="#2021-03-04" class="headerlink" title="2021-03-04"></a>2021-03-04</h2><h4 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h4><p><strong><em>argument</em></strong> n.论点  </p><p><strong><em>declarative sentences</em></strong> 陈述句</p><p><strong><em>permises</em></strong> n.前提：包含一些论点的陈述句</p><p><strong><em>conclusion</em></strong> n. 结论 </p><p><strong><em>entail</em></strong>  vt. 使需要，必需；承担；遗传给；蕴含 n. 引起；需要；继承</p><p><strong><em>propositional logic</em></strong> 命题逻辑 </p><p><strong><em>formulae</em></strong> n.公式</p><p><strong><em>formalised</em></strong> vi. 使形式化，使正式</p><p><strong><em>implementation</em></strong> n. 实施，履行</p><p><strong><em>valid</em></strong> a. 有效的，合理的</p><p><strong><em>tautology</em></strong> n.同意反复</p><p><strong><em>detote</em></strong> vt. 表示</p><p><strong><em>evaluate</em></strong>  vt. 评价；估价</p><p><strong><em>tautology</em></strong> n. 同义反复；无谓的重复</p><p><strong><em>irrational</em></strong> adj. 不合理的；无理性的；荒谬的 n. [数] 无理数</p><p><strong><em>Contradiction</em></strong> n. 矛盾；否认；反驳</p><p><strong><em>substitution</em></strong> n. 代替；[数] 置换；代替物</p><p><strong><em>valuation</em></strong> n. 评价，估价；计算</p><p><strong><em>parenthese</em></strong> n. 括号；圆括号</p><p><strong><em>complementation</em></strong> n. 互补；互补作用</p><p><strong><em>isomorphic</em></strong> adj. [物] 同构的；同形的</p><p><strong><em>cartesian</em></strong>  adj. 笛卡尔的；笛卡尔哲学的</p><p><strong><em>auxiliary</em></strong> adj. 辅助的；副的；附加的；（发动机、设备等）备用的</p><p><strong><em>composition</em></strong> n. 作文，作曲，作品；[材] 构成；合成物；成分</p><p><strong><em>associative</em></strong> adj. 联想的；联合的；组合的</p><p><strong><em>identity</em></strong> n. 身份；同一性，一致；特性；恒等式</p><p><strong><em>partial function</em></strong> 偏函数</p><p><strong><em>least fixpoint</em></strong> 最小定点</p><p><strong><em>surjective</em></strong> adj. 满射的</p><p><strong><em>injective</em></strong> adj. [数] 内射的；[数] 单射的</p><p><strong><em>equivalent</em></strong> adj. （在价值、数量等方面）相等的；等价的；等效的；等量的；同意义的</p><p><strong><em>invertible</em></strong>  adj. 可逆的；倒转的</p><p><strong><em>substituting</em></strong> n. 取代；[数] 代入</p><p><strong><em>optimisation</em></strong> 最优化</p><p><strong><em>transpose</em></strong> vt. 调换；移项；颠倒顺序</p><p><strong><em>symmetric</em></strong> adj. 对称的；匀称的</p><p><strong><em>scalar product</em></strong>  标量乘积</p><p><strong><em>n-dimensional vectors</em></strong> n维向量</p><p><strong><em>nonemptiness</em></strong> 非空性</p><p><strong><em>ubiquitous</em></strong> adj. 普遍存在的；无所不在的</p><p><strong><em>trivial</em></strong> adj. 不重要的，琐碎的；琐细的</p><p><strong><em>diagonal</em></strong> adj. 斜的；对角线的；斜纹的</p><p><strong><em>reflexive</em></strong> adj. （词或词形）反身的；反射性的，本能反应的；</p><p><strong><em>antireflective</em></strong> adj. 增透的；减反射的；[物] 抗反射的</p><p><strong><em>symmetric</em></strong> adj. 对称的；匀称的</p><p><strong><em>antisymmetric</em></strong> adj. 反对称的</p><p><strong><em>transitive</em></strong> adj. 及物的；过渡的；可迁的 n. 传递；及物动词</p><p><strong><em>equivalence</em></strong> n. 等价；相等；等值</p><h2 id="2021-03-07-2021-03-09"><a href="#2021-03-07-2021-03-09" class="headerlink" title="2021-03-07~2021-03-09"></a>2021-03-07~2021-03-09</h2><h4 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h4><p><strong><em>axioms</em></strong>  n. [数] 公理；公设；原理</p><p><strong><em>generalization</em></strong> n. 概括；普遍化；一般化</p><p><strong><em>derivation</em></strong> n. 起源；推导；词源，派生词；导数</p><p><strong><em>derived</em></strong> adj. 导出的；衍生的，派生的 v. 从……衍生出，源于；</p><p><strong><em>model</em></strong> n. 模型；典型；模范；模特儿；样式 vt. 建模</p><p><strong><em>singleton</em></strong> n. 单独的人（或物体）；单生子女，单生幼畜；单身的人；</p><p><strong><em>deletion</em></strong> n. 删除；[遗] 缺失；删除部分</p><p><strong><em>modifications</em></strong> n. 修改；修饰；变型；</p><h2 id="2021-03-12"><a href="#2021-03-12" class="headerlink" title="2021-03-12"></a>2021-03-12</h2><p><strong><em>divisibility</em></strong>  n. 可分性；[数] 可除性</p><p><strong><em>equivalence</em></strong> n. 等价；相等；等值</p><p><strong><em>partition</em></strong> vt. [数] 分割；分隔；区分</p><p><strong><em>lexicographic</em></strong> adj. 词典编辑的；字典式的</p><p><strong><em>congruent</em></strong> adj. 适合的，一致的；全等的；和谐的</p><p><strong><em>isomorphic</em></strong> adj. [物] 同构的；同形的</p><p><strong><em>vertex</em></strong> n. 顶点；[昆] 头顶；[天] 天顶</p><p><strong><em>lemma</em></strong> n. 引理；辅助定理；论点；膜</p><p><strong><em>conversely</em></strong> adv. 相反地</p><p><strong><em>illuminating</em></strong> adj. 照亮的，照明的；启蒙的，有启发性的</p><p><strong><em>corollary</em></strong> n. 推论；必然的结果</p><p><strong><em>pointwise</em></strong> adj. [数] 逐点的</p><p><strong><em>factorization</em></strong> n. [数] 因子分解；[数] 因式分解</p><p><strong><em>isomorphic</em></strong> adj. [物] 同构的；同形的</p><p><strong><em>subassembly</em></strong> n. 组件，部件</p><p><strong><em>affiliation</em></strong> n. 友好关系；加入；联盟；从属关系</p><p><strong><em>depict</em></strong> vt. 描述；描画</p><p><strong><em>vertex</em></strong> n. 顶点</p><p><strong><em>isomorphism</em></strong> n. 类质同像；同构</p><p><strong><em>nonisomorphic</em></strong> adj. [数] 单一同态的；[生物] 单型的</p><p><strong><em>automorphism</em></strong>  n. [数] 自同构；自守</p><p><strong><em>bipartite</em></strong> adj. 双边的；由两部分构成的；一式两份的；双方的</p><p><strong><em>chromatic</em></strong> adj. 彩色的；色品的；易染色的</p><p><strong><em>clique</em></strong> n. 派系；阀；私党；小圈子</p><p><strong><em>inequalities</em></strong>  n. [数] 不等式；不均等，不平衡；</p><p><strong><em>partitioned</em></strong> adj. 分割的；分区的；分段的</p><p><strong><em>planarity</em></strong> n. [数] 平面性；平面化</p><p><strong><em>deficienc</em></strong>y n. 缺陷，缺点；缺乏；不足的数额</p><p><strong><em>encompass</em></strong> vt. 包含；包围，环绕；完成</p><h2 id="2021-03-28"><a href="#2021-03-28" class="headerlink" title="2021-03-28"></a>2021-03-28</h2><p><strong><em>hierarchy</em></strong> n. 层级；等级制度</p><p><strong><em>decrement</em></strong> n. 渐减；减缩；衰减率</p><p><strong><em>fragmented</em></strong> adj. 片断的；成碎片的</p><p><strong><em>Induction</em></strong>  n.归纳法</p><p><strong><em>orthogonal</em></strong> adj. [数] 正交的</p>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持续更新 </tag>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础SQL</title>
      <link href="/2021/03/01/unsw/comp9311/shu-ju-ku-ji-chu-sql/"/>
      <url>/2021/03/01/unsw/comp9311/shu-ju-ku-ji-chu-sql/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL（Structured-Query-Language）"><a href="#SQL（Structured-Query-Language）" class="headerlink" title="SQL（Structured Query Language）"></a>SQL（Structured Query Language）</h2><p>SQL即结构化查询语言，是关系数据库的标准语言</p><h4 id="SQL-的动词"><a href="#SQL-的动词" class="headerlink" title="SQL 的动词"></a>SQL 的动词</h4><div class="table-container"><table><thead><tr><th>SQL功能</th><th>动词</th></tr></thead><tbody><tr><td>数据查询</td><td>Select</td></tr><tr><td>数据定义</td><td>Create,Drop,Alter</td></tr><tr><td>数据操纵</td><td>Insert, Update, Delete</td></tr><tr><td>数据控制</td><td>Grant, Revoke</td></tr></tbody></table></div><h4 id="SQL-的数据定义语句"><a href="#SQL-的数据定义语句" class="headerlink" title="SQL 的数据定义语句"></a>SQL 的数据定义语句</h4><div class="table-container"><table><thead><tr><th>操作对象</th><th>创建</th><th>删除</th><th>修改</th></tr></thead><tbody><tr><td>模式</td><td>Create Schema</td><td>Drop Schema</td><td></td></tr><tr><td>表</td><td>Create Table</td><td>Drop Table</td><td>Alter Table</td></tr><tr><td>视图</td><td>Create View</td><td>Drop View</td><td></td></tr><tr><td>索引</td><td>Create Index</td><td>Drop Index</td><td>Alter Index</td></tr></tbody></table></div><h3 id="定义模式"><a href="#定义模式" class="headerlink" title="定义模式"></a>定义模式</h3><p><strong>CREATE SCHEMA</strong> [&lt;模式名&gt;] <strong>AUTHORIZATION</strong> &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</p><p>CREATE SCHEMA “S-T” AUTHORIZATION WANG;</p><p>其中，模式名可隐藏，默认为&lt;用户名&gt;</p><h2 id="本案例使用的数据"><a href="#本案例使用的数据" class="headerlink" title="本案例使用的数据"></a>本案例使用的数据</h2><p>本教程使用如下数据库表：</p><p>Beers( <em><u>name</u></em>, manf ), Bars( <em><u>name</u></em>, addr, license )<br>Drinkers( <em><u>name</u></em>, addr, phone ), Likes( <em><u>drinker, beer</u></em> )<br>Sells( <u>bar, beer</u>, price ), Frequents( <u><em>drinker, bar</em></u> )</p><p>其中，斜体加下划线内容为主键</p><p>Bars：</p><div class="table-container"><table><thead><tr><th>Name</th><th>Addr</th><th>License</th></tr></thead><tbody><tr><td>Australia Hotel</td><td>The Rocks</td><td>123456</td></tr><tr><td>Coogee Bay Hotel</td><td>Coogee</td><td>966500</td></tr><tr><td>Lord Nelson</td><td>The Rocks</td><td>123888</td></tr><tr><td>Marble Bar</td><td>Sydney</td><td>122123</td></tr><tr><td>Regent Hotel</td><td>Kingsford</td><td>987654</td></tr><tr><td>Royal Hotel</td><td>Randwick</td><td>938500</td></tr></tbody></table></div><p>Drinkers：</p><div class="table-container"><table><thead><tr><th>Name</th><th>Addr</th><th>Phone</th></tr></thead><tbody><tr><td>Adam</td><td>Randwick</td><td>9385-4444</td></tr><tr><td>Gernot</td><td>Newtown</td><td>9415-3378</td></tr><tr><td>John</td><td>Clovelly</td><td>9665-1234</td></tr><tr><td>Justin</td><td>Mosman</td><td>9845-4321</td></tr></tbody></table></div><p>Beers：</p><div class="table-container"><table><thead><tr><th>Name</th><th>Manf</th></tr></thead><tbody><tr><td>80/-</td><td>Caledonian</td></tr><tr><td>Bigfoot Barley Wine</td><td>Sierra Nevada</td></tr><tr><td>Burragorang Bock</td><td>George IV Inn</td></tr><tr><td>Crown Lager</td><td>Carlton</td></tr><tr><td>Fosters Lager</td><td>Carlton</td></tr><tr><td>Invalid Stout</td><td>Carlton</td></tr><tr><td>Melbourne Bitter</td><td>Carlton</td></tr><tr><td>New</td><td>Toohey’s</td></tr><tr><td>Old</td><td>Toohey’s</td></tr><tr><td>Old Admiral</td><td>Lord Nelson</td></tr><tr><td>Pale Ale</td><td>Sierra Nevada</td></tr><tr><td>Premium Lager</td><td>Cascade</td></tr><tr><td>Red</td><td>Toohey’s</td></tr><tr><td>Sheaf Stout</td><td>Toohey’s</td></tr><tr><td>Sparkling Ale</td><td>Cooper’s</td></tr><tr><td>Stout</td><td>Cooper’s</td></tr><tr><td>Three Sheets</td><td>Lord Nelson</td></tr><tr><td>Victoria Bitter</td><td>Carlton</td></tr></tbody></table></div><p>Frequents：</p><div class="table-container"><table><thead><tr><th>Drinker</th><th>Bar</th></tr></thead><tbody><tr><td>Adam</td><td>Coogee Bay Hotel</td></tr><tr><td>Gernot</td><td>Lord Nelson</td></tr><tr><td>John</td><td>Coogee Bay Hotel</td></tr><tr><td>John</td><td>Lord Nelson</td></tr><tr><td>John</td><td>Australia Hotel</td></tr><tr><td>Justin</td><td>Regent Hotel</td></tr><tr><td>Justin</td><td>Marble Bar</td></tr></tbody></table></div><p>Likes:</p><div class="table-container"><table><thead><tr><th>Drinker</th><th>Beer</th></tr></thead><tbody><tr><td>Adam</td><td>Crown Lager</td></tr><tr><td>Adam</td><td>Fosters Lager</td></tr><tr><td>Adam</td><td>New</td></tr><tr><td>Gernot</td><td>Premium Lager</td></tr><tr><td>Gernot</td><td>Sparkling Ale</td></tr><tr><td>John</td><td>80/-</td></tr><tr><td>John</td><td>Bigfoot Barley Wine</td></tr><tr><td>John</td><td>Pale Ale</td></tr><tr><td>John</td><td>Three Sheets</td></tr><tr><td>Justin</td><td>Sparkling Ale</td></tr><tr><td>Justin</td><td>Victoria Bitter</td></tr></tbody></table></div><p>Sells:</p><div class="table-container"><table><thead><tr><th>Bar</th><th>Beer</th><th>Price</th></tr></thead><tbody><tr><td>Australia Hotel</td><td>Burragorang Bock</td><td>3.5</td></tr><tr><td>Coogee Bay Hotel</td><td>New</td><td>2.25</td></tr><tr><td>Coogee Bay Hotel</td><td>Old</td><td>2.5</td></tr><tr><td>Coogee Bay Hotel</td><td>Sparkling Ale</td><td>2.8</td></tr><tr><td>Coogee Bay Hotel</td><td>Victoria Bitter</td><td>2.3</td></tr><tr><td>Lord Nelson</td><td>Three Sheets</td><td>3.75</td></tr><tr><td>Lord Nelson</td><td>Old Admiral</td><td>3.75</td></tr><tr><td>Marble Bar</td><td>New</td><td>2.8</td></tr><tr><td>Marble Bar</td><td>Old</td><td>2.8</td></tr><tr><td>Marble Bar</td><td>Victoria Bitter</td><td>2.8</td></tr><tr><td>Regent Hotel</td><td>New</td><td>2.2</td></tr><tr><td>Regent Hotel</td><td>Victoria Bitter</td><td>2.2</td></tr><tr><td>Royal Hotel</td><td>New</td><td>2.3</td></tr><tr><td>Royal Hotel</td><td>Old</td><td>2.3</td></tr><tr><td>Royal Hotel</td><td>Victoria Bitter</td><td>2.3</td></tr></tbody></table></div><h2 id="SQL语法及样例"><a href="#SQL语法及样例" class="headerlink" title="SQL语法及样例"></a>SQL语法及样例</h2><h3 id="SQL-SELECT"><a href="#SQL-SELECT" class="headerlink" title="SQL SELECT"></a>SQL SELECT</h3><p><strong>语法：</strong>π<sub>{attributes}</sub>(σ<sub>Condition</sub>(Relations))</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT attributesFROM relationsWHERE condition<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>例：</strong>哪个啤酒是Toohey制造的？</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 指定where语句查询条件的方法SELECT Name FROM Beers WHERE Manf = 'Toohey''s';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>例</strong>：查询Drinkers的名字和地址：π<sub>Name,Addr</sub>(Drinkers)</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查询结果筛选字段名的方法SELECT Name, Addr FROM Drinkers;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>例</strong>：查询Drinkers的所有信息</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 显示所有字段的方法SELECT * FROM Drinkers;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>例</strong>：查询Beers的所有品牌和制造商</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 显示结果为字段名重命名的方法SELECT name AS Brand, manf AS Brewer FROM Beers;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>例</strong>：查询各个酒吧售卖啤酒的售价，价格用Yen表示</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 修改查询结果数值，并修改显示字段名的方法SELECT bar, beer, price*120 AS PriceInYen FROM Sells;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>例</strong>：查询喜欢Sparkling Ale啤酒的人，并修改显示结果为likes Cooper’s</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 修改查询结果显示内容的方法SELECT drinker, 'likes Cooper''s' AS WhoLikesFROM LikesWHERE beer = 'Sparkling Ale';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：查询John喜欢的啤酒的酿酒商：π<sub>manf</sub> (σ<sub>drinker=’John′</sub> Likes ⋈ Beers)</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 多表联查的方法SELECT Manf FROM Likes, Beers WHERE drinker = 'John' AND beer = name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>例</strong>：查询哪个酒吧的名字和啤酒的名字相同</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 解决字段名冲突的方法SELECT Bars.nameFROM Bars, BeersWHERE Bars.name = Beers.name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：查询售价大于3.00的啤酒</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 查询时指定表名的用法SELECT Sells.beerFROM SellsWHERE Sells.price &gt; 3.00;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：查询售卖New啤酒价格与Coogee Bay酒吧售卖Victoria Bitter价格相同的酒吧</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 使用子句查询SELECT barFROM SellsWHERE beer = 'New'      AND price =(SELECT price  FROM Sells  WHERE bar = 'Coogee Bay Hotel'  AND beer = 'Victoria Bitter' );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 不使用子句查询SELECT b2.barFROM Sells b1, Sells b2WHERE b1.beer = 'Victoria Bitter' and b1.bar = 'Coogee Bay Hotel' and b1.price = b2.price and b2.beer = 'New';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：查询John喜欢的啤酒品牌及其制造商</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- IN的使用方法SELECT *FROM BeersWHERE name IN       (SELECT beer        FROM Likes        WHERE drinker = 'John'         );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 不使用IN的查询方法SELECT Beers.*FROM Beers, LikesWhere Beers.name = Likes.beer and Likes.drinker = 'John';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：查询只生产一种啤酒品牌的制造商</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- EXISTS的用法SELECT nameFROM Beers b1WHERE NOT EXISTS(SELECT * FROM Beers WHERE manf = b1.manf AND name != b1.name );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：查询售价最高的啤酒</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- ALL的使用方法SELECT beerFROM SellsWHERE price &gt;=    ALL(          SELECT price          FROM sells           );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：查询喜欢喝某品牌啤酒的人，同时他经常去的还售卖此种酒的酒吧</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 交集INTERSECT的用法(SELECT *  FROM Likes)INTERSECT(SELECT drinker,beer  FROM Sells, Frequents  WHERE Frequents.bar = Sells.bar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：找到售卖Justin喜欢的所有啤酒的酒吧：π<sub>bar,beer</sub>Sells ÷ (π<sub>beer</sub>(σ<sub>drinker=′Justin′ </sub>Likes))</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 除EXCEPT的使用select distinct a.barfrom sells awhere not exists( (select b.beer from likes b    where b.drinker = 'Justin')    except   (select c.beer from sells c     where c.bar = a.bar )  );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：查询New啤酒的平均售价</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 平局值AVG的用法SELECT AVG(price)          FROM SellsWHERE beer = 'New';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：查询有多少酒吧售卖啤酒</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- DISTINCT的用法SELECT COUNT(DISTINCT bar)FROM Sells;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>类似的聚类函数有SUM     AVG    MIN     MAX     COUNT</li></ul><h3 id="SQL-GROUP-BY"><a href="#SQL-GROUP-BY" class="headerlink" title="SQL GROUP BY"></a>SQL GROUP BY</h3><p><strong>语法</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT attributes/aggregationsFROM relationsWHERE conditionGROUP BY attribute<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：查询有多少种不同的啤酒</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- COUNT的使用方法SELECT COUNT(*) FROM Beers;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>例</strong>：查询每种啤酒制造商制造啤酒的数量</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- GROUP BY的用法SELECT manf, COUNT(beer)FROM Beers GROUP BY manf;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：查询每个人其经常去的酒吧New啤酒的平均售价</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- GROUP BY的用法二SELECT drinker, AVG(price)FROM Frequents, SellsWHERE beer = 'New' AND Frequents.bar = Sells.barGROUP BY drinker;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：查询每个酒吧最便宜的啤酒价格</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- GROUP BY和MIN的用法SELECT bar, MIN(price)FROM SellsGROUP BY BAR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：查询郊区的啤酒平均价格，不包括Rock区的酒吧</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- GROUP BY和AVG的用法SELECT Bars.addr, AVG(Sells.price)FROM Sells, BarsWHERE Bars.addr != 'The Rocks'AND Sells.bar = Bars.nameGROUP BY Bars.addr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SQL-HAVING"><a href="#SQL-HAVING" class="headerlink" title="SQL HAVING"></a>SQL HAVING</h3><p><strong>语法</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT attributes/aggregationsFROM relationsWHERE condition (on tuples)GROUP BY attributeHAVING condition (on group);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：查询流行啤酒的均价</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- HAVING的用法SELECT beer, AVG(price)FROM SellsGROUP BY beerHAVING COUNT(bar) &gt; 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SQL-CREATE-TABLE-定义表结构"><a href="#SQL-CREATE-TABLE-定义表结构" class="headerlink" title="SQL CREATE TABLE 定义表结构"></a>SQL CREATE TABLE 定义表结构</h3><p><strong>语法</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE RelName (attribute1 ˜ domain1 ˜ propertiesattribute2 ˜ domain2 ˜ propertiesattribute3 ˜ domain3 ˜ properties...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例：</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE Beers (name VARCHAR(20) PRIMARY KEY,manf VARCHAR(20),);CREATE TABLE Bars (name VARCHAR(30) PRIMARY KEY,addr VARCHAR(30),license INTEGER);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 定义一个主键CREATE TABLE Beers (name VARCHAR(20) PRIMARY KEY,manf VARCHAR(20),);-- 定义多个主键CREATE TABLE Beers (name VARCHAR(20),manf VARCHAR(20),  PRIMARY KEY(name, manf));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 指定必须具有唯一值attribute domain UNIQUE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 定制默认值CREATE TABLE Likes (drinker VARCHAR(20) DEFAULT 'Joe',beer VARCHAR(30) DEFAULT 'New',PRIMARY KEY(drinker, beer));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例：</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- NOT NULL非空约束CREATE TABLE Likes (drinker VARCHAR(20) PRIMARY KEY,beer VARCHAR(30) NOT NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例：</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- CHECK约束CREATE TABLE Example(gender CHAR(1) CHECK (gender IN ('M','F')),Xvalue INT NOT NULL,Yvalue INT CHECK (Yvalue &gt; Xvalue),Zvalue FLOAT CHECK (Zvalue &gt; ( SELECT MAX(price) FROM Sells)));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SQL-INSERT-插入数据"><a href="#SQL-INSERT-插入数据" class="headerlink" title="SQL INSERT 插入数据"></a>SQL INSERT 插入数据</h3><p><strong>语法：</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 插入具体数据INSERT INTO Relation VALUES (val1, val2, val3, ...)-- 按查询结果插入数据INSERT INTO Relation ( Subquery );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 插入一条数据INSERT INTO Likes VALUES ('Justin', 'Old');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 按指定字段顺序插入数据INSERT INTO Sells(price,bar,beer) VALUES    (2.50, 'Coogee Bay Hotel', 'Pale Ale');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TABLE DrinkingBuddies (name varchar(20));INSERT INTO DrinkingBuddies(SELECT DISTINCT f2.drinkerFROM Frequents f1, Frequents f2WHERE f1.drinker = 'John'AND f2.drinker != 'John'AND f1.bar = f2.bar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SQL-DELETE-删除数据"><a href="#SQL-DELETE-删除数据" class="headerlink" title="SQL DELETE 删除数据"></a>SQL DELETE 删除数据</h3><p><strong>语法</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DELETE FROM RelationWHERE Condition<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 按指定条件删除表数据DELETE FROM LikesWHERE drinker = 'Justin'AND beer = 'Sparkling Ale';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 清空表数据DELETE FROM R;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>例</strong>：删除所有与同一制造商生产的啤酒相同的啤酒</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DELETE FROM Beers bWHERE EXISTS( SELECT name   FROM Beers   WHERE manf = b.manf   AND name != b.name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SQL-UPDTE-更新表数据"><a href="#SQL-UPDTE-更新表数据" class="headerlink" title="SQL UPDTE 更新表数据"></a>SQL UPDTE 更新表数据</h3><p><strong>语法</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">UPDATE RSET list of assignmentsWHERE Condition<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 更新一条数据UPDATE DrinkersSET addr = 'Coogee' ,    phone = '9665-4321'WHERE name = 'John';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 更新多条数据UPDATE SellsSET price = 3.00WHERE price &gt; 3.00;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 每种啤酒的售价提升10%UPDATE SellsSET price = price * 1.10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="ALTER-TABLE-修改表结构语句"><a href="#ALTER-TABLE-修改表结构语句" class="headerlink" title="ALTER TABLE 修改表结构语句"></a>ALTER TABLE 修改表结构语句</h3><p><strong>语法</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER TABLE Relation Modifications<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 增加表字段ALTER TABLE BarsADD phone char(10) DEFAULT 'Unlisted';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>例：</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 增加多个表字段ALTER TABLE Bars Add opens NUMERIC(4,2) DEFAULT 10.00 ,Add closes NUMERIC(4,2) DEFAULT 23.00 ,Add manager VARCHAR(20);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SQL-VIEWS"><a href="#SQL-VIEWS" class="headerlink" title="SQL VIEWS"></a>SQL VIEWS</h3><p><strong>语法</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 创建ViewCREATE VIEW ViewName AS Query-- 删除ViewDROP VIEW ViewName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE VIEW MyBeers ASSELECT name, manfFROM BeersWHERE manf = 'Carlton';SELECT * FROM MyBeers;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE VIEW InnerCityHotels ASSELECT name, licenseFROM BarsWHERE addr = 'The Rocks' OR addr = 'Sydney';SELECT * FROM InnerCityHotels;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE VIEW InnerCityPubs ASSELECT name AS pub, license AS licFROM BarsWHERE addr IN ('The Rocks', 'Sydney');CREATE VIEW InnerCityPubs(pub,lic) ASSELECT name, licenseFROM BarsWHERE addr IN ('The Rocks', 'Sydney');CREATE VIEW InnerCityHotels ASSELECT name, licenseFROM BarsWHERE addr IN ('The Rocks', 'Sydney');SELECT pub FROM InnerCityHotels WHERE lic = '123456';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例</strong>：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 通过VIEW添加数据CREATE VIEW CityHotels ASSELECT name,addr FROM BarsWHERE addr IN ('The Rocks', 'Sydney');INSERT INTO CityHotelsVALUES ('Jackson''s on George', 'Sydney');SELECT * FROM CityHotels;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SQL-DROP-TABLE删除表"><a href="#SQL-DROP-TABLE删除表" class="headerlink" title="SQL DROP TABLE删除表"></a>SQL DROP TABLE删除表</h3><p><strong>语法</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DROP TABLE RelName;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="SQL的详细规则"><a href="#SQL的详细规则" class="headerlink" title="SQL的详细规则"></a>SQL的详细规则</h2><h3 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h3><p><strong>语法：</strong></p><p><strong>SELECT</strong> attributes <strong>FROM</strong> relations <strong>WHERE</strong> condition</p><p><strong>例：</strong>哪个啤酒是Toohey制造的？</p><p><strong>答：**</strong>SELECT<strong> Name </strong>FROM<strong> Beers </strong>WHERE** Manf = ‘Toohey’’s’;</p><p><strong>结果</strong>：</p><div class="table-container"><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td>New</td></tr><tr><td>Old</td></tr><tr><td>Red</td></tr><tr><td>Sheaf Stout</td></tr></tbody></table></div><p><strong>注意：</strong></p><ul><li><p>字符中含有’符号时，需要双写为’’</p></li><li><p>SELECT功能可以使用关系代数中的选择（Select）、投影（Project）、连接（Join）</p></li></ul><h3 id="SQL标示符"><a href="#SQL标示符" class="headerlink" title="SQL标示符"></a>SQL标示符</h3><p>标示符名称用于标识对象，如表、属性、视图等</p><p>SQL中的标识符使用与普通编程语言类似的约定，如：</p><ul><li>必须以字母开头的字母数字序列</li><li>不区分大小写</li><li>不允使用许保留单词</li></ul><h3 id="SQL关键字"><a href="#SQL关键字" class="headerlink" title="SQL关键字"></a>SQL关键字</h3><p>SQL经常使用的关键字有：</p><p>ALTER    AND    CREATE<br>FROM    INSERT    NOT    OR<br>SELECT    TABLE    WHERE</p><p><strong>注：</strong></p><p>对于PostgreSQL的关键字，请参阅相关文档。</p><h3 id="SQL数据类型"><a href="#SQL数据类型" class="headerlink" title="SQL数据类型"></a>SQL数据类型</h3><p>SQL关系中的所有属性都指定了域</p><p>SQL支持一小部分有用的内置数据类型：字符串、数字、日期、位字符串</p><p>在PostgreSQL中允许自定义数据类型</p><p>各种类型的转换均可用，例如：日期到字符串，字符串到日期，整数为实数……以“使其有意义的方法”自动适应</p><p>自动执行基本域（类型）检查</p><p>约束可以用来“强制”更复杂的域成员条件</p><p>空值（NULL）是所有数据类型的成员</p><p>所有类型均可以使用比较操作符：&lt;    &gt;    &lt;=    &gt;=    =    !=</p><p>在WHERE表达式中可用布尔操作符AND、OR、NOT来组合比较结果</p><p>与NULL的比较结果为FALSE</p><p>可以使用以下命令显式测试NULL：</p><p>attr IS NULL         attr IS NOT NULL</p><p>大多数数据类型也有特定类型的操作可用（例如数字的算术）。实际应用哪些操作取决于实现。</p><h3 id="SQL字符串"><a href="#SQL字符串" class="headerlink" title="SQL字符串"></a>SQL字符串</h3><p>可以使用两种字符串：</p><p><strong>CHAR(n)</strong>…使用n个字节，左对齐，填充空白</p><p>VARCHAR(n)…使用0到n个字节，没有填充</p><p>字符串类型可以通过空白填充或截断来强制转换。</p><p>字符串字面值使用单引号写入。’John’ = “John” = “John “ != “JOHN”</p><p>str1 <strong>&lt;</strong> str2…使用字典顺序进行比较</p><p>str <strong>LIKE</strong>模式…匹配字符串到模式</p><p>两种模式匹配：</p><p><strong>%</strong>匹配任何字符（如 *）<br>_匹配任何单个字符（如 .）</p><p><strong>例如：</strong><br>Name <strong>LIKE</strong> ‘Ja<strong>%</strong>’            以“Ja”开头<br>Name LIKE  ‘<strong>_</strong>i<strong>%</strong>’            名称以“i”作为第二个字母<br>Name <strong>LIKE</strong> ‘%o<strong>%</strong>o<strong>%</strong>’     名称包含两个“o”</p><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>string <strong>||</strong> string … 连接两个字符串</p><p><strong>例如：</strong>‘Post’|| ‘greSQL’ -&gt; PostgreSQL</p><p><strong>LENGTH</strong>(str) … 返回字符串长度</p><p><strong>SUBSTR</strong> (str,开始,长度)……从字符串中提取字符</p><p><strong>substring</strong>(‘Thomas’, 2, 3) -&gt; hom</p><h3 id="SQL日期"><a href="#SQL日期" class="headerlink" title="SQL日期"></a>SQL日期</h3><p>日期只是特殊格式的字符串，通过一系列操作来实现日期语义。</p><p>经典的格式为 DD-Mon-YYYY，如：’18-Aug-1998’</p><p>接受其他格式</p><p>可使用比较运算符&lt;和&gt;进行比较</p><p>(start1, end1) <strong>OVERLAPS</strong> (start2, end2)</p><p>如果第一段日期与第二段日期有重叠，则返回True，否则返回False</p><p><strong>例如：</strong></p><p><strong>SELECT</strong> (DATE ‘2001-02-16’, DATE ‘2001-12-21’) <strong>OVERLAPS</strong> (DATE ‘2001-10-30’, DATE ‘2002-10-30’);  -&gt; 结果: True</p><h3 id="SQL数字"><a href="#SQL数字" class="headerlink" title="SQL数字"></a>SQL数字</h3><p>可以使用各种类型的数字：<br>smallint, int, bigint…2字节，4字节和8字节的整数<br>real, double precision…4字节8字节的浮点数<br>numeric(precision, scale)<br>scale是小数点右侧的小数部分的数。precision是整个数字中所有有效数字的总数</p><p>算数运算符：+  - * / abs ceil floor power sqrt sin …</p><p>一些运算适用于关系中的一列数字：</p><p>AVG (attr)…            属性值的平均值<br>COUNT(attr)…        属性列的行数<br>MIN/MAX(attr)…    最小/最大的attr值<br>SUM(attr)…            attr的值的总和</p><p>NULL 在算术操作生成结果为NULL，但参与列操作时被忽略</p><h3 id="SQL元组和集合"><a href="#SQL元组和集合" class="headerlink" title="SQL元组和集合"></a>SQL元组和集合</h3><p>Tuple和set常量都写成(val1, val2, val3, … )</p><p>正确的解释是从上下文中得出的</p><p><strong>例如：</strong></p><p>Tuple含义：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">Student(stude#, name, course)( 2177364, ’Jack Smith’, ’BSc’)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Set含义</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT nameFROM EmployeesWHERE job IN (’Lecturer’, ’Tutor’, ’Professor’);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="查询单个关系"><a href="#查询单个关系" class="headerlink" title="查询单个关系"></a>查询单个关系</h3><p>格式（关系代数）：</p><p>从关系R FROM子句</p><p>在 WHERE 子句中使用 Condition 实现 σ </p><p>在 SELECT 子句中使用 Attributes 实现 π </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT AttributesFROM RWHERE Conditions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从操作上来说，我们考虑的是一个元组变量，其范围涵盖了关系的所有元组。</p><p>操作的语义：</p><pre class="line-numbers language-none"><code class="language-none">FOR EACH tuple T in R DOcheck whether T satisfies the condition in the WHERE clauseIF it does THENprint the attributes of T that arespecified in the SELECT clauseENDEND<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SQL投影"><a href="#SQL投影" class="headerlink" title="SQL投影"></a>SQL投影</h3><p>假设一个关系R和属性 X ⊆ R.</p><p>π<sub>X</sub> (R) 在SQL中实现如下:</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT X FROM R<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>例子：</strong></p><p>投影drinkers的名字：π<sub>Name</sub>(Drinkers)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT Name FROM Drinkers;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>结果为：</strong></p><div class="table-container"><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td>Adam</td></tr><tr><td>Gernot</td></tr><tr><td>John</td></tr><tr><td>Justin</td></tr></tbody></table></div><p><strong>例子：</strong></p><p>drinkers的名字和地址 π<sub>Name,Addr</sub>(Drinkers)</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT Name, Addr FROM Drinkers;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果为：</p><div class="table-container"><table><thead><tr><th>NAME</th><th>ADDR</th></tr></thead><tbody><tr><td>Adam</td><td>Randwick</td></tr><tr><td>Gernot</td><td>Newtown</td></tr><tr><td>John</td><td>Clovelly</td></tr><tr><td>Justin</td><td>Mosman</td></tr></tbody></table></div><p>符号∗表示所有属性的列表。</p><p>例如：</p><p>drinkers的所有信息：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM Drinkers;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><div class="table-container"><table><thead><tr><th>ame</th><th>Addr</th><th>Phone</th></tr></thead><tbody><tr><td>Adam</td><td>Randwick</td><td>9385-4444</td></tr><tr><td>Gernot</td><td>Newtown</td><td>9415-3378</td></tr><tr><td>John</td><td>Clovelly</td><td>9665-1234</td></tr><tr><td>Justin</td><td>Mosman</td><td>9845-4321</td></tr></tbody></table></div><h3 id="SQL选择"><a href="#SQL选择" class="headerlink" title="SQL选择"></a>SQL选择</h3><p>σ<bar>Cond</bar>(Rel) 在SQL中实现如下:</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM Rel WHERE Cond<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：找出Regent Hotel对新产品的价格</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT priceFROM SellsWHERE bar = ’Regent Hotel’ AND beer = ’New’;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：<br>| PRICE |<br>| ——- |<br>| 22    |</p><p>条件可以是任意复杂的布尔值表达式，使用前面提到的操作符。</p><p>典型的SELECT查询格式为：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT a1, a2, a3FROM RelWHERE Cond<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这对应于select后面跟着project：</p><p>π<sub>{a1,a2,a3}</sub>(σ<sub>Cond</sub>(Rel))</p><h3 id="使用AS重命名"><a href="#使用AS重命名" class="headerlink" title="使用AS重命名"></a>使用AS重命名</h3><p>Ullman/Widom定义了一个重命名操作符ρ，以避免名称冲突。</p><p>例如，“学术”和“学生”的地址栏</p><p>例子：ρ<sub>Beers(Brand,Brewer)</sub>(Beers)</p><p>给出一个新的关系，使用与Beers相同的数据，但是属性名称改变了。</p><p>SQL提供AS来解决这个问题，它用于SELECT部分。</p><p><strong>例子</strong></p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT name AS Brand, manf AS Brewer FROM Beers;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：<br>| BRAND| BREWER|<br>| ————————————-| ——————————|<br>| 80/- | Caledonian|<br>| Bigfoot Barley Wine| Sierra Nevada|<br>| Burragorang Bock | George IV Inn|<br>| Crown Lager| Carlton|<br>| Fosters Lager | Carlton|<br>| Invalid Stout| Carlton|</p><h3 id="表达式作为列中的值"><a href="#表达式作为列中的值" class="headerlink" title="表达式作为列中的值"></a>表达式作为列中的值</h3><p>AS还可以用于引入计算值</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT bar, beer, price*120 AS PriceInYen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><div class="table-container"><table><thead><tr><th>BAR</th><th>BEER</th><th>PRICEINYEN</th></tr></thead><tbody><tr><td>Australia Hotel</td><td>Burragorang Bock</td><td>420</td></tr><tr><td>Coogee Bay Hotel</td><td>New</td><td>270</td></tr><tr><td>Coogee Bay Hotel</td><td>Old</td><td>300</td></tr><tr><td>Coogee Bay Hotel</td><td>Sparkling Ale</td><td>336</td></tr><tr><td>Coogee Bay Hotel</td><td>Victoria Bitter</td><td>276</td></tr></tbody></table></div><p>这只是显示数据库数据，但没有对数据库进行更改</p><h3 id="在结果表中插入文本"><a href="#在结果表中插入文本" class="headerlink" title="在结果表中插入文本"></a>在结果表中插入文本</h3><p>技巧：要将文本放入输出列，请使用带有AS的常量表达式。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT drinker, ‘likes Cooper’’s’ AS WhoLikesFROM LikesWHERE beer = ‘Sparkling Ale’;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：<br>|DRINKER|WHOLIKES|<br>|———————|———————|<br>|Gernot|likes Cooper’s|<br>|Justin |likes Cooper’s|</p><h3 id="查询多关系"><a href="#查询多关系" class="headerlink" title="查询多关系"></a>查询多关系</h3><p>找到约翰喜欢的啤酒酿造商。</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT Manf FROM Likes, Beers WHERE drinker = ‘John’ AND beer = name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：<br>| MANF|<br>|——————————|<br>|Caledonian|<br>|Sierra Nevada|<br>|Sierra Nevada|<br>|Lord Nelson|</p><p>注意：可以使用DISTINCT来消除重复项。</p><p>关系代数：π<sub>manf</sub> (σ<sub>drinker=‘John′</sub> Likes ⋈ Beers).</p><p>语法：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT AttributesFROM R1, R2, ...WHERE ConditionFROM clause contains a list of relations.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>SQL SELECT语句的几个关系：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT AttributesFROM R1, R2, ...WHERE Condition<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>形式语义（关系代数）：</p><p>从乘积R1 × R2 ×…在FROM子句<br>应用σ使用条件在WHERE子句<br>应用π使用属性在SELECT子句</p><p>SELECT的操作语义:</p><pre class="line-numbers language-none"><code class="language-none">FOR EACH tuple T1 in R1 DOFOR EACH tuple T2 in R2 DO    ...         check WHERE condition for current         assignment of T1, T2, ... vars         IF holds THENprint attributes of T1, T2, ...specified in SELECTEND          END     ...END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于效率的原因，它不以这种方式实现！</p><h3 id="属性名称冲突"><a href="#属性名称冲突" class="headerlink" title="属性名称冲突"></a>属性名称冲突</h3><p>如果选择条件引用两个关系，或关系具有相同名称的属性，则可以使用关系名称来消除歧义。</p><p><strong>例子：</strong></p><p>哪些酒店的名字和啤酒相同?</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT Bars.nameFROM Bars, BeersWHERE Bars.name = Beers.name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：</p><p>它们都没有，所以结果是空的。</p><p>可以使用这样的限定名，即使没有歧义:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT Sells.beerFROM SellsWHERE Sells.price &gt; 3.00;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>建议:<br>只有在绝对必要时才对属性名进行限定。不能使用SQL的AS操作符来解析名称冲突。</p><h3 id="表名称冲突"><a href="#表名称冲突" class="headerlink" title="表名称冲突"></a>表名称冲突</h3><p>如果我们在SELECT中使用同一个关系两次，那么relationship-dot-attribute约定将不起作用。</p><p>要处理这个问题，我们需要在FROM子句中为关系的每个“实例”定义新的名称。</p><p>举例：找几双同一厂商生产的啤酒。</p><p>注意：我们应该避免：<br>将啤酒与自身搭配如(New,New)<br>相同的配对如 (New,Old) (Old,New)</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT b1.name, b2.name FROM Beers b1, Beers b2 WHERE b1.manf = b2.manf AND b1.name &lt; b2.name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>SELECT-FROM-WHERE查询的结果可以在另一个查询的WHERE子句中使用。</p><p>最简单的例子:子查询返回一个元组。可以将结果视为常数值并使用=。</p>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9311 </tag>
            
            <tag> 手册 </tag>
            
            <tag> 持续更新 </tag>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础课程笔记（3）</title>
      <link href="/2021/02/28/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-3/"/>
      <url>/2021/02/28/unsw/comp9311/shu-ju-ku-ji-chu-ke-cheng-bi-ji-3/</url>
      
        <content type="html"><![CDATA[<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><h4 id="关系数据库语言的分类"><a href="#关系数据库语言的分类" class="headerlink" title="关系数据库语言的分类"></a>关系数据库语言的分类</h4><p><strong>关系代数语言</strong>：用对关系的运算来表达查询要求</p><p><strong>关系演算语言</strong>：用谓词来表达查询要求</p><ul><li>元组关系演算语言<br>谓词变元的基本对象是元组变量<br>代表：APLHA, QUEL</li><li>域关系演算语言<br>谓词变元的基本对象是域变量<br>代表：QBE</li></ul><p><strong>具有关系代数和关系演算双重特点的语言</strong><br>代表：SQL（Structured Query Language）</p><h2 id="关系代数-1"><a href="#关系代数-1" class="headerlink" title="关系代数"></a>关系代数</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>关系代数是一种抽象的查询语言，它用对关系的运算来表达查询。</p><p>关系代数是一种过程性DML。</p><h4 id="关系代数的特点"><a href="#关系代数的特点" class="headerlink" title="关系代数的特点"></a>关系代数的特点</h4><ul><li>运算对象是关系</li><li>运算结果亦为关系</li><li>关系代数的运算符有两类：集合运算符和专门的关系运算符</li></ul><div class="table-container"><table><thead><tr><th></th><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>集合运算符</td><td>$\cup $</td><td>并（Union）</td></tr><tr><td></td><td>$- $</td><td>差（Difference）</td></tr><tr><td></td><td>$\cap $</td><td>交（Intersection）</td></tr><tr><td></td><td>$\times$</td><td>笛卡尔积（Cartesian Product）</td></tr><tr><td>专门的关系运算符</td><td>$\sigma$</td><td>选择（Select）</td></tr><tr><td></td><td>$ \pi$</td><td>投影（Project）</td></tr><tr><td></td><td>$\Join$</td><td>连接（Join）</td></tr><tr><td></td><td>$\div$</td><td>除（Divide）</td></tr></tbody></table></div><h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><h4 id="（1）-R-t-in-R-t-A-i"><a href="#（1）-R-t-in-R-t-A-i" class="headerlink" title="（1）$R,t\in R,t[A_i]$"></a>（1）$R,t\in R,t[A_i]$</h4><p>设关系模式为$R(A_1,A_2,\dots , A_n)$<br>它的一个关系设为$R$<br>$t \in R $表示$t$是$R$的一个元组<br>$t[A_i]$则表示元组$t$中相应于属性$A_i$的一个分量</p><h4 id="（2）-A-t-A-bar-A"><a href="#（2）-A-t-A-bar-A" class="headerlink" title="（2）$A,t[A], \bar{A}$"></a>（2）$A,t[A], \bar{A}$</h4><p>若$A={A_{i1}, A_{i2}, \dots, A_{ik}}$ ，其中$A_{i1}, A_{i2}, \dots, A_{ik}$ 是$A_{1}, A_{2}, \dots, A_{n}$ 中的一部分，则$A$称为属性列或属性组。<br>$t[A]=(t[A_{i1}],t[A_{i2}],\dots,t[A_{ik}])$表示元组$t$在属性列$A$上诸分量的集合。<br>$\bar{A}$则表示${A_{1}, A_{2}, \dots, A_{n}}$中去掉${A_{i1}, A_{i2}, \dots, A_{ik}}$后剩余的属性组。</p><h4 id="3-overset-frown-t-rt-s"><a href="#3-overset-frown-t-rt-s" class="headerlink" title="(3)$\overset{\frown}{t_rt_s}$"></a>(3)$\overset{\frown}{t_rt_s}$</h4><p>$R$为$n$目关系，$S$为$m$目关系。<br>$t_r\in R,t_s \in S, \overset{\frown}{t_rt_s}$称为元组的连接。<br>$\overset{\frown}{t_rt_s}$是一个$n+m$列的元组，前$n$个分量为$R$中的一个$n$元组，后$m$个分量为$S$中的一个$m$元组。</p><h4 id="4-象集-Z-x"><a href="#4-象集-Z-x" class="headerlink" title="(4)象集$Z_x$"></a>(4)象集$Z_x$</h4><p>给定一个关系$R（X，Z），X$和$Z$为属性组。 当$t[X]=x$时，$x$在$R$中的象集（Images Set）为：<br>$Zx={t[Z]|,t ∈R,t[X]=x}$<br>它表示$R$中属性组$X$上值为$x$的诸元组在$Z$上分量的集合</p><h3 id="本篇例题所使用数据库表"><a href="#本篇例题所使用数据库表" class="headerlink" title="本篇例题所使用数据库表"></a>本篇例题所使用数据库表</h3><p>STUDENT表：</p><div class="table-container"><table><thead><tr><th>Person#</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>Dr.C.C.Chen</td></tr><tr><td>3</td><td>Ms.K.Juliff</td></tr><tr><td>4</td><td>Ms.J.Gledill</td></tr><tr><td>5</td><td>Ms.B.K.Lee</td></tr></tbody></table></div><p>RESEARCHER表：</p><div class="table-container"><table><thead><tr><th>Person#</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>Dr.C.C.Chen</td></tr><tr><td>2</td><td>Dr.R.G.Wilkinson</td></tr></tbody></table></div><p>COURSE表：</p><div class="table-container"><table><thead><tr><th>Department</th><th>Name</th></tr></thead><tbody><tr><td>Psychology</td><td>Ph.D.</td></tr><tr><td>Comp.Sci.</td><td>Ph.D.</td></tr><tr><td>Comp.Sci.</td><td>M.Sc.</td></tr><tr><td>Psychology</td><td>M.Sc.</td></tr></tbody></table></div><p>ENROLMENT表：</p><div class="table-container"><table><thead><tr><th>Enrolment#</th><th>Supervisee</th><th>Supervisor</th><th>Department</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>2</td><td>Psychology</td><td>Ph.D.</td></tr><tr><td>2</td><td>3</td><td>1</td><td>Comp.Sci.</td><td>Ph.D.</td></tr><tr><td>3</td><td>4</td><td>1</td><td>Comp.Sci.</td><td>M.Sc.</td></tr><tr><td>4</td><td>5</td><td>1</td><td>Comp.Sci.</td><td>M.Sc.</td></tr></tbody></table></div><p><strong>例：选择学生为1的选课记录：</strong></p><script type="math/tex; mode=display">\sigma_{(Supervisor=1)}(ENROLMENT)</script><p>结果为：</p><div class="table-container"><table><thead><tr><th>Enrolment#</th><th>Supervisee</th><th>Supervisor</th><th>Department</th><th>Name</th></tr></thead><tbody><tr><td>2</td><td>3</td><td>1</td><td>Comp.Sci.</td><td>Ph.D.</td></tr><tr><td>3</td><td>4</td><td>1</td><td>Comp.Sci.</td><td>M.Sc.</td></tr><tr><td>4</td><td>5</td><td>1</td><td>Comp.Sci.</td><td>M.Sc.</td></tr></tbody></table></div><h2 id="传统的集合运算"><a href="#传统的集合运算" class="headerlink" title="传统的集合运算"></a>传统的集合运算</h2><h3 id="1-并（Union）"><a href="#1-并（Union）" class="headerlink" title="1. 并（Union）"></a>1. 并（Union）</h3><p>求并集是两个关系元组的集合理论并集。</p><script type="math/tex; mode=display">r\cup s=\{t:t∈r 或 t∈s\}</script><p>注意，求并集要求$R$和$S$是兼容的，具体要求如下：</p><ul><li>$R$和$S$ 具有相同的目$n$（即两个关系都有$n$个属性） ，两者的属性之间有1-1的对应关系</li><li>相应的属性取自同一个域<br>$R\cup S$ 仍为$n$目关系，由属于$R$或属于$S$的元组组成<br>$R\cup S =  \{ t|t ∈ R\lor t \in S\}$</li></ul><p><strong>例子</strong></p><p>设$R_1 ← σ _{(Supervisor=2)} (ENROLMENT)$，    $R_2 ← σ_{(Name=”M.Sc”)} (ENROLMENT)$</p><p>那么，$R_1 \cup R_2=$</p><div class="table-container"><table><thead><tr><th>Enrolment#</th><th>Supervisee</th><th>Supervisor</th><th>Department</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>2</td><td>Psych.</td><td>Ph.D.</td></tr><tr><td>3</td><td>4</td><td>1</td><td>Comp.Sci.</td><td>M.Sc.</td></tr><tr><td>4</td><td>5</td><td>1</td><td>Comp.Sci.</td><td>M.Sc.</td></tr></tbody></table></div><p><strong>例子</strong></p><p>$\text{STUDENT} \cup \text{RESEARCHER}=$ </p><div class="table-container"><table><thead><tr><th>Person#</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>Dr.C.C.Chen</td></tr><tr><td>3</td><td>Ms.K.Juliff</td></tr><tr><td>4</td><td>Ms.J.Gledill</td></tr><tr><td>5</td><td>Ms.B.K.Lee</td></tr><tr><td>2</td><td>Dr.R.G.Wilkinson</td></tr></tbody></table></div><h3 id="2-差（Difference）"><a href="#2-差（Difference）" class="headerlink" title="2. 差（Difference）"></a>2. 差（Difference）</h3><p>求差集即为求两个关系的元组的集合差。</p><script type="math/tex; mode=display">r−s=\{t:t∈r 且 t∉s\}</script><ul><li>$R$和$S$ 具有相同的目$n$ </li><li>相应的属性取自同一个域<br>$R - S $ 仍为$n$目关系，由属于$R$而不属于$S$的所有元组组成<br>$R -S = \{ t|t∈R∧t∉S \}$</li></ul><p><strong>例子：</strong></p><p>$\text{STUDENT} − \text{RESEARCHER} =$</p><div class="table-container"><table><thead><tr><th>Person#</th><th>Name</th></tr></thead><tbody><tr><td>3</td><td>Ms K. Juliff</td></tr><tr><td>4</td><td>Ms J. Gledhill</td></tr><tr><td>5</td><td>Ms B.K. Lee</td></tr></tbody></table></div><h3 id="3-交（Intersection）"><a href="#3-交（Intersection）" class="headerlink" title="3.交（Intersection）"></a>3.交（Intersection）</h3><p>求交即求两个关系元组的集合理论交集。</p><script type="math/tex; mode=display">r\cap s=\{t:t∈r and t∈s\}</script><ul><li>$R$和$S$具有相同的目$n$</li><li>相应的属性取自同一个域</li><li>$R∩S$ 仍为$n$目关系，由既属于$R$又属于$S$的元组组成</li><li>$R∩S = \{ t|t ∈ R∧t ∈S \}\\ R∩S = R –(R-S）$</li></ul><p><strong>例子</strong></p><p>设$R_1 ← σ_{(Supervisor=1)} (ENROLMENT)\quad R_2 ← σ_{ (Name=“Ph.D.′′)} (ENROLMENT)$</p><p>则$R_1 \cap R_2=$</p><div class="table-container"><table><thead><tr><th>Enrolment#</th><th>Supervisee</th><th>Supervisor</th><th>Department</th><th>Name</th></tr></thead><tbody><tr><td>2</td><td>3</td><td>1</td><td>Comp.Sci.</td><td>Ph.D.</td></tr></tbody></table></div><p><strong>例子：</strong></p><p>$\text{STUDENT} ∩ \text{RESEARCHER} =$</p><div class="table-container"><table><thead><tr><th>Person#</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>Dr C.C. Chen</td></tr></tbody></table></div><h3 id="4-笛卡尔积（Cartesian-Product）"><a href="#4-笛卡尔积（Cartesian-Product）" class="headerlink" title="4.笛卡尔积（Cartesian Product）"></a>4.笛卡尔积（Cartesian Product）</h3><script type="math/tex; mode=display">r×s=\{t_1||t_2:t_1∈r 且 t_2∈s\}</script><p>其中$t_1||t_2$表示元组的拼接。</p><ul><li>$R: n$目关系，$k_1$个元组； $S: m$目关系，$k_2$个元组<br>对于$R×S$，有</li><li>列：$（n+m）$列元组的集合<br>元组的前$n$列是关系$R$的一个元组<br>后$m$列是关系$S$的一个元组</li><li>行：$k_1×k_2$个元组<br>$R×S = \{\overset{\frown}{t_rt_s}|t_r ∈R ∧ t_s∈S \}$</li></ul><p><strong>例子：</strong></p><p>$\text{ENROLMENT} × \text{RESEARCHER}=$</p><div class="table-container"><table><thead><tr><th>E’ment#</th><th>S’ee</th><th>S’or</th><th>D’ment</th><th>E’ment. Name</th><th>Person#</th><th>R’cher. Name</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>2</td><td>Psych.</td><td>Ph.D.</td><td>1</td><td>Dr C.C. Chen</td></tr><tr><td>1</td><td>1</td><td>2</td><td>Psych.</td><td>Ph.D.</td><td>2</td><td>Dr R.G.Wilkinson</td></tr><tr><td>2</td><td>3</td><td>1</td><td>Comp.Sci</td><td>Ph.D.</td><td>1</td><td>Dr C.C. Chen</td></tr><tr><td>2</td><td>3</td><td>1</td><td>Comp.Sci</td><td>Ph.D.</td><td>2</td><td>Dr R.G.Wilkinson</td></tr><tr><td>3</td><td>4</td><td>1</td><td>Comp.Sci</td><td>M.Sc.</td><td>1</td><td>Dr C.C. Chen</td></tr><tr><td>3</td><td>4</td><td>1</td><td>Comp.Sci</td><td>M.Sc.</td><td>2</td><td>Dr R.G.Wilkinson</td></tr><tr><td>4</td><td>5</td><td>1</td><td>Comp.Sci</td><td>M.Sc.</td><td>1</td><td>Dr C.C. Chen</td></tr><tr><td>4</td><td>5</td><td>1</td><td>Comp.Sci</td><td>M.Sc.</td><td>2</td><td>Dr R.G.Wilkinson</td></tr></tbody></table></div><p>更有用的是$R_1←\text{ENROLLMENT} × \text{RESEARCHER}$</p><script type="math/tex; mode=display">σ_{(Supervisor=Person\#)}(R_1)=</script><div class="table-container"><table><thead><tr><th>E’ment#</th><th>S’ee</th><th>S’or</th><th>D’ment</th><th>E’ment. Name</th><th>Person#</th><th>R’cher. Name</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>2</td><td>Psych.</td><td>Ph.D.</td><td>2</td><td>Dr R.G.Wilkinson</td></tr><tr><td>2</td><td>3</td><td>1</td><td>Comp.Sci.</td><td>Ph.D.</td><td>1</td><td>Dr C.C. Chen</td></tr><tr><td>3</td><td>4</td><td>1</td><td>Comp.Sci.</td><td>M.Sc.</td><td>1</td><td>Dr C.C. Chen</td></tr><tr><td>4</td><td>5</td><td>1</td><td>Comp.Sci.</td><td>M.Sc.</td><td>1</td><td>Dr C.C. Chen</td></tr></tbody></table></div><p>或者更好是：$R_1 ← \text{ENROLMENT} × \text{RESEARCHER}$</p><p>$R_2 ← σ_{(Supervisor=Person#)}(R1) =π\{E′ment#,S′ee,S′or,R′cher.Name,D′ment,E′ment.Name\}(R2) =$</p><div class="table-container"><table><thead><tr><th>E’ment#</th><th>S’ee</th><th>S’or</th><th>R’cher. Name</th><th>D’ment</th><th>E’ment. Name</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>2</td><td>Dr R.G.Wilkinson</td><td>Psych.</td><td>Ph.D.</td></tr><tr><td>2</td><td>3</td><td>1</td><td>Dr C.C. Chen</td><td>Comp.Sci.</td><td>Ph.D.</td></tr><tr><td>3</td><td>4</td><td>1</td><td>Dr C.C. Chen</td><td>Comp.Sci.</td><td>M.Sc.</td></tr><tr><td>4</td><td>5</td><td>1</td><td>Dr C.C. Chen</td><td>Comp.Sci.</td><td>M.Sc.</td></tr></tbody></table></div><p>最后一种连接也称为自然连接，倒数第二种是等距连接。</p><h2 id="数据库特有的运算"><a href="#数据库特有的运算" class="headerlink" title="数据库特有的运算"></a>数据库特有的运算</h2><h3 id="5-选择-Select"><a href="#5-选择-Select" class="headerlink" title="5. 选择 Select"></a>5. 选择 Select</h3><p>选择一个关系$r$元组的子集，满足某些条件。</p><script type="math/tex; mode=display">\sigma_B(r)= {r \in r:B(t)}</script><p>B是选择条件，由使用AND、OR和NOT组合的选择子句组成。</p><p>选择子句有这样的形式：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">&lt;attribute name&gt; &lt;op&gt; &lt;constant&gt; 或&lt;attribute name&gt; &lt;op&gt; &lt;attribute name&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中 ，<op>为$=, &lt;, ≤, &gt;, ≥ , ≠$之一</op></p><p><strong>例：请选择选课记录为1且不是Ph.D头衔的学生：</strong></p><script type="math/tex; mode=display">\sigma_{(Supervisor=1) AND\ NOT (Name \neq "Ph.D.")}(ENROLMENT)</script><p>结果为：<br>| Enrolment# | Supervisee | Supervisor | Department | Name  |<br>| ————— | ————— | ————— | ————— | ——- |<br>| 3          | 4          | 1          | Comp.Sci.  | M.Sc. |<br>| 4          | 5          | 1          | Comp.Sci.  | M.Sc. |</p><h4 id="选择操作具有的属性"><a href="#选择操作具有的属性" class="headerlink" title="选择操作具有的属性"></a>选择操作具有的属性</h4><p>交换性（Commutative）：</p><script type="math/tex; mode=display">σ_{ <cond1>} (σ_{ <cond2>} (R)) =    σ_{ <cond2>} (σ_{ <cond1>} (R))</script><p>连续的选择可以组合起来：</p><script type="math/tex; mode=display">σ_{<cond1>} (σ_{ <cond2>} (R)) =    σ_{ <cond1> AND <cond2>} (R)</script><h3 id="6-投影-PROJECT"><a href="#6-投影-PROJECT" class="headerlink" title="6. 投影 PROJECT"></a>6. 投影 PROJECT</h3><p>投影即映射到一个关系属性的子集$X$上。</p><script type="math/tex; mode=display">π_X(r)=\{t[X]:t∈r\}</script><p>注意，元组$t$是从属性到它们域的元素的映射。$t[X]$是映射到属性$X$集合的限制。</p><p><strong>例：学生们都选哪些课程?</strong></p><script type="math/tex; mode=display">π_{Department,Name}(ENROLMENT)=</script><p>结果为：<br>| Department|Name      |<br>| —— | —— |<br>|Psych.|Ph.D.|<br>|Comp.Sci.|Ph.D.|<br>| Comp.Sci.|M.Sc.|</p><h4 id="投影操作具有的属性"><a href="#投影操作具有的属性" class="headerlink" title="投影操作具有的属性"></a>投影操作具有的属性</h4><p>如果<list2>包含<list1>中的所有属性，那么</list1></list2></p><script type="math/tex; mode=display">π_{<list1>} (π_{<list2>} (R)) = π_{ <list1>} (R)</script><p>否则，这个操作没有正确定义</p><p><strong>选择交换（commute）</strong>，注意，$B$的范围不能在$X$之外</p><script type="math/tex; mode=display">π_{X} (σ_{B}(R)) = σ_{B} (π_{X}(R))</script><p>练习：用以下方法验证上述结论</p><script type="math/tex; mode=display">π_{\{Department\}} (σ_{(Department=“Psychology”)}(ENROLMENT))</script><p>注意，$π(R \cup S)) = π(R)\cup π(S)$是正确的，而$π(R\cap S)) = π(R)\cap π(S)$是<strong>不正确</strong>的</p><h3 id="7-连接-Join"><a href="#7-连接-Join" class="headerlink" title="7. 连接 Join"></a>7. 连接 Join</h3><p>用于组合两个关系中的相关元组。</p><h4 id="theta-连接（theta-join）"><a href="#theta-连接（theta-join）" class="headerlink" title="$\theta$连接（theta join）"></a>$\theta$连接（theta join）</h4><script type="math/tex; mode=display">r⋈B s=\{t_1||t_2:t_1∈r 且 t_2∈s 且 B\}</script><p>$B$由$A_iθ b_j$形式的条件组成，其中$A_i$是$R$的属性，$B_j$是$S$的属性，$θ$是比较运算符。</p><h4 id="等值连接（Equi-join）"><a href="#等值连接（Equi-join）" class="headerlink" title="等值连接（Equi-join）"></a>等值连接（Equi-join）</h4><p>是一个$\theta$连接，其中每个比较操作符都是“=”。</p><p><strong>例子：</strong></p><script type="math/tex; mode=display">{\text{ENROLEMENT} \\ \text{RESEARCHER}}⋈(Supervisor=Person\#)</script><h4 id="自然连接（Natural-join）"><a href="#自然连接（Natural-join）" class="headerlink" title="自然连接（Natural join）"></a>自然连接（Natural join）</h4><p>是一种每次比较只保留一个属性的等值连接。</p><p><strong>例子：</strong></p><script type="math/tex; mode=display">{\text{ENROLEMENT} \\ \text{RESEARCHER}}⋈(Supervisor),(Person\#)</script><p>问：如果两个关系没有联接属性，如何定义联接结果？为什么？</p><p>$R (A, B) ⋈ S (B, C) ⋈ T (C, D)$</p><p>注意：</p><ul><li>在自然连接中，可能有几对连接属性</li></ul><p><strong>例子：</strong></p><p>COURSE</p><div class="table-container"><table><thead><tr><th>Department</th><th>Name</th><th>By</th></tr></thead><tbody><tr><td>Comp.Sci</td><td>Ph.D.</td><td>Research</td></tr><tr><td>Comp.Sci.</td><td>M.Sc.</td><td>Research</td></tr><tr><td>Psychology</td><td>M.Sc.</td><td>Coursework</td></tr></tbody></table></div><script type="math/tex; mode=display">{\text{ENROLEMENT} \\ \text{COURSE}}⋈(Department,Name),(Department,Name)</script><ul><li>如果连接属性对恰好是命名相同的那些，我们可以这样写</li></ul><script type="math/tex; mode=display">\text{ENROLMENT}⋈\text{COURSE}</script><h3 id="3-8-除-Divide"><a href="#3-8-除-Divide" class="headerlink" title="3.8 除 Divide"></a>3.8 除 Divide</h3><p>假设$R$是$Z$上的一个关系式，$S$在$X$上，且$X\subseteq Z$，令$Y = Z−X$，则$R ÷ S$也是在$Y$上的关系</p><script type="math/tex; mode=display">R ÷ S = \{t: t × S\subseteq R\}</script><p><strong>例子：</strong></p><p>P<br>| A    | B    |<br>| —— | —— |<br>| a1   | b1   |<br>| a1   | b2   |<br>| a2   | b1   |<br>| a3   | b2   |<br>| a4   | b1   |<br>| a5   | b1   |<br>| a5   | b2   |</p><p>Q</p><div class="table-container"><table><thead><tr><th>B</th></tr></thead><tbody><tr><td>b1</td></tr><tr><td>b2</td></tr></tbody></table></div><p>$P÷Q=$</p><div class="table-container"><table><thead><tr><th>A</th></tr></thead><tbody><tr><td>a1</td></tr><tr><td>a5</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9311 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3教程笔记（1）</title>
      <link href="/2021/02/26/ji-zhu-xue-xi/python/python3-jiao-cheng-bi-ji-1/"/>
      <url>/2021/02/26/ji-zhu-xue-xi/python/python3-jiao-cheng-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文根据<a href="https://www.runoob.com/python3">菜鸟教程</a>整理</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><ul><li>默认编码：UTF-8</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding: cp-1252 -*-<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="标示符"><a href="#标示符" class="headerlink" title="标示符"></a>标示符</h4><p>需要符合以下正则表达式： [_A-Za-z]+[_A-Za-z0-9]* （变量名也支持中文）</p><h4 id="python保留字"><a href="#python保留字" class="headerlink" title="python保留字"></a>python保留字</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>单行注释 <strong>#</strong>，多行注释 <strong>‘’’</strong>和 <strong>“””</strong></p><h4 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h4><p>python使用行与缩进表示代码块，不使用{}等符号</p><h4 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h4><p>使用== \\==实现多行语句</p><ul><li>在 [], {}, 或 () 中，不需要使用多行语句</li></ul><h4 id="数字-Number-类型"><a href="#数字-Number-类型" class="headerlink" title="数字(Number)类型"></a>数字(Number)类型</h4><p>整数int、布尔型bool、浮点数float和复数complex</p><h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h4><ul><li><p>单引号’’及双引号””语义完全相同</p></li><li><p>使用三引号定义多行字符串</p></li><li><p>转义字符为<strong>\\</strong></p></li><li><p>使用<strong>r’内容’</strong>，使字符串中的内容不转义</p></li><li><p>使用<strong>+</strong>号拼接，使用<strong>*</strong>号重复</p></li><li><p>索引左侧数从0开始，右侧数从-1开始</p></li><li>没有单独的字符类型</li><li>字符串截取：<strong>变量[头下标:尾下标:步长]</strong></li></ul><h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><p>用于分割函数或类，不是Python语法，仅用于便于日后维护</p><h4 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!/usr/bin/python3input("\n\n按下 enter 键后退出。")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h4><p>语句见使用<strong>;</strong>分割</p><h4 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h4><p>即缩进相同的一组语句构成一个代码块</p><h4 id="print-输出"><a href="#print-输出" class="headerlink" title="print 输出"></a>print 输出</h4><ul><li>print 默认输出后换行</li></ul><p>不换行需要在尾部加上 <strong>end=””</strong></p><h4 id="import-与-from…import"><a href="#import-与-from…import" class="headerlink" title="import 与 from…import"></a>import 与 from…import</h4><ul><li><p>导入整个模块：<strong>import somemodule</strong></p></li><li><p>从模块中导入函数： <strong>from somemodule import firstfunc, secondfunc, thirdfunc</strong></p></li><li><p>导入模块中的全部函数： <strong>from somemodule import *</strong></p></li></ul><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><p>可使用python -h命令查看python帮助</p><h3 id="Python3-基本数据类型"><a href="#Python3-基本数据类型" class="headerlink" title="Python3 基本数据类型"></a>Python3 基本数据类型</h3><h4 id="变量声明及赋值"><a href="#变量声明及赋值" class="headerlink" title="变量声明及赋值"></a>变量声明及赋值</h4><ul><li>定义变量时不需要声明类型</li><li>使用<strong>=</strong>给变量赋值</li><li>使用del删除变量</li></ul><h4 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h4><p>允许同时为多个变量赋值，格式为</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a = b = c = 1# a,b,c均赋值为1a, b, c = 1, 2, "runoob"# a,b,c分别赋值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h4><ul><li><p>Number（数字）</p></li><li><p>String（字符串）</p></li><li><p>List（列表）</p></li><li><p>Tuple（元组）</p></li><li><p>Set（集合）</p></li><li><p>Dictionary（字典）</p></li></ul><p><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）</p><p><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）</p><h4 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h4><p>支持 <strong>int、float、bool、complex（复数）</strong></p><ul><li>Python3 没有Long，Python2有Long类型</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">type(a)# 查询对象类型，不会认为子类是一种父类类型isinstance(a, int) # 判断对象是否为指定类型，认为子类是一种父类类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="基本数学运算"><a href="#基本数学运算" class="headerlink" title="基本数学运算"></a>基本数学运算</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 5 + 4  # 加法&gt;&gt;&gt; 4.3 - 2 # 减法&gt;&gt;&gt; 3 * 7  # 乘法&gt;&gt;&gt; 2 / 4  # 除法，得到一个浮点数&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数&gt;&gt;&gt; 17 % 3 # 取余 &gt;&gt;&gt; 2 ** 5 # 乘方<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h4><ul><li>使用’’或“”定义，或使用 <strong>“””…”””</strong>  <strong>‘’’…’’’</strong> 跨越多行定义</li><li>使用\转义</li><li><p>截取字符串方法 变量名[头下标:尾下标]</p></li><li><p>使用+连接字符串，使用*重复字符串</p></li><li><p>使用r’’定义原始不转义字符串</p></li><li><p>索引从左往右以0开始，从右往左以-1开始</p></li></ul><h4 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h4><ul><li><p>使用<strong>[]</strong>符号定义，元素间使用<strong>,</strong>符号分割</p></li><li><p>列表中的数据类型可以不相同</p></li><li><p>可以被截取，截取方式为：<strong>变量名[头下标:尾下标]</strong> 或 <strong>变量名[头下标:尾下标:步长]</strong></p></li><li><p>可以被索引和切片，索引值以 <strong>0</strong> 为开始值，<strong>-1</strong> 为从末尾的开始位置</p></li><li><p>加号 <strong>+</strong> 是列表连接运算符，星号 <strong>*</strong> 是重复操作</p></li><li><p>列表中的元素可以改变</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a[0] = 9# 改变列表单个值a[2:5] = [13, 14, 15]# 改变列表多个值a[2:4] = []# 删除列表中的指定项数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h4><ul><li>使用<strong>()</strong>符号定义，元素之间用逗号隔开</li><li>元组的元素不能修改</li><li>可以被索引且下标索引从0开始，-1 为从末尾开始的位置</li><li><p>可以被截取，截取方式为：<strong>变量名[头下标:尾下标]</strong> 或 <strong>变量名[头下标:尾下标:步长]</strong></p></li><li><p>元组的元素可以是可变的对象，比如list列表</p></li><li><p>string、list 和 tuple 都属于 sequence（序列）</p></li></ul><h4 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h4><ul><li>使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 集合的运算a - b     # a 和 b 的差集a | b     # a 和 b 的并集a &amp; b     # a 和 b 的交集a ^ b     # a 和 b 中不同时存在的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h4><ul><li><p>使用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合</p></li><li><p>列表是有序的对象集合，字典是无序的对象集合</p></li><li>键(key)必须使用不可变类型</li><li>在同一个字典中，键(key)必须是唯一的，不能重复</li><li>字典类型也有一些内置的函数，例如clear()、keys()、values()</li><li>创建空字典使用 <strong>{ }</strong></li><li>字典是一种映射类型，它的元素是键值对</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字典的基本使用方法dict['one']       # 输出键为 'one' 的值dict[2]           # 输出键为 2 的值print (tinydict)          # 输出完整的字典到控制台tinydict.keys()   # 输出所有键tinydict.values() # 输出所有值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 构造函数 dict() 可以直接从键值对序列中构建字典dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)]){x: x**2 for x in (2, 4, 6)}dict(Runoob=1, Google=2, Taobao=3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h4><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-int.html">int(x [,base])</a></td><td style="text-align:left">将x转换为一个整数</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-float.html">float(x)</a></td><td style="text-align:left">将x转换到一个浮点数</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-complex.html">complex(real [,imag])</a></td><td style="text-align:left">创建一个复数</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-str.html">str(x)</a></td><td style="text-align:left">将对象 x 转换为字符串</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-repr.html">repr(x)</a></td><td style="text-align:left">将对象 x 转换为表达式字符串</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-eval.html">eval(str)</a></td><td style="text-align:left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s)</a></td><td style="text-align:left">将序列 s 转换为一个元组</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(s)</a></td><td style="text-align:left">将序列 s 转换为一个列表</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-set.html">set(s)</a></td><td style="text-align:left">转换为可变集合</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-dict.html">dict(d)</a></td><td style="text-align:left">创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s)</a></td><td style="text-align:left">转换为不可变集合</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-chr.html">chr(x)</a></td><td style="text-align:left">将一个整数转换为一个字符</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-ord.html">ord(x)</a></td><td style="text-align:left">将一个字符转换为它的整数值</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-hex.html">hex(x)</a></td><td style="text-align:left">将一个整数转换为一个十六进制字符串</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-oct.html">oct(x)</a></td><td style="text-align:left">将一个整数转换为一个八进制字符串</td></tr></tbody></table></div><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="Python算术运算符"><a href="#Python算术运算符" class="headerlink" title="Python算术运算符"></a>Python算术运算符</h4><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">加 - 两个对象相加</td><td style="text-align:left">a + b 输出结果 31</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">减 - 得到负数或是一个数减去另一个数</td><td style="text-align:left">a - b 输出结果 -11</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td style="text-align:left">a * b 输出结果 210</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">除 - x 除以 y</td><td style="text-align:left">b / a 输出结果 2.1</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">取模 - 返回除法的余数</td><td style="text-align:left">b % a 输出结果 1</td></tr><tr><td style="text-align:left">**</td><td style="text-align:left">幂 - 返回x的y次幂</td><td style="text-align:left">a**b 为10的21次方</td></tr><tr><td style="text-align:left">//</td><td style="text-align:left">取整除 - 向下取接近商的整数</td><td style="text-align:left"><code>&gt;&gt;&gt; 9//2 # 4</code><br><code>&gt;&gt;&gt; -9//2 # -5</code></td></tr></tbody></table></div><h4 id="Python比较运算符"><a href="#Python比较运算符" class="headerlink" title="Python比较运算符"></a>Python比较运算符</h4><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">==</td><td style="text-align:left">等于 - 比较对象是否相等</td><td style="text-align:left">(a == b) 返回 False。</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">不等于 - 比较两个对象是否不相等</td><td style="text-align:left">(a != b) 返回 True。</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">大于 - 返回x是否大于y</td><td style="text-align:left">(a &gt; b) 返回 False。</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td><td style="text-align:left">(a &lt; b) 返回 True。</td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:left">大于等于 - 返回x是否大于等于y。</td><td style="text-align:left">(a &gt;= b) 返回 False。</td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:left">小于等于 - 返回x是否小于等于y。</td><td style="text-align:left">(a &lt;= b) 返回 True。</td></tr></tbody></table></div><h4 id="Python赋值运算符"><a href="#Python赋值运算符" class="headerlink" title="Python赋值运算符"></a>Python赋值运算符</h4><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">简单的赋值运算符</td><td style="text-align:left">c = a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td style="text-align:left">+=</td><td style="text-align:left">加法赋值运算符</td><td style="text-align:left">c += a 等效于 c = c + a</td></tr><tr><td style="text-align:left">-=</td><td style="text-align:left">减法赋值运算符</td><td style="text-align:left">c -= a 等效于 c = c - a</td></tr><tr><td style="text-align:left">*=</td><td style="text-align:left">乘法赋值运算符</td><td style="text-align:left">c <em>= a 等效于 c = c </em> a</td></tr><tr><td style="text-align:left">/=</td><td style="text-align:left">除法赋值运算符</td><td style="text-align:left">c /= a 等效于 c = c / a</td></tr><tr><td style="text-align:left">%=</td><td style="text-align:left">取模赋值运算符</td><td style="text-align:left">c %= a 等效于 c = c % a</td></tr><tr><td style="text-align:left">**=</td><td style="text-align:left">幂赋值运算符</td><td style="text-align:left">c <strong>= a 等效于 c = c </strong> a</td></tr><tr><td style="text-align:left">//=</td><td style="text-align:left">取整除赋值运算符</td><td style="text-align:left">c //= a 等效于 c = c // a</td></tr><tr><td style="text-align:left">:=</td><td style="text-align:left">海象运算符，可在表达式内部为变量赋值。<strong>Python3.8 版本新增运算符</strong>。</td><td style="text-align:left">在这个示例中，赋值表达式可以避免调用 len() 两次:<br><code>if (n := len(a)) &gt; 10:    print(f"List is too long ({n} elements, expected &lt;= 10)")</code></td></tr></tbody></table></div><h4 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h4><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">&amp;</td><td style="text-align:left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td style="text-align:left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td style="text-align:left">$#124;</td><td style="text-align:left">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td style="text-align:left">(a \</td><td>b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">按位异或运算符：当两对应的二进位相异时，结果为1</td><td style="text-align:left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td style="text-align:left">~</td><td style="text-align:left">按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。<strong>~x</strong>类似于 <strong>-x-1</strong></td><td style="text-align:left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td></tr><tr><td style="text-align:left">&lt;&lt;</td><td style="text-align:left">左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td><td style="text-align:left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td style="text-align:left">&gt;&gt;</td><td style="text-align:left">右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数</td><td style="text-align:left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table></div><h4 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h4><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">逻辑表达式</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">and</td><td style="text-align:left">x and y</td><td style="text-align:left">布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td><td style="text-align:left">(a and b) 返回 20。</td></tr><tr><td style="text-align:left">or</td><td style="text-align:left">x or y</td><td style="text-align:left">布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td><td style="text-align:left">(a or b) 返回 10。</td></tr><tr><td style="text-align:left">not</td><td style="text-align:left">not x</td><td style="text-align:left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td style="text-align:left">not(a and b) 返回 False</td></tr></tbody></table></div><h4 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h4><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">in</td><td style="text-align:left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td style="text-align:left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td style="text-align:left">not in</td><td style="text-align:left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td style="text-align:left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table></div><h4 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h4><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">is</td><td style="text-align:left">is 是判断两个标识符是不是引用自一个对象</td><td style="text-align:left"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td style="text-align:left">is not</td><td style="text-align:left">is not 是判断两个标识符是不是引用自不同对象</td><td style="text-align:left"><strong>x is not y</strong> ， 类似 <strong>id(a) != id(b)</strong>。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table></div><ul><li><a href="https://www.runoob.com/python/python-func-id.html">id()</a> 函数用于获取对象内存地址</li><li><code>is</code> 用于判断两个变量引用对象是否为同一个， <code>==</code> 用于判断引用变量的值是否相等。</li></ul><h4 id="Python运算符优先级"><a href="#Python运算符优先级" class="headerlink" title="Python运算符优先级"></a>Python运算符优先级</h4><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">**</td><td style="text-align:left">指数 (最高优先级)</td></tr><tr><td style="text-align:left">~ + -</td><td style="text-align:left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td style="text-align:left">* / % //</td><td style="text-align:left">乘，除，求余数和取整除</td></tr><tr><td style="text-align:left">+ -</td><td style="text-align:left">加法减法</td></tr><tr><td style="text-align:left">&gt;&gt; &lt;&lt;</td><td style="text-align:left">右移，左移运算符</td></tr><tr><td style="text-align:left">&amp;</td><td style="text-align:left">位 ‘AND’</td></tr><tr><td style="text-align:left">^ |</td><td style="text-align:left">位运算符</td></tr><tr><td style="text-align:left">&lt;= &lt; &gt; &gt;=</td><td style="text-align:left">比较运算符</td></tr><tr><td style="text-align:left">== !=</td><td style="text-align:left">等于运算符</td></tr><tr><td style="text-align:left">= %= /= //= -= += <em>= *</em>=</td><td style="text-align:left">赋值运算符</td></tr><tr><td style="text-align:left">is    is not</td><td style="text-align:left">身份运算符</td></tr><tr><td style="text-align:left">in    not in</td><td style="text-align:left">成员运算符</td></tr><tr><td style="text-align:left">not and or</td><td style="text-align:left">逻辑运算符</td></tr></tbody></table></div><ul><li>逻辑比较中，顺序 not&gt;and&gt;or</li><li>Python3不再支持 &lt;&gt; 运算符</li></ul><h3 id="数字-Number"><a href="#数字-Number" class="headerlink" title="数字(Number)"></a>数字(Number)</h3><ul><li><strong>整型(Int)</strong> - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。</li><li><strong>浮点型(float)</strong> - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）</li><li><strong>复数( (complex))</strong> - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li></ul><h4 id="Python-数字类型转换"><a href="#Python-数字类型转换" class="headerlink" title="Python 数字类型转换"></a>Python 数字类型转换</h4><ul><li><strong>int(x)</strong> 将x转换为一个整数。</li><li><strong>float(x)</strong> 将x转换到一个浮点数。</li><li><strong>complex(x)</strong> 将x转换到一个复数，实数部分为 x，虚数部分为 0。</li><li><strong>complex(x, y)</strong> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。</li></ul><h4 id="Python-数字运算"><a href="#Python-数字运算" class="headerlink" title="Python 数字运算"></a>Python 数字运算</h4><p>加<code>+</code>, 减<code>-</code>,乘 <code>*</code> ,除<code>/</code>,取整除<code>//</code>,幂<code>**</code></p><ul><li>在交互模式中，最后被输出的表达式结果被赋值给变量 <code>_</code> </li></ul><h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">返回值 ( 描述 )</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-abs.html">abs(x)</a></td><td style="text-align:left">返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-ceil.html">ceil(x) </a></td><td style="text-align:left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td style="text-align:left">cmp(x, y)</td><td style="text-align:left">如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换</strong>。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-exp.html">exp(x) </a></td><td style="text-align:left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-fabs.html">fabs(x)</a></td><td style="text-align:left">返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-floor.html">floor(x) </a></td><td style="text-align:left">返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-log.html">log(x) </a></td><td style="text-align:left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-log10.html">log10(x) </a></td><td style="text-align:left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-max.html">max(x1, x2,…) </a></td><td style="text-align:left">返回给定参数的最大值，参数可以为序列。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-min.html">min(x1, x2,…) </a></td><td style="text-align:left">返回给定参数的最小值，参数可以为序列。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-modf.html">modf(x) </a></td><td style="text-align:left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-pow.html">pow(x, y)</a></td><td style="text-align:left">x**y 运算后的值。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-round.html">round(x [,n])</a></td><td style="text-align:left">返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。<strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-sqrt.html">sqrt(x) </a></td><td style="text-align:left">返回数字x的平方根。</td></tr></tbody></table></div><h4 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h4><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-choice.html">choice(seq)</a></td><td style="text-align:left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-randrange.html">randrange ([start,] stop [,step]) </a></td><td style="text-align:left">从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-random.html">random() </a></td><td style="text-align:left">随机生成下一个实数，它在[0,1)范围内。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-seed.html">seed([x]) </a></td><td style="text-align:left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-shuffle.html">shuffle(lst) </a></td><td style="text-align:left">将序列的所有元素随机排序</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-uniform.html">uniform(x, y)</a></td><td style="text-align:left">随机生成下一个实数，它在[x,y]范围内。</td></tr></tbody></table></div><h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-acos.html">acos(x)</a></td><td style="text-align:left">返回x的反余弦弧度值。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-asin.html">asin(x)</a></td><td style="text-align:left">返回x的反正弦弧度值。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-atan.html">atan(x)</a></td><td style="text-align:left">返回x的反正切弧度值。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-atan2.html">atan2(y, x)</a></td><td style="text-align:left">返回给定的 X 及 Y 坐标值的反正切值。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-cos.html">cos(x)</a></td><td style="text-align:left">返回x的弧度的余弦值。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-hypot.html">hypot(x, y)</a></td><td style="text-align:left">返回欧几里德范数 sqrt(x<em>x + y</em>y)。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-sin.html">sin(x)</a></td><td style="text-align:left">返回的x弧度的正弦值。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-tan.html">tan(x)</a></td><td style="text-align:left">返回x弧度的正切值。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-degrees.html">degrees(x)</a></td><td style="text-align:left">将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-number-radians.html">radians(x)</a></td><td style="text-align:left">将角度转换为弧度</td></tr></tbody></table></div><h4 id="数学常量"><a href="#数学常量" class="headerlink" title="数学常量"></a>数学常量</h4><div class="table-container"><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">pi</td><td style="text-align:left">数学常量 pi（圆周率，一般以π来表示）</td></tr><tr><td style="text-align:left">e</td><td style="text-align:left">数学常量 e，e即自然常数（自然常数）。</td></tr></tbody></table></div><h3 id="Python3-字符串"><a href="#Python3-字符串" class="headerlink" title="Python3 字符串"></a>Python3 字符串</h3><ul><li>使用引号( <code>'</code> 或 <code>"</code> )来创建字符串。</li></ul><h4 id="Python-访问字符串中的值"><a href="#Python-访问字符串中的值" class="headerlink" title="Python 访问字符串中的值"></a>Python 访问字符串中的值</h4><ul><li><p>不支持单字符类型</p></li><li><p>使用方括号 <strong>[]</strong> 来截取字符串</p></li></ul><h4 id="Python转义字符"><a href="#Python转义字符" class="headerlink" title="Python转义字符"></a>Python转义字符</h4><div class="table-container"><table><thead><tr><th style="text-align:left">转义字符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">\(在行尾时)</td><td style="text-align:left">续行符</td><td style="text-align:left"><code>&gt;&gt;&gt; print("line1 \ ... line2 \ ... line3") line1 line2 line3 &gt;&gt;&gt;</code></td></tr><tr><td style="text-align:left">\\</td><td style="text-align:left">反斜杠符号</td><td style="text-align:left"><code>&gt;&gt;&gt; print("\\") \</code></td></tr><tr><td style="text-align:left">\’</td><td style="text-align:left">单引号</td><td style="text-align:left"><code>&gt;&gt;&gt; print('\'') '</code></td></tr><tr><td style="text-align:left">\”</td><td style="text-align:left">双引号</td><td style="text-align:left"><code>&gt;&gt;&gt; print("\"") "</code></td></tr><tr><td style="text-align:left">\a</td><td style="text-align:left">响铃</td><td style="text-align:left"><code>&gt;&gt;&gt; print("\a")</code>执行后电脑有响声。</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">退格(Backspace)</td><td style="text-align:left"><code>&gt;&gt;&gt; print("Hello \b World!") Hello World!</code></td></tr><tr><td style="text-align:left">\000</td><td style="text-align:left">空</td><td style="text-align:left"><code>&gt;&gt;&gt; print("\000") &gt;&gt;&gt;</code></td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">换行</td><td style="text-align:left"><code>&gt;&gt;&gt; print("\n")  &gt;&gt;&gt;</code></td></tr><tr><td style="text-align:left">\v</td><td style="text-align:left">纵向制表符</td><td style="text-align:left"><code>&gt;&gt;&gt; print("Hello \v World!") Hello        World! &gt;&gt;&gt;</code></td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">横向制表符</td><td style="text-align:left"><code>&gt;&gt;&gt; print("Hello \t World!") Hello    World! &gt;&gt;&gt;</code></td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">回车，将 <strong>\r</strong> 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 <strong>\r</strong> 后面的内容完全替换完成。</td><td style="text-align:left"><code>&gt;&gt;&gt; print("Hello\rWorld!") World! &gt;&gt;&gt; print('google runoob taobao\r123456') 123456 runoob taobao</code></td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">换页</td><td style="text-align:left"><code>&gt;&gt;&gt; print("Hello \f World!") Hello        World! &gt;&gt;&gt;</code></td></tr><tr><td style="text-align:left">\yyy</td><td style="text-align:left">八进制数，y 代表 0~7 的字符，例如：\012 代表换行。</td><td style="text-align:left"><code>&gt;&gt;&gt; print("\110\145\154\154\157\40\127\157\162\154\144\41") Hello World!</code></td></tr><tr><td style="text-align:left">\xyy</td><td style="text-align:left">十六进制数，以 \x 开头，y 代表的字符，例如：\x0a 代表换行</td><td style="text-align:left"><code>&gt;&gt;&gt; print("\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21") Hello World!</code></td></tr><tr><td style="text-align:left">\other</td><td style="text-align:left">其它的字符以普通格式输出</td></tr></tbody></table></div><h4 id="Python字符串运算符"><a href="#Python字符串运算符" class="headerlink" title="Python字符串运算符"></a>Python字符串运算符</h4><p>下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”：</p><div class="table-container"><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">字符串连接</td><td style="text-align:left">a + b 输出结果： HelloPython</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">重复输出字符串</td><td style="text-align:left">a*2 输出结果：HelloHello</td></tr><tr><td style="text-align:left">[]</td><td style="text-align:left">通过索引获取字符串中字符</td><td style="text-align:left">a[1] 输出结果 <strong>e</strong></td></tr><tr><td style="text-align:left">[ : ]</td><td style="text-align:left">截取字符串中的一部分，遵循<strong>左闭右开</strong>原则，str[0:2] 是不包含第 3 个字符的。</td><td style="text-align:left">a[1:4] 输出结果 <strong>ell</strong></td></tr><tr><td style="text-align:left">in</td><td style="text-align:left">成员运算符 - 如果字符串中包含给定的字符返回 True</td><td style="text-align:left"><strong>‘H’ in a</strong> 输出结果 True</td></tr><tr><td style="text-align:left">not in</td><td style="text-align:left">成员运算符 - 如果字符串中不包含给定的字符返回 True</td><td style="text-align:left"><strong>‘M’ not in a</strong> 输出结果 True</td></tr><tr><td style="text-align:left">r/R</td><td style="text-align:left">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 <strong>r</strong>（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td><td style="text-align:left"><code>print( r'\n' ) print( R'\n' )</code></td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">格式字符串</td><td style="text-align:left">请看下一节内容。</td></tr></tbody></table></div><h4 id="Python字符串格式化"><a href="#Python字符串格式化" class="headerlink" title="Python字符串格式化"></a>Python字符串格式化</h4><div class="table-container"><table><thead><tr><th style="text-align:left">符  号</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">%c</td><td style="text-align:left">格式化字符及其ASCII码</td></tr><tr><td style="text-align:left">%s</td><td style="text-align:left">格式化字符串</td></tr><tr><td style="text-align:left">%d</td><td style="text-align:left">格式化整数</td></tr><tr><td style="text-align:left">%u</td><td style="text-align:left">格式化无符号整型</td></tr><tr><td style="text-align:left">%o</td><td style="text-align:left">格式化无符号八进制数</td></tr><tr><td style="text-align:left">%x</td><td style="text-align:left">格式化无符号十六进制数</td></tr><tr><td style="text-align:left">%X</td><td style="text-align:left">格式化无符号十六进制数（大写）</td></tr><tr><td style="text-align:left">%f</td><td style="text-align:left">格式化浮点数字，可指定小数点后的精度</td></tr><tr><td style="text-align:left">%e</td><td style="text-align:left">用科学计数法格式化浮点数</td></tr><tr><td style="text-align:left">%E</td><td style="text-align:left">作用同%e，用科学计数法格式化浮点数</td></tr><tr><td style="text-align:left">%g</td><td style="text-align:left">%f和%e的简写</td></tr><tr><td style="text-align:left">%G</td><td style="text-align:left">%f 和 %E 的简写</td></tr><tr><td style="text-align:left">%p</td><td style="text-align:left">用十六进制数格式化变量的地址</td></tr></tbody></table></div><p>格式化操作符辅助指令:</p><div class="table-container"><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">*</td><td style="text-align:left">定义宽度或者小数点精度</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">用做左对齐</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">在正数前面显示加号( + )</td></tr><tr><td style="text-align:left"><sp></sp></td><td style="text-align:left">在正数前面显示空格</td></tr><tr><td style="text-align:left">#</td><td style="text-align:left">在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">显示的数字前面填充’0’而不是默认的空格</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">‘%%’输出一个单一的’%’</td></tr><tr><td style="text-align:left">(var)</td><td style="text-align:left">映射变量(字典参数)</td></tr><tr><td style="text-align:left">m.n.</td><td style="text-align:left">m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td></tr></tbody></table></div><h4 id="Python三引号"><a href="#Python三引号" class="headerlink" title="Python三引号"></a>Python三引号</h4><ul><li>允许一个字符串跨多行</li></ul><h4 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h4><ul><li>python3.6 之后版本新增功能</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; name = 'Runoob'&gt;&gt;&gt; f'Hello {name}'  # 替换变量 'Hello Runoob'&gt;&gt;&gt; f'{1+2}'         # 使用表达式n'3'&gt;&gt;&gt; w = {'name': 'Runoob', 'url': 'www.runoob.com'}&gt;&gt;&gt; f'{w["name"]}: {w["url"]}'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在 Python 3.8 的版本中可以使用 <strong>=</strong> 符号来拼接运算表达式与结果</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; x = 1&gt;&gt;&gt; print(f'{x+1}')   # Python 3.62&gt;&gt;&gt; x = 1&gt;&gt;&gt; print(f'{x+1=}')   # Python 3.8'x+1=2'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Unicode-字符串"><a href="#Unicode-字符串" class="headerlink" title="Unicode 字符串"></a>Unicode 字符串</h4><p>在Python3中，所有的字符串都是Unicode字符串</p><h4 id="Python-的字符串内建函数"><a href="#Python-的字符串内建函数" class="headerlink" title="Python 的字符串内建函数"></a>Python 的字符串内建函数</h4><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-capitalize.html">capitalize()</a> 将字符串的第一个字符转换为大写</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-center.html">center(width, fillchar)</a> 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-count.html">count(str, beg= 0,end=len(string))</a> 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-decode.html">bytes.decode(encoding=”utf-8”, errors=”strict”)</a> Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-encode.html">encode(encoding=’UTF-8’,errors=’strict’)</a> 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-endswith.html">endswith(suffix, beg=0, end=len(string))</a> 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-expandtabs.html">expandtabs(tabsize=8)</a> 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-find.html">find(str, beg=0, end=len(string))</a> 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-index.html">index(str, beg=0, end=len(string))</a> 跟find()方法一样，只不过如果str不在字符串中会报一个异常。</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-isalnum.html">isalnum()</a> 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-isalpha.html">isalpha()</a> 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-isdigit.html">isdigit()</a> 如果字符串只包含数字则返回 True 否则返回 False..</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-islower.html">islower()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-isnumeric.html">isnumeric()</a> 如果字符串中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-isspace.html">isspace()</a> 如果字符串中只包含空白，则返回 True，否则返回 False.</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-istitle.html">istitle()</a> 如果字符串是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-isupper.html">isupper()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-join.html">join(seq)</a> 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td style="text-align:left">19</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-len.html">len(string)</a> 返回字符串长度</td></tr><tr><td style="text-align:left">20</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-ljust.html">ljust(width[, fillchar])</a> 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td></tr><tr><td style="text-align:left">21</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-lower.html">lower()</a> 转换字符串中所有大写字符为小写.</td></tr><tr><td style="text-align:left">22</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-lstrip.html">lstrip()</a> 截掉字符串左边的空格或指定字符。</td></tr><tr><td style="text-align:left">23</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-maketrans.html">maketrans()</a> 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td style="text-align:left">24</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-max.html">max(str)</a> 返回字符串 str 中最大的字母。</td></tr><tr><td style="text-align:left">25</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-min.html">min(str)</a> 返回字符串 str 中最小的字母。</td></tr><tr><td style="text-align:left">26</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-replace.html">replace(old, new [, max])</a> 把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td style="text-align:left">27</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-rfind.html">rfind(str, beg=0,end=len(string))</a> 类似于 find()函数，不过是从右边开始查找.</td></tr><tr><td style="text-align:left">28</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-rindex.html">rindex( str, beg=0, end=len(string))</a> 类似于 index()，不过是从右边开始.</td></tr><tr><td style="text-align:left">29</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-rjust.html">rjust(width,[, fillchar])</a> 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td></tr><tr><td style="text-align:left">30</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-rstrip.html">rstrip()</a> 删除字符串字符串末尾的空格.</td></tr><tr><td style="text-align:left">31</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-split.html">split(str=””, num=string.count(str))</a> 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</td></tr><tr><td style="text-align:left">32</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-splitlines.html">splitlines([keepends])</a> 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td style="text-align:left">33</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-startswith.html">startswith(substr, beg=0,end=len(string))</a> 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td></tr><tr><td style="text-align:left">34</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-strip.html">strip([chars])</a> 在字符串上执行 lstrip()和 rstrip()</td></tr><tr><td style="text-align:left">35</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-swapcase.html">swapcase()</a> 将字符串中大写转换为小写，小写转换为大写</td></tr><tr><td style="text-align:left">36</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-title.html">title()</a> 返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td style="text-align:left">37</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-translate.html">translate(table, deletechars=””)</a> 根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td></tr><tr><td style="text-align:left">38</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-upper.html">upper()</a> 转换字符串中的小写字母为大写</td></tr><tr><td style="text-align:left">39</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-zfill.html">zfill (width)</a> 返回长度为 width 的字符串，原字符串右对齐，前面填充0</td></tr><tr><td style="text-align:left">40</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-string-isdecimal.html">isdecimal()</a> 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr></tbody></table></div><h3 id="Python3-列表"><a href="#Python3-列表" class="headerlink" title="Python3 列表"></a>Python3 列表</h3><ul><li>列表都可以进行的操作包括索引，切片，加，乘，检查成员。</li></ul><h4 id="访问列表中的值"><a href="#访问列表中的值" class="headerlink" title="访问列表中的值"></a>访问列表中的值</h4><ul><li><p>列表索引从 <strong>0</strong> 开始，第二个索引是 <strong>1</strong>，依此类推</p></li><li><p>使用方括号 <strong>[]</strong> 的形式截取字符，左闭右开</p></li></ul><h4 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">list[2] = 2001list.append(100)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">del list[2]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Python列表脚本操作符"><a href="#Python列表脚本操作符" class="headerlink" title="Python列表脚本操作符"></a>Python列表脚本操作符</h4><div class="table-container"><table><thead><tr><th style="text-align:left">Python 表达式</th><th style="text-align:left">结果</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">len([1, 2, 3])</td><td style="text-align:left">3</td><td style="text-align:left">长度</td></tr><tr><td style="text-align:left">[1, 2, 3] + [4, 5, 6]</td><td style="text-align:left">[1, 2, 3, 4, 5, 6]</td><td style="text-align:left">组合</td></tr><tr><td style="text-align:left">[‘Hi!’] * 4</td><td style="text-align:left">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td><td style="text-align:left">重复</td></tr><tr><td style="text-align:left">3 in [1, 2, 3]</td><td style="text-align:left">True</td><td style="text-align:left">元素是否存在于列表中</td></tr><tr><td style="text-align:left">for x in [1, 2, 3]: print(x, end=” “)</td><td style="text-align:left">1 2 3</td><td style="text-align:left">迭代</td></tr></tbody></table></div><h4 id="Python列表截取与拼接"><a href="#Python列表截取与拼接" class="headerlink" title="Python列表截取与拼接"></a>Python列表截取与拼接</h4><div class="table-container"><table><thead><tr><th style="text-align:left">Python 表达式</th><th style="text-align:left">结果</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">L[2]</td><td style="text-align:left">‘Taobao’</td><td style="text-align:left">读取第三个元素</td></tr><tr><td style="text-align:left">L[-2]</td><td style="text-align:left">‘Runoob’</td><td style="text-align:left">从右侧开始读取倒数第二个元素: count from the right</td></tr><tr><td style="text-align:left">L[1:]</td><td style="text-align:left">[‘Runoob’, ‘Taobao’]</td><td style="text-align:left">输出从第二个元素开始后的所有元素</td></tr></tbody></table></div><h4 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h4><p>使用嵌套列表即在列表里创建其它列表</p><h4 id="Python列表函数-amp-方法"><a href="#Python列表函数-amp-方法" class="headerlink" title="Python列表函数&amp;方法"></a>Python列表函数&amp;方法</h4><p>Python包含以下函数:</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">函数</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-len.html">len(list)</a> 列表元素个数</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-max.html">max(list)</a> 返回列表元素最大值</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-min.html">min(list)</a> 返回列表元素最小值</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(seq)</a> 将元组转换为列表</td></tr></tbody></table></div><p>Python包含以下方法:</p><div class="table-container"><table><thead><tr><th style="text-align:left">号</th><th style="text-align:left">方法</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-pop.html">list.pop([index=-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-reverse.html">list.reverse()</a> 反向列表中元素</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-sort.html">list.sort( key=None, reverse=False)</a> 对原列表进行排序</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-clear.html">list.clear()</a> 清空列表</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-copy.html">list.copy()</a> 复制列表</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手册 </tag>
            
            <tag> 编辑中 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo个人博客搭建教程</title>
      <link href="/2021/02/24/shi-yong-gong-ju/hexo-da-jian-jiao-cheng/"/>
      <url>/2021/02/24/shi-yong-gong-ju/hexo-da-jian-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本教程为使用Mac搭建Hexo个人博客</p></blockquote><p><a href="https://hexo.io/docs/">Hexo官方安装部署文档</a></p><p><a href="https://hexo.io/zh-cn/docs/">Hexo官方中文安装部署文档</a></p><h4 id="1-下载安装Nodejs"><a href="#1-下载安装Nodejs" class="headerlink" title="1. 下载安装Nodejs"></a>1. 下载安装Nodejs</h4><p>在Nodejs官网，下载最新版Node.js，并安装至/usr/local/bin/node</p><p>安装npm至/usr/local/bin/npm</p><h4 id="2-启动iterm，安装cnpm，安装"><a href="#2-启动iterm，安装cnpm，安装" class="headerlink" title="2. 启动iterm，安装cnpm，安装"></a>2. 启动iterm，安装cnpm，安装</h4><p>进入Mac 命令行中，输入</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">node -v     # 查看node版本  查看nodenpm -v      # 查看npm版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装cnpm</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">npm install -g cnpm --registry=https://registry.npm.taobao.org    # 安装cnpmcnpm -v     # 查看cnpm版本版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h4><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">cnpm install -g hexo-cli    # 安装hexohexo -v                     # 查看hexo的版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-在本地创建博客目录"><a href="#4-在本地创建博客目录" class="headerlink" title="4. 在本地创建博客目录"></a>4. 在本地创建博客目录</h4><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">cd 【本地目录】 # 该目录用于存放未来全部的博客内容mkdir blogcd bloghexo init   # 初始化博客hexo s      # 启动hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 默认启动本地4000端口<br> <a href="http://localhost:4000">http://localhost:4000</a></p></blockquote><p>在blog目录下<br></p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">hexo n "我的第一篇博客"  # 创建博客hexo clean 清空缓存hexo g 自动创建静态文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><h4 id="5-创建github的repository"><a href="#5-创建github的repository" class="headerlink" title="5. 创建github的repository"></a>5. 创建github的repository</h4><p>进入github，创建与登录账号同名的repository</p><blockquote><p>xxx.github.io</p></blockquote><p>并生成token：【Token】<br><strong> Token极其私密，请牢记，勿分享！ </strong></p><h4 id="6-本地安装hexo-git插件"><a href="#6-本地安装hexo-git插件" class="headerlink" title="6. 本地安装hexo-git插件"></a>6. 本地安装hexo-git插件</h4><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">cnpm install --save hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在blog目录下，修改_config.yml文件</p><p>Deployment下，修改为以下内容</p><blockquote><p>deploy:<br>type: git<br>repo: <a href="https://github.com/xxx/xxx.github.io.git">https://github.com/xxx/xxx.github.io.git</a><br>branch: master<br>token: <em>*</em></p></blockquote><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">hexo d    # 部署Hexo服务到远端<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="7-访问在线博客"><a href="#7-访问在线博客" class="headerlink" title="7. 访问在线博客"></a>7. 访问在线博客</h4><blockquote><p>xxx.github.io</p></blockquote><h4 id="8-定制主题"><a href="#8-定制主题" class="headerlink" title="8. 定制主题"></a>8. 定制主题</h4><p>Hexo的主题有很多，如</p><blockquote><p>github.com/litten/hexo-theme-yilia<br>github.com/cendeal/hexo-theme-aomori<br>github.com/jangdelong/hexo-theme-xups<br>github.com/blinkfox/hexo-theme-matery</p></blockquote><p>将主题克隆至本地<br></p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">git clone http://github.com/litten/hexo-theme-yilia.git themes/yiliagit clone https://github.com/cendeal/hexo-theme-aomori.git themes/aomorigit clone https://github.com/jangdelong/hexo-theme-xups.git themes/xupsgit clone https://github.com/blinkfox/hexo-theme-matery.git themes/materyvim _config.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>将 theme: landscape 修改为 theme: <strong>yilia</strong>或<strong>aomori</strong><br>在本地编译，部署服务<br><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">hexo cleanhexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>或<br><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">hexo d -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h4 id="9-修复模板缺失问题"><a href="#9-修复模板缺失问题" class="headerlink" title="9. 修复模板缺失问题"></a>9. 修复模板缺失问题</h4><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">npm i hexo-generator-json-content --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改_config.yml，增加以下配置</p><pre class="line-numbers language-none"><code class="language-none">jsonContent:  meta: false  pages: false  posts:   title: true   date: true   path: true   text: false   raw: false   content: false   slug: false   updated: false   comments: false   link: false   permalink: false   excerpt: false   categories: false   tags: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="10-使用LaTeX"><a href="#10-使用LaTeX" class="headerlink" title="10. 使用LaTeX"></a>10. 使用LaTeX</h4><p>可参考 <a href="https://blog.csdn.net/weixin_44191286/article/details/102702479">Hexo博客中使用Latex</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 已完稿 </tag>
            
            <tag> 工具 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学课程笔记（2）</title>
      <link href="/2021/02/24/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-2/"/>
      <url>/2021/02/24/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Logical-逻辑"><a href="#Logical-逻辑" class="headerlink" title="Logical 逻辑"></a>Logical 逻辑</h2><h4 id="逻辑等价-Logical-Equivalence"><a href="#逻辑等价-Logical-Equivalence" class="headerlink" title="逻辑等价  Logical Equivalence"></a>逻辑等价  Logical Equivalence</h4><script type="math/tex; mode=display">\begin{align} \mbox{Excluded Middle} \qquad p\lor \lnot p & \equiv \top \\\mbox{Contradiction} \qquad p\wedge \lnot p & \equiv \bot \\\mbox{Idempotence} \qquad \quad p\lor p & \equiv p \\p \wedge p & \equiv p \\\mbox{Double Negation} \qquad \quad \lnot \lnot p & \equiv p \\\mbox{Identity} \qquad \quad p \lor \bot & \equiv p \\p \wedge \top & \equiv p \\p \lor \top & \equiv \top \\p \wedge \bot & \equiv \bot \\\mbox {Commutativity} \qquad \quad p \lor q & \equiv q \lor v \\p\land q & \equiv q \land p \\\mbox {Associativity}\qquad (p \lor q ) \lor r & \equiv p \lor (q \lor r ) \\(p \land q ) \land r & \equiv p \land ( q \land r ) \\\mbox {Distribution}\qquad p \lor (q \land r) & \equiv (p \lor q) \land ( p \lor r) \\p \land (q \lor r) & \equiv (p \land q)\lor (p \land r) \\\mbox {De Morgan's laws}\qquad \lnot (p \land q) & \equiv \lnot p \lor \lnot q \\\lnot (p \lor q) & \equiv \lnot p \land \lnot q \\\mbox {Implication} \qquad \qquad p \Rightarrow q & \equiv \lnot p \lor q \\p \Leftrightarrow q & \equiv  (p \Rightarrow q) \land (q \Rightarrow p)\end{align}</script><p><strong>例</strong></p><script type="math/tex; mode=display">\begin{array} ((r \land \lnot p ) \lor (r \land q)) \lor (( \lnot r \land \lnot p ) \lor (\lnot r \land q)) \\\qquad \equiv (r \land ( \lnot p \lor q )) \lor (\lnot r \land ( \lnot p \lor q )) \qquad \mbox {Distrib.} \\ \qquad \equiv (r \lor \lnot r) \land (\lnot p \lor q) \qquad \qquad \qquad \quad \mbox {Distrib.} \\ \qquad \equiv \top \land (\lnot p \lor q ) \qquad \qquad \qquad \qquad \quad \mbox {Excl. Mid.} \\ \qquad \equiv \lnot p \lor q \qquad \qquad \qquad \qquad \qquad \qquad \mbox {Ident.}\end{array}</script><script type="math/tex; mode=display">\color {Green} \checkmark p \Rightarrow ( q \Rightarrow r) \equiv ( p \Rightarrow q) \Rightarrow (p \Rightarrow r) \\\color {Red} \times (p \Rightarrow q ) \Rightarrow r \equiv p \Rightarrow (q \Rightarrow r )</script><div class="table-container"><table><thead><tr><th>p</th><th>q</th><th>r</th><th>$(p \Rightarrow q ) \Rightarrow r$</th><th style="text-align:left">$p \Rightarrow (q \Rightarrow r )$</th></tr></thead><tbody><tr><td>F</td><td>T</td><td>F</td><td>$ \color{Red}{\mbox{F}}$</td><td style="text-align:left">$ \color {Green} {\mbox{T}}$</td></tr></tbody></table></div><h3 id="公式的可满足性-Satisfifiability-of-Formulas"><a href="#公式的可满足性-Satisfifiability-of-Formulas" class="headerlink" title="公式的可满足性 Satisfifiability of Formulas"></a>公式的可满足性 Satisfifiability of Formulas</h3><p>如果在某种情况下，其值可为真值，则这个个公式是<strong>可满足的satisfiable</strong>。</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th><th>$ A \Rightarrow B $</th><th>$\lnot ( A \Rightarrow B )$</th></tr></thead><tbody><tr><td>F<br>F<br>T<br>T</td><td>F<br>T<br>F<br>T</td><td>$ \color{Green}{\mbox{T}}$<br>$ \color{Green}{\mbox{T}}$<br>$ \color{Red}{\mbox{F}}$<br>$ \color{Green}{\mbox{T}}$</td><td>$ \color{Red}{\mbox{F}}$<br>$ \color{Red}{\mbox{F}}$<br>$ \color{Green}{\mbox{T}}$<br>$ \color{Red}{\mbox{F}}$</td></tr></tbody></table></div><h5 id="例"><a href="#例" class="headerlink" title="例:"></a>例:</h5><p>若：</p><ul><li>$J \Rightarrow \lnot S$</li><li>$S \Rightarrow K$</li><li>$K \Rightarrow J$</li></ul><p>求$\phi = (J\Rightarrow \lnot S) \land (S\Rightarrow K) \land (K\Rightarrow J)$为真的情形。</p><p>解析真值表为：</p><div class="table-container"><table><thead><tr><th>J</th><th>K</th><th>S</th><th>$J\Rightarrow \lnot S$</th><th>$S \Rightarrow K$</th><th>$K \Rightarrow J$</th><th>$\phi$</th></tr></thead><tbody><tr><td>F<br>F<br>F<br>F<br>T<br>T<br>T<br>T</td><td>F<br>F<br>T<br>T<br>F<br>F<br>T<br>T</td><td>F<br>T<br>F<br>T<br>F<br>T<br>F<br>T</td><td><br><br><br><br><br>F<br><br>F</td><td><br>F<br><br><br><br>F<br><br></td><td><br><br>F<br>F<br><br><br><br></td><td>$ \color{Green}{\mbox{T}}$<br>$ \color{Red}{\mbox{F}}$<br>$ \color{Red}{\mbox{F}}$<br>$ \color{Red}{\mbox{F}}$<br>$ \color{Green}{\mbox{T}}$<br>$ \color{Red}{\mbox{F}}$<br>$ \color{Green}{\mbox{T}}$<br>$ \color{Red}{\mbox{F}}$</td></tr></tbody></table></div><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><p>下列哪个公式总为真？</p><p>(a) $(p \land (p \Rightarrow q)) \Rightarrow q \color{Green}{\checkmark}$</p><p>(b) $((p \lor q) \land \lnot p) \Rightarrow \lnot q\color{Red}{\times}$</p><p>(c) $((p\Rightarrow q) \lor (q \Rightarrow r)) \Rightarrow (p \Rightarrow r)\color{Red}{\times}$</p><p>(d) $(p \land q) \Rightarrow q\color{Green}{\checkmark}$</p><h3 id="有效性、蕴涵、参数-Validity-Entailment-Arguments"><a href="#有效性、蕴涵、参数-Validity-Entailment-Arguments" class="headerlink" title="有效性、蕴涵、参数 Validity, Entailment, Arguments"></a>有效性、蕴涵、参数 Validity, Entailment, Arguments</h3><p> <strong>前提permises</strong>：包含一些论点的陈述句</p><ul><li><p>结论从前提逻辑地推导出来</p></li><li><p>结论是前提的逻辑推论</p></li><li><p>前提<strong>蕴含entail</strong>结论</p></li></ul><p><strong>定义</strong>： $\phi_1,\dots,\phi_n \vDash \phi $</p><h3 id="公式的有效性-Validity-of-Formulas"><a href="#公式的有效性-Validity-of-Formulas" class="headerlink" title="公式的有效性 Validity of Formulas"></a>公式的有效性 Validity of Formulas</h3><p>如果公式$\phi$对其基本命题的所有真值赋值为T，那么它就是<strong>有效的valid</strong>，或者<strong>重言式tautology</strong>，记为$\vDash \phi$。</p><h3 id="Validity-Equivalence-and-Entailment-有效性，等价性和蕴含性"><a href="#Validity-Equivalence-and-Entailment-有效性，等价性和蕴含性" class="headerlink" title="Validity, Equivalence and Entailment 有效性，等价性和蕴含性"></a>Validity, Equivalence and Entailment 有效性，等价性和蕴含性</h3><h5 id="定理-Theorem"><a href="#定理-Theorem" class="headerlink" title="定理 Theorem"></a>定理 Theorem</h5><p>以下等价</p><ul><li><p>$\phi_1,\dots,\phi_n\vDash\psi$</p></li><li><p>$\vDash(\phi_1\land\dots\land\phi_n)\Rightarrow \psi$</p></li><li><p>$\vDash \phi_1 \Rightarrow (\phi_2\Rightarrow \dots (\phi_n \Rightarrow \psi )\dots)$</p></li><li><p>$\phi \equiv \psi \ \mbox{if and only if} \vDash \phi \Leftrightarrow \psi$</p></li></ul><h2 id="证明规则与方法-Proof-Roles-and-Methods"><a href="#证明规则与方法-Proof-Roles-and-Methods" class="headerlink" title="证明规则与方法 Proof Roles and Methods"></a>证明规则与方法 Proof Roles and Methods</h2><h3 id="按案例证明-Proof-Roles-and-Methods-Proof-by-Cases"><a href="#按案例证明-Proof-Roles-and-Methods-Proof-by-Cases" class="headerlink" title="按案例证明 Proof Roles and Methods: Proof by Cases"></a>按案例证明 Proof Roles and Methods: Proof by Cases</h3><p>为了证明A，我们有</p><ul><li><p>$B_1 \lor \dots \lor B_n$</p></li><li><p>$B_i \Rightarrow A \ \mbox{for each } i = 1 \dots n$</p></li></ul><p>$\forall$ 意思是“所有”</p><p>$ \exists$ 意思是“存在”</p><p><strong>哥德巴赫猜想 Goldbach’s conjecture</strong></p><p>$\forall n \in 2 \mathbb {N} ( n &gt; 2 \Rightarrow \exists p, q \in \mathbb {N} (p,q \in PRIMES \land n=p+1))$ </p><h5 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h5><p>下列哪项是同义重述?</p><p>$\forall x(\exists y( P(x,y))) \Rightarrow \exists y(\forall x (P(x,y)))\color {Red} \times$</p><p>$ \exists y(\forall x (P(x,y))) \Rightarrow \forall x(\exists y( P(x,y))) \color {Green} \checkmark$</p><h3 id="证明逆否命题-Proof-of-the-Contrapositive"><a href="#证明逆否命题-Proof-of-the-Contrapositive" class="headerlink" title="证明逆否命题 Proof of the Contrapositive"></a>证明逆否命题 Proof of the Contrapositive</h3><p>我们想证明 $ A \Rightarrow B$</p><p>为了证明这个表达式，我们转换为 $ \lnot B \Rightarrow \lnot A$ 然后使用用等价性 $(A \Rightarrow B) \equiv (\lnot B \Rightarrow \lnot A)$</p><p><strong>练习</strong></p><p>无理数的平方根是无理数：</p><p>$\forall x \in \mathbb {R}(x\notin \mathbb {Q} \Rightarrow \sqrt {x} \notin \mathbb {Q})$</p><p>为了证明这一点，我们可以证明：</p><p>$\sqrt x \in \mathbb {Q} \Rightarrow x \in \mathbb {Q}$</p><p>$\sqrt x = \frac {p}{q} \ $对于一些$p,q \in \mathbb {Z} $</p><p>$\Rightarrow x = \frac {p^2}{q^2}$</p><h3 id="反证法-Proof-by-Contradiction"><a href="#反证法-Proof-by-Contradiction" class="headerlink" title="反证法 Proof by Contradiction"></a>反证法 Proof by Contradiction</h3><p>我们想证明$A$。为了证明这一点，我们假设 $\lnot A$ ，并为某些命题$B$派生$B$和$\lnot B$。</p><p>（难点是：计算出$B$应该是多少。）</p><p><strong>例子</strong></p><ul><li><p>$\sqrt{2}$ 是无理数</p></li><li><p>存在无数个质数</p></li></ul><p>$\sqrt{2}=\frac{p}{q}$</p><p>$\Rightarrow 2q^2 = p^2$</p><p>$\Rightarrow p^2 \mbox{ 为偶数 } \Rightarrow p \mbox{ 为偶数 } \Rightarrow p=2\cdot r$</p><p>$\Rightarrow 2q^2 = 4 r^2$</p><p>$\Rightarrow q^2 = 2 r^2$</p><p>$\Rightarrow q^2 \mbox{ 为偶数 } \Rightarrow q \mbox{ 为偶数 }$</p><p>但是$p,q$一定互为质数，产生矛盾</p><h2 id="替换-substitution"><a href="#替换-substitution" class="headerlink" title="替换 substitution"></a>替换 substitution</h2><p>替换是用表达式替换每一个符号的过程。</p><p>我们可以用逻辑表达式代替逻辑变量。</p><h3 id="替换规则-Substitution-Rules"><a href="#替换规则-Substitution-Rules" class="headerlink" title="替换规则 Substitution Rules"></a>替换规则 Substitution Rules</h3><p>(a) 如果 $\vDash \phi(P)$ 那么 $\vDash \phi ( \alpha)$</p><p>(b) 如果 $\alpha \equiv \beta$ 那么 $\phi(\alpha) \equiv \phi(\beta)$</p><h2 id="布尔函数-Boolean-Functions"><a href="#布尔函数-Boolean-Functions" class="headerlink" title="布尔函数 Boolean Functions"></a>布尔函数 Boolean Functions</h2><p>只有一个变量的布尔函数也被称为 <strong>unary(一元的)</strong>.</p><p>有两个变量的函数被称为 <strong>binary(二元的)</strong>.</p><p>有<em>n</em>个输入变量的函数被称为 <strong>n-ary(n元的)</strong>.</p><h3 id="布尔运算-Boolean-Arithmetic"><a href="#布尔运算-Boolean-Arithmetic" class="headerlink" title="布尔运算 Boolean Arithmetic"></a>布尔运算 Boolean Arithmetic</h3><p>考虑带操作的真值 $\land \lor \lnot $ <strong>代数结构 algebraic structure</strong>：</p><p>$\mathbb{B}=\{0,1\}$ 的布尔运算：</p><p>$a\cdot b, a+b,a^\prime = 1-a$</p><ul><li>$pq$ 表示 $p \cdot q$</li><li>$\bar{p}$ 表示方法比 $p^\prime$ 更频繁</li><li>$\bar{(\cdot )}$ 省去了一些括号的需要</li></ul><h4 id="应用四-数字电路-Applications-IV-Digital-Circuits"><a href="#应用四-数字电路-Applications-IV-Digital-Circuits" class="headerlink" title="应用四:数字电路 Applications IV: Digital Circuits"></a>应用四:数字电路 Applications IV: Digital Circuits</h4><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210227170629.png" alt="image-20210227170629279"></p><h3 id="布尔代数的定义-Definition-Boolean-Algebra"><a href="#布尔代数的定义-Definition-Boolean-Algebra" class="headerlink" title="布尔代数的定义 Definition Boolean Algebra"></a>布尔代数的定义 Definition Boolean Algebra</h3><p><strong>commutative:</strong> $ x + y = y + x$</p><p>$ x \cdot y = y \cdot x$</p><p><strong>associative:</strong> $(x + y) + z = x + (y + z)$ </p><p>$(x \cdot y) \cdot z = x \cdot ( y\cdot z)$</p><p><strong>distributive:</strong> $x + (y\cdot z)=(x+y)\cdot (x+z)$</p><p>$x \cdot (y+x) = (x\cdot y) + (x \cdot z)$</p><p><strong>identity:</strong> $x + 0 = x, \ x \cdot 1 = x$</p><p><strong>complementation:</strong> $x + x^\prime = 1, \ x\cdot x^\prime =0$</p><p>2-bit vectors $\mathbb{B}^2$:</p><script type="math/tex; mode=display">0 \overset {def}{=}(0,0) \\1 \overset {def}{=}(1,1) \\\mbox{join: } (a_1,a_2)+(b_1,b_2) \mapsto (a_1 = b_1, a_2 + b_2) \\\mbox{join: } (a_1,a_2)\cdot(b_1,b_2) \mapsto (a_1 \cdot b_1, a_2 \cdot b_2) \\\mbox{complementation: } (a_1,a_2)^\prime \mapsto(a_1^\prime,a_2^\prime)</script><p>$T={(0,0),(0,1),(1,0),(1,1)}$</p><h4 id="布尔表达式-Boolean-Expressions"><a href="#布尔表达式-Boolean-Expressions" class="headerlink" title="布尔表达式 Boolean Expressions"></a>布尔表达式 Boolean Expressions</h4><div class="table-container"><table><thead><tr><th></th><th>PL</th><th>BA(Boolean algebra)</th></tr></thead><tbody><tr><td>原子命题 propositional atoms</td><td>$p,q,\dots$</td><td>$p,q,\dots$</td></tr><tr><td>结合 conjunction</td><td>$p\land q$</td><td>$p\cdot q$ or $pq$</td></tr><tr><td>析取 disjunction</td><td>$p\lor q$</td><td>$p + q$</td></tr><tr><td>否定 negation</td><td>$\lnot p$</td><td>$p^\prime$</td></tr></tbody></table></div><h3 id="术语和规则-Terminology-and-Rules"><a href="#术语和规则-Terminology-and-Rules" class="headerlink" title="术语和规则 Terminology and Rules"></a>术语和规则 Terminology and Rules</h3><ul><li><p>一个<strong>文字literal</strong>是一个表达式$p$或$p’$素数，其中$p$是一个命题原子</p></li><li><p>一个表达式为<strong>CNF（合取范式conjunctive normal form</strong>），如果它的形式为</p><script type="math/tex; mode=display">\prod_{i} C_i</script></li></ul><p>其中每个<strong>子句clause</strong> $C_i$是字面量的分离 如. $p+q+r^\prime$. </p><ul><li>如果一个表达式具有这种形式，那么它就是<strong>DNF（析取范式disjunctive normal form）</strong><script type="math/tex; mode=display">\sum_{i}C_i</script></li></ul><p>其中每个子句$C_i$是一个合取字面值 如$pqr^\prime$</p><ul><li><p>CNF和DNF以它们的顶级操作符命名；$\cdot$或$+$不允许更深的嵌套。</p></li><li><p>任何给定的变量在一个子句中只出现一次</p></li></ul><script type="math/tex; mode=display">x + x =x,\ xx=x \\xx^\prime = 0,\ x + x^\prime = 1 \\x \cdot 0 = 0,\ x \cdot 1 = x,\ x + 0 = x,\ x +1 =1</script><ul><li>DNF优先</li></ul><script type="math/tex; mode=display">\begin{array}xx + xy & = x \quad \mbox{(absorption)} \\xy + xy^\prime & = x \quad \mbox{(combining the opposites)}\end{array}</script><ul><li>每个布尔表达式$\phi$在CNF或DNF中有一个等价的表达式</li><li><strong>德摩根定律 De morgan’s laws</strong></li></ul><script type="math/tex; mode=display">(x+y)^\prime = x^\prime \cdot y^\prime \\(x \cdot y )^\prime = x^\prime + y^\prime \\(x^\prime)^\prime = x</script><h3 id="规范形式DNF-Canonical-Form-DNF"><a href="#规范形式DNF-Canonical-Form-DNF" class="headerlink" title="规范形式DNF Canonical Form DNF"></a>规范形式DNF Canonical Form DNF</h3><script type="math/tex; mode=display">\mathcal{l}=\begin{cases} X_i \quad if\ \pi(x_i)=1 \\x_i^\prime \quad if \ \pi(x_i)=0\end{cases} \\\mbox{product}\ t_\pi = \mathcal{l}_1\cdot\mathcal{l}_2\cdot \ \dots \ \cdot \mathcal{l}_n</script><p><strong>例</strong></p><p>如果 $\pi(x_1)=1 $ 且 $\pi(x_2)=0$ ，那么 $t_\pi=x_1\cdot x_2^\prime$</p><p>$E$的<strong>规范DNF</strong>是</p><script type="math/tex; mode=display">E^{dnf}=\sum_{E(\pi)=1}t_\pi</script><p><strong>例</strong></p><p>如果E是由此定义</p><div class="table-container"><table><thead><tr><th>x</th><th>y</th><th>E</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>那么 $E^{dnf} = {x}’{y}’+x{y}’+xy$</p><p>可以简化为  $x+{y}’$</p><h3 id="卡诺图-Karnaugh-Maps"><a href="#卡诺图-Karnaugh-Maps" class="headerlink" title="卡诺图 Karnaugh Maps"></a>卡诺图 Karnaugh Maps</h3><ul><li><p>矩形可以绕着角落移动，即实际的卡诺图应该被视为一个<em>环面</em>。</p></li><li><p>矩形的边必须是1、2或4个正方形(三个相邻的单元格是无用的)。</p></li></ul><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210227223730.png" alt="K Maps计算过程图" style="zoom: 33%;"></p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210228135344.jpg" alt="使用卡诺图计算CNF及DNF方法"></p><p><em>本图由freakyuito整理</em></p><h3 id="计算机科学中的布尔代数-Boolean-Algebras-in-Computer-Science"><a href="#计算机科学中的布尔代数-Boolean-Algebras-in-Computer-Science" class="headerlink" title="计算机科学中的布尔代数 Boolean Algebras in Computer Science"></a>计算机科学中的布尔代数 Boolean Algebras in Computer Science</h3><p> 一些数据结构有类似自然法则的运算符，如$\land \lor \lnot$</p><h4 id="只包含0和1的n元布尔运算规则："><a href="#只包含0和1的n元布尔运算规则：" class="headerlink" title="只包含0和1的n元布尔运算规则："></a>只包含0和1的n元布尔运算规则：</h4><p>加（join）：$(1,0,0,1) + (1,1,0,0) = (1,1,0,1)$</p><p>乘（meet）：$(1,0,0,1)\cdot (1,1,0,0) = (1,0,0,0)$</p><p>补集（complementation）：${(1,0,0,1)}’=(0,1,1,0)$</p><h4 id="Pow-S-——-S-的子集"><a href="#Pow-S-——-S-的子集" class="headerlink" title="$Pow(S)$ ——$S$的子集"></a>$Pow(S)$ ——$S$的子集</h4><p>加（join）：$A\cup B$  乘（meet）：$A \cap B$  补集（complement）：$A^C = S \setminus A$</p><p>对于S的布尔代数，$Pow(S)$，$s=\{a,b,c\}$，有：</p><p>$0 \overset{def}=\empty$</p><p>$1 \overset{def}=\{a,b,c\}$</p><p>加（join）：$X,Y \mapsto X \cup Y $</p><p>乘（meet）：$X,Y \mapsto X \cap Y$</p><p>补（complementation）：$X \mapsto \{a,b,c\} \setminus X$</p><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210304202204.png" alt="" style="zoom: 25%;"></p><h3 id="更多计算机科学中布尔代数的例子"><a href="#更多计算机科学中布尔代数的例子" class="headerlink" title="更多计算机科学中布尔代数的例子"></a>更多计算机科学中布尔代数的例子</h3><p>对于任意集合$S$到$\mathbb{B}$的函数，它们的集合记为$Map(S, \mathbb{B})$</p><p>如果$f,g: S \rightarrow \mathbb{B}$，那么：</p><p>$(f+g):S \rightarrow \mathbb(B) $定义为$s \mapsto f(s) + g(s)$</p><p>$(f\cdot g):S\rightarrow \mathbb{B}$定义为$s \mapsto f(s)\cdot g(s)$</p><p> $f’:S\rightarrow \mathbb{B}$定义为$s\mapsto {(f(s))}’$</p><p>对于$|S|=n$，一共有$2^n$个</p><p>对于所有n个变量的布尔函数，如$(p_1,p_2,p_3)\mapsto (p_1+p_2’)\cdot (p_1+p_3)\cdot p_2 + p_3’$</p><p>它们一共有$2^{2^n}$个，它们的集合表示为$BOOL(n)$</p><p><strong>事实上</strong>，每个具有有限元素集T的布尔代数满足: $|T|=2^k$</p><p><strong>定义</strong></p><p>考虑</p><ul><li><p>布尔代数$B_1$在集合$S$上有不同的元素$0_S$和$1_S$</p></li><li><p>布尔代数$B_2$在集合$T$上有不同的元素$0_T$和$1_T$</p></li></ul><p>它们是同构体（isomorphic），写作$B_1\simeq B_2$，当且仅当存在一一对应关系时，$\iota:S\mapsto T$，这样</p><p>$\iota(0_S)=0_T$</p><p>$\iota(1_S)=1_T$</p><p>$\iota(s_1+s_2)=\iota(S_1)+\iota(S_2)$  对于所有的$s_1,s_2\in S$</p><p>$\iota(s_1 \cdot s_2)=\iota(S_1)\cdot \iota(S_2)$ 对于所有的$s_1,s_2\in S$</p><p>$\iota(s’)=\iota(s)’$ 对于所有的$s\in S$</p><p><strong>事实上</strong>，所有元素数相同的代数都是同构的，即“结构上相似”。因此，研究一个这样的代数就可以描述所有的性质。</p><p>布尔代数的笛卡尔积也是布尔代数。写作：</p><script type="math/tex; mode=display">\mathbb{B}^k = \mathbb{B} \times \dots \mathbb{B}</script><p>上面提到的代数都是这种形式：</p><ul><li><p>$n元\simeq \mathbb{B}^n$</p></li><li><p>$Pow(S)\simeq \mathbb{B}^{|S|}$</p></li><li><p>$Map(S,\mathbb{B})\simeq \mathbb{B}^{|S|}$</p></li><li><p>$BOOL(n)\simeq \mathbb{B}^{2^n}$</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>$\equiv$等价</p><p>可满足的公式（satisfiable formulae），有效公式（valid formulae）、重复式（tautologies）</p><p>逻辑蕴涵$\vDash$</p><p>证明方法：反证法，证明逆否命题，按案例证明</p><p>布尔代数，CNF，DNF，规范形式，卡诺图（Karnaugh maps）</p><blockquote><p><strong>参考资料</strong></p><p>Textbook (R &amp; W) - Ch. 2, Sec. 2.2-2.5; Ch. 10. Sec. 10.1-10.5</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9020 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 离散数学 </tag>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX 符号命令大全</title>
      <link href="/2021/02/24/shi-yong-gong-ju/latex-fu-hao-ming-ling-da-quan/"/>
      <url>/2021/02/24/shi-yong-gong-ju/latex-fu-hao-ming-ling-da-quan/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>参考资料</strong></p><p><a href="http://blog.sina.com.cn/s/blog_bad174440102z1t7.html">http://blog.sina.com.cn/s/blog_bad174440102z1t7.html</a></p><p><a href="https://www.cnblogs.com/yalphait/articles/8685586.html">https://www.cnblogs.com/yalphait/articles/8685586.html</a></p><p>Latex大全<br><a href="https://blog.csdn.net/weixin_42468475/article/details/106015495">https://blog.csdn.net/weixin_42468475/article/details/106015495</a></p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/266267223?utm_source=wechat_session">编写Matrix矩阵方法</a></p><h2 id="函数、符号及特殊字符"><a href="#函数、符号及特殊字符" class="headerlink" title="函数、符号及特殊字符"></a>函数、符号及特殊字符</h2><h3 id="声调"><a href="#声调" class="headerlink" title="声调"></a>声调</h3><div class="table-container"><table><thead><tr><th>语法</th><th>效果</th><th>语法</th><th>效果</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>\bar{x}</td><td>$\bar{x}$</td><td>\acute{\eta}</td><td>$\acute{\eta}$</td><td>\check{\alpha}</td><td>$\check{\alpha}$</td></tr><tr><td>\grave{\eta}</td><td>$\grave{\eta}$</td><td>\breve{a}</td><td>$\breve{a}$</td><td>\ddot{y}</td><td>$\ddot{y}$</td></tr><tr><td>\dot{x}</td><td>$\dot{x}$</td><td>\hat{\alpha}</td><td>$\hat{\alpha}$</td><td>\tilde{\iota}</td><td>$\tilde{\iota}$</td></tr></tbody></table></div><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><div class="table-container"><table><thead><tr><th>语法</th><th>效果</th><th>语法</th><th>效果</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>\sin\theta</td><td>$\sin\theta$</td><td>\cos\theta</td><td>$\cos\theta$</td><td>$\tan\theta$</td><td>$\tan\theta$</td></tr><tr><td>\arcsin\frac{L}{r}</td><td>$\arcsin\frac{L}{r}$</td><td>\arccos\frac{T}{r}</td><td>$\arccos\frac{T}{r}$</td><td>$\arctan\frac{L}{T}$</td><td>$\arctan\frac{L}{T}$</td></tr><tr><td>\sinh g</td><td>$\sinh g$</td><td>\cosh h</td><td>$\cosh h$</td><td>$\tanh i$</td><td>\tanh i</td></tr><tr><td>\operatorname{sh}j</td><td>$\operatorname{sh}j$</td><td>\operatorname{argsh}k</td><td>$\operatorname{argsh}k$</td><td>\operatorname{ch}h</td><td>$\operatorname{ch}h$</td></tr><tr><td>\operatorname{argch}l</td><td>$\operatorname{argch}l$</td><td>\operatorname{th}i</td><td>$\operatorname{th}i$</td><td>\operatorname{argth}m</td><td>$\operatorname{argth}m$</td></tr><tr><td>k’(x)=\lim_{\Delta x\to 0}\frac{k(x)-k(x-\Delta x)}{\Deltax}</td><td>k’(x)=$m_{\Delta x\to 0}\frac{k(x)-k(x-\Delta x)}{\Deltax}$</td><td>\limsup S</td><td>$\limsup S$</td><td>\liminf I</td><td>$\liminf I$</td></tr><tr><td>\max H</td><td>$\max H$</td><td>\min L</td><td>$\min L$</td><td>\inf s</td><td>$\inf s$</td></tr><tr><td>\sup t</td><td>$\sup t$</td><td>\exp!t</td><td>$\exp!t$</td><td>\ln X</td><td>$\ln X$</td></tr><tr><td>\lg X</td><td>$\lg X$</td><td>\log X</td><td>$\log X$</td><td>\log_\alpha X</td><td>$\log_\alpha X$</td></tr><tr><td>\ker x</td><td>$\ker x$</td><td>\deg x</td><td>$\deg x$</td><td>\gcd(T,U,V,W,X)</td><td>$\gcd(T,U,V,W,X)$</td></tr><tr><td>\Pr x</td><td>$\Pr x$</td><td>\det x</td><td>$\det x$</td><td>\hom x</td><td>$\hom x$</td></tr><tr><td>\arg x</td><td>$\arg x$</td><td>\dim x</td><td>$\dim x$</td><td>\lim_{t\to n}T</td><td>$\lim_{t\to n}T$</td></tr></tbody></table></div><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><div class="table-container"><table><thead><tr><th>语法</th><th>效果</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>\pmod{m}</td><td>$\pmod{m}$</td><td>a \bmod b</td><td>$a \bmod b$</td></tr></tbody></table></div><h3 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h3><div class="table-container"><table><thead><tr><th>语法</th><th>效果</th><th>语法</th><th>效果</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>\nabla</td><td>$\nabla$</td><td>\partial x</td><td>$\partial x$</td><td>\mathrm{d}x</td><td>$\mathrm{d}x$</td></tr><tr><td>\dot x</td><td>$\dot x$</td><td>\ddot y</td><td>$\ddot y$</td><td></td></tr></tbody></table></div><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><div class="table-container"><table><thead><tr><th>语法</th><th>效果</th><th>语法</th><th>效果</th><th>语法</th><th>效果</th><th>语法</th><th>效果</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>\forall</td><td>$\forall$</td><td>\exists</td><td>$\exists$</td><td>\empty</td><td>$\empty$</td><td>\emptyset</td><td>$\emptyset$</td><td>\varnothing</td><td>$\varnothing$</td></tr><tr><td>\in</td><td>$\in$</td><td>\ni</td><td>$\ni$</td><td>\not\in</td><td>$\not\in$</td><td>\notin</td><td>$\notin$</td><td>\subset</td><td>$\subset$</td></tr><tr><td>\subseteq</td><td>$\subseteq$</td><td>\supset</td><td>$\supset$</td><td>\supseteq</td><td>$\supseteq$</td><td>\cap</td><td>$\cap$</td><td>\bigcap</td><td>$\bigcap$</td></tr><tr><td>\cup</td><td>$\cup$</td><td>\bigcup</td><td>$\bigcup$</td><td>\biguplus</td><td>$\biguplus$</td><td>\sqsubset</td><td>$\sqsubset$</td><td>\sqsubseteq</td><td>$\sqsubseteq$</td></tr><tr><td>\sqsupset</td><td>$\sqsupset$</td><td>\sqsupseteq</td><td>$\sqsupseteq$</td><td>\sqcap</td><td>$\sqcap$</td><td>\sqcup</td><td>$\sqcup$</td><td>\bigsqcup</td><td>$\bigsqcup$</td></tr></tbody></table></div><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><div class="table-container"><table><thead><tr><th>语法</th><th>效果</th><th>语法</th><th>效果</th><th>语法</th><th>效果</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>p</td><td>$P$</td><td>\land</td><td>$\land$</td><td>\wedge</td><td>$\wedge$</td><td>\bigwedge</td><td>$\bigwedge$</td></tr><tr><td>\bar{q} \to p</td><td>$\bar{q} \to p$</td><td>\lor</td><td>$\lor$</td><td>\vee</td><td>$\vee$</td><td>\bigvee</td><td>$\bigvee$</td></tr><tr><td>\lnot</td><td>$\lnot$</td><td>\neg q</td><td>$\neg q$</td><td>\setminus</td><td>$\setminus$</td><td>\smallsetminus</td><td>$\smallsetminus$</td></tr></tbody></table></div><h3 id="根号"><a href="#根号" class="headerlink" title="根号"></a>根号</h3><div class="table-container"><table><thead><tr><th>语法</th><th>效果</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>\sqrt{3}</td><td>$\sqrt{3}$</td><td>\sqrt[n]{3}</td><td>$\sqrt[n]{3}$</td></tr></tbody></table></div><h3 id="关系符号"><a href="#关系符号" class="headerlink" title="关系符号"></a>关系符号</h3><div class="table-container"><table><thead><tr><th>语法</th><th>效果</th></tr></thead><tbody><tr><td><code>\Delta ABC\sim\Delta XYZ</code></td><td>$1 $</td></tr><tr><td><code>\sqrt{3}\approx1.732050808\ldots</code></td><td>$1$</td></tr><tr><td>\simeq</td><td>$\simeq$</td></tr><tr><td>\cong</td><td>$\cong$</td></tr><tr><td>\dot=</td><td>$\dot=$</td></tr><tr><td><code>\ggg</code></td><td>$1$</td></tr><tr><td><code>\gg</code></td><td>$1$</td></tr><tr><td><code>&gt;</code></td><td>$1$</td></tr><tr><td><code>\ge</code></td><td>$1$</td></tr><tr><td><code>\geqq</code></td><td>$1$</td></tr><tr><td><code>=</code></td><td>$1$</td></tr><tr><td><code>\leq</code></td><td>$1$</td></tr><tr><td><code>\leqq</code></td><td>$1$</td></tr><tr><td><code>&lt;</code></td><td>$1$</td></tr><tr><td><code>\ll</code></td><td>$1$</td></tr><tr><td><code>\lll</code></td><td>$1$</td></tr><tr><td><code>(x-y)^2\equiv(-x+y)^2\equiv x^2-2xy+y^2</code></td><td>$1$</td></tr><tr><td><code>\begin{align}``\because\begin{cases}``\acute{a}x^2+bx^2+c\gtrless0\gtrless\grave{a}x^2+bx^2+c\\``\acute{a}&gt;0&gt;\grave{a}``\end{cases}\\``\therefore\frac{-b\pm\sqrt{b^2-4\acute{a}c}}{2\acute{a}}{}_\lessgtr^\gtrlessx_\lessgtr^\gtrless\frac{-b\pm\sqrt{b^2-4\grave{a}c}}{2\grave{a}}``\end{align}</code></td><td>$1$</td></tr><tr><td>x\not\equiv N</td><td>$x\not\equiv N$</td></tr><tr><td>x\ne A</td><td>$x\ne A$</td></tr><tr><td>x\neq C</td><td>$x\neq C$</td></tr><tr><td>t\propto v</td><td>$t\propto v$</td></tr><tr><td>\pm</td><td>$\pm$</td></tr><tr><td>\mp</td><td>$\mp$</td></tr></tbody></table></div><h3 id="几何符号"><a href="#几何符号" class="headerlink" title="几何符号"></a>几何符号</h3><div class="table-container"><table><thead><tr><th>特征</th><th>语法</th><th>效果</th><th></th></tr></thead><tbody><tr><td>菱形</td><td>\Diamond</td><td>$\Diamond$</td><td></td></tr><tr><td>正方形</td><td>\Box</td><td>$\Box$</td><td></td></tr><tr><td>三角形 Delta</td><td><code>\Delta</code></td><td>$\Delta$</td><td></td></tr><tr><td>三角形 图型</td><td><code>\triangle</code></td><td>$\triangle$</td><td></td></tr><tr><td>角名</td><td><code>\angle\Alpha\Beta\Gamma</code></td><td>$\angle\Alpha\Beta\Gamma$</td><td></td></tr><tr><td>角度</td><td><code>\sin\!\frac{\pi}{3}=\sin60^\operatorname{\omicron}=\frac{\sqrt{3}}{2}</code></td><td>$\sin!\frac{\pi}{3}=\sin60^{\operatorname{\omicron}}=\frac{\sqrt{3}}{2}$</td><td></td></tr><tr><td>垂直</td><td>\perp</td><td>$\perp$</td></tr></tbody></table></div><h3 id="箭头符号"><a href="#箭头符号" class="headerlink" title="箭头符号"></a>箭头符号</h3><div class="table-container"><table><thead><tr><th>语法</th><th>效果</th><th>语法</th><th>效果</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>\leftarrow</td><td>$\leftarrow$</td><td>\gets</td><td>$\gets$</td><td>\rightarrow</td><td>$\rightarrow$</td></tr><tr><td>\to</td><td>$\to$</td><td>\leftrightarrow</td><td>$\leftrightarrow$</td><td>\longleftarrow</td><td>$\longleftarrow$</td></tr><tr><td>\longrightarrow</td><td>$\longrightarrow$</td><td>\mapsto</td><td>$\mapsto$</td><td>\longmapsto</td><td>$\longmapsto$</td></tr><tr><td>\hookrightarrow</td><td>$\hookrightarrow$</td><td>\hookleftarrow</td><td>$\hookleftarrow$</td><td>\nearrow</td><td>$\nearrow$</td></tr><tr><td>\searrow</td><td>$\searrow$</td><td>\swarrow</td><td>$\swarrow$</td><td>\nwarrow</td><td>$\nwarrow$</td></tr><tr><td>\uparrow</td><td>$\uparrow $</td><td>\downarrow</td><td>$\downarrow$</td><td>\updownarrow</td><td>$\updownarrow$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>语法</th><th>效果</th><th>语法</th><th>效果</th><th>语法</th><th>效果</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>\rightharpoonup</td><td>$\rightharpoonup $</td><td>\rightharpoondown</td><td>$\rightharpoondown$</td><td>\leftharpoonup</td><td>$\leftharpoonup$</td><td>\leftharpoondown</td><td>$\leftharpoondown$</td></tr><tr><td>\upharpoonleft</td><td>$\upharpoonleft$</td><td>\upharpoonright</td><td>$\upharpoonright$</td><td>\downharpoonleft</td><td>$\downharpoonleft$</td><td>\downharpoonright</td><td>$\downharpoonright$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>语法</th><th>效果</th><th>语法</th><th>效果</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>\Leftarrow</td><td>$\Leftarrow$</td><td>\Rightarrow</td><td>$\Rightarrow$</td><td>\Leftrightarrow</td><td>$\Leftrightarrow$</td></tr><tr><td>\Longleftarrow</td><td>$\Longleftarrow$</td><td>\Longrightarrow</td><td>$\Longrightarrow$</td><td>\Longleftrightarrow (or \iff)</td><td>$\Longleftrightarrow (or \iff)$</td></tr><tr><td>\Uparrow</td><td>$\Uparrow$</td><td>\Downarrow</td><td>$\Downarrow$</td><td>\Updownarrow</td><td>$\Updownarrow$</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持续更新 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客配置及图片引用方法</title>
      <link href="/2021/02/24/shi-yong-gong-ju/bo-ke-pei-zhi-ji-tu-pian-yin-yong-fang-fa/"/>
      <url>/2021/02/24/shi-yong-gong-ju/bo-ke-pei-zhi-ji-tu-pian-yin-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p>content</p><footer><strong>[author[</strong><cite>source]] [link] [source_link_title]</cite></footer></blockquote><h5 id="普通的-blockquote"><a href="#普通的-blockquote" class="headerlink" title="普通的 blockquote"></a>普通的 blockquote</h5><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p></blockquote><h5 id="引用书上的句子"><a href="#引用书上的句子" class="headerlink" title="引用书上的句子"></a>引用书上的句子</h5><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><h5 id="引用-Twitter"><a href="#引用-Twitter" class="headerlink" title="引用 Twitter"></a>引用 Twitter</h5><blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><h5 id="引用网络上的文章"><a href="#引用网络上的文章" class="headerlink" title="引用网络上的文章"></a>引用网络上的文章</h5><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></cite></footer></blockquote><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><pre class="line-numbers language-none"><code class="language-none">{% codeblock [title] [lang:language] [url] [link text] [additional options] %}code snippet{% endcodeblock %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="普通的代码块"><a href="#普通的代码块" class="headerlink" title="普通的代码块"></a>普通的代码块</h5><pre class="line-numbers language-none"><code class="language-none">alert("Hello World!");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="指定语言"><a href="#指定语言" class="headerlink" title="指定语言"></a>指定语言</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">print("This is my python code!")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h5><pre class="line-numbers language-none"><div class="caption"><span>Array.map</span></div><code class="language-none">array.map(callback[, thisArg])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="附加说明和网址"><a href="#附加说明和网址" class="headerlink" title="附加说明和网址"></a>附加说明和网址</h5><pre class="line-numbers language-none"><div class="caption"><span>_.compact</span><a href="http://underscorejs.org/#compact">Underscore.js</a></div><code class="language-none">_.compact([0, 1, false, 2, '', 3]);=&gt; [1, 2, 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">println("This is my Java code!");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h4><p><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">matery-github</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 已完稿 </tag>
            
            <tag> Hexo </tag>
            
            <tag> 工具 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学课程笔记（1）</title>
      <link href="/2021/02/20/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-1/"/>
      <url>/2021/02/20/unsw/comp9020/chi-san-shu-xue-ke-cheng-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h2 id="数字符号-Notation-for-Numbers"><a href="#数字符号-Notation-for-Numbers" class="headerlink" title="数字符号 Notation for Numbers"></a>数字符号 Notation for Numbers</h2><p><strong>定义：</strong></p><p>整数Integers $\mathbb{Z}=\{\dots, -2,-1,0,1,2\}$</p><p>实数Reals $\mathbb{R}$</p><p>$\lfloor.\rfloor:\mathbb{R}\rightarrow\mathbb{Z}$  x的底，最大整数$\leq x$</p><p>$\lceil.\rceil:\mathbb{R}\rightarrow\mathbb{Z}$ x的天花板，最小整数$\geq x$</p><p><strong>例如：</strong></p><p>$\lfloor \pi \rfloor = 3 = \lfloor e \rfloor\quad \pi,e\in \mathbb{R}; \lfloor \pi \rfloor , \lfloor e \rfloor \in \mathbb{Z}$</p><p>一些特性：</p><p>$\lfloor -x \rfloor = -\lceil x \rceil$，因此$\lceil x \rceil = - \lfloor -x \rfloor$</p><p>$\lfloor -x + t \rfloor = \lfloor x \rfloor + t$，且$\lceil x + t \rceil = \lceil x \rceil + t$ ，对于所有的$t\in \mathbb{Z}$</p><p>如果$k&gt;0$且$m\leq n$，那么$k$在$[m,n]$中的次数为：</p><script type="math/tex; mode=display">\lfloor \frac{n}{k} \rfloor - \lfloor \frac{m-1}{k} \rfloor</script><p>对任意非整数$n$，有：$\lceil n \rceil - \lfloor n \rfloor = 1$</p><h3 id="可除性-Divisibility"><a href="#可除性-Divisibility" class="headerlink" title="可除性 Divisibility"></a>可除性 Divisibility</h3><p><strong>定义：</strong></p><p>令$m,n \in \mathbb{Z}$，则$m|n$表示$m$是$n$的一个<strong>除数divisor</strong>，定义为$n=k\cdot m$，其中$k\in \mathbb{Z}$。也可以表述为$n$可被$m$整除，$n$是$m$的倍数等。</p><p>$m\not | n$，即$m|n$的否定式</p><p>整除的概念适用于所有整数（正整数、负整数、零）</p><p>对于$m$，有$1|m，-1|m，m|m，m|-m$</p><p>对任意$n$，有$n|0$；除$n=0$以外，$0\not | n$</p><p><strong>定义：</strong></p><p>$r=n \mod m$</p><p>当$n$除以$m$时，$r$为<strong>余数remainder</strong>。对$0 \leq r &lt; m$，定义为$n=k\cdot m + r$</p><p>当且仅当$m|n$时，$n \mod m=0$</p><p>当一个数大于1，且只能被1和它自身整除时，这个数被称为<strong>质数prime</strong></p><p><strong>最大公约数Greatest common divisor</strong> $gcd(m, n)$</p><p>当$gcd(m,n)=1$时，称为$m$和$n$<strong>互质relatively prime</strong></p><p>$gcd(0,n)=|n|$</p><p><strong>最小公倍数Least common multiple</strong>  $lcm(m,n)$</p><p>注：即使$m$或$n$是负数，$gcd(m, n)$ 和 $lcm(m,n)$总是取正数</p><h3 id="绝对值-Absolute-Value"><a href="#绝对值-Absolute-Value" class="headerlink" title="绝对值 Absolute Value"></a>绝对值 Absolute Value</h3><script type="math/tex; mode=display">|x| = \begin{cases}x & x \geq 0 \\-x & x<0\end{cases}</script><p>事实上，$gcd(m,n)\cdot lcm(m,n)=|m|\cdot|n|$</p><p>若$lcm(m,n)=n$，那么$m$一定是$n$的除数</p><h3 id="欧几里得的gcd算法-Euclid’s-gcd-Algorithm"><a href="#欧几里得的gcd算法-Euclid’s-gcd-Algorithm" class="headerlink" title="欧几里得的gcd算法 Euclid’s gcd Algorithm"></a>欧几里得的gcd算法 Euclid’s gcd <strong>Algorithm</strong></h3><script type="math/tex; mode=display">gcd(m,n)= \begin{cases}m & m=n \\gcd(m-n,n) & m > n \\gcd(m,n-m) & m < n\end{cases}</script><p>另一种算法</p><script type="math/tex; mode=display">gcd(m,n)= \begin{cases}m & n=0 \\gcd(n,m \mod n) & n > 0\end{cases}</script><h2 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合 Sets"></a>集合 Sets</h2><p>集合由其元素的集合定义。</p><p>$x\in S$ 表示x是集合S中的一个元素</p><h3 id="子集-Subsets"><a href="#子集-Subsets" class="headerlink" title="子集 Subsets"></a>子集 Subsets</h3><p>$S\subseteq T$，表示S是T的子集。</p><p>$S\subset T$，表示S是T的真子集。</p><p>空集{}，记作$\emptyset$</p><h3 id="基数，幂集-Cardinality-Powerset"><a href="#基数，幂集-Cardinality-Powerset" class="headerlink" title="基数，幂集 Cardinality, Powerset"></a>基数，幂集 Cardinality, Powerset</h3><p>基数$|X|=#(X)=card(X)$</p><p>$|A\cup B | = |A| + |B| - |A \cap B|$</p><p>$|A\cup B| + |A\cap B| = |A| + |B|$</p><p>$|A\setminus B| = |A| - |A \cap B|$</p><p>$|A \oplus B| = |A| + |B| - 2|A\cup B|$</p><p>幂集$Pow(X)=\{A:A\subseteq X\}$</p><p>$|Pow(X)|=2^{|X|}$</p><p>一般地，以下表达式成立：</p><p>$|B| &lt; | Pow(B)| \\ A \cap B \in Pow(B)$</p><p>注意，一般以下表达式不成立：</p><p> $A \subseteq Pow(A)$</p><h3 id="数的集合-Sets-of-Numbers"><a href="#数的集合-Sets-of-Numbers" class="headerlink" title="数的集合 Sets of Numbers"></a>数的集合 Sets of Numbers</h3><p>$\mathbb{P}\subset \mathbb{N}\subset \mathbb{Z} \subset \mathbb{Q}\subset \mathbb{R}$</p><h3 id="间隔-Intervals"><a href="#间隔-Intervals" class="headerlink" title="间隔 Intervals"></a>间隔 Intervals</h3><p>[a,b] (a,b) [a,b) (a,b]</p><p>$|[m,n]|=n-m+1$</p><h3 id="集合操作符-Set-Operations"><a href="#集合操作符-Set-Operations" class="headerlink" title="集合操作符 Set Operations"></a>集合操作符 Set Operations</h3><p>并集Union $A\cup B$</p><p>交集Intersection $A\cap B$</p><p>如果$A∩B =∅$，那么$A, B$是<strong>不相交disjoint</strong></p><p>差集difference $A\setminus B$</p><p>对称差symmetric difference $A\oplus B \overset{def}{=} (A\setminus B)\cup (B \setminus A)$</p><p>$A\oplus A = \emptyset$，$A\oplus \emptyset = A$</p><p>补集complement $A^C$</p><h3 id="文氏图"><a href="#文氏图" class="headerlink" title="文氏图"></a>文氏图</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210426003001.png" alt="文氏图"></p><h3 id="集合操作符运算规则"><a href="#集合操作符运算规则" class="headerlink" title="集合操作符运算规则"></a>集合操作符运算规则</h3><p><img src="https://gitee.com/szdf123/hexoblog/raw/master/img/20210426003156.png" alt="集合操作符运算规则"></p><h3 id="笛卡儿积-Cartesian-Product"><a href="#笛卡儿积-Cartesian-Product" class="headerlink" title="笛卡儿积 Cartesian Product"></a>笛卡儿积 Cartesian Product</h3><p>$S \times T$，$S^2=S \times S$，$S^3 = S \times S \times S$</p><p>$\emptyset\times S = \emptyset$</p><p>$|S \times T|=|S|\cdot |T|$</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>$S \mapsto T$的映射$f$</p><p>$f(x) = y$</p><h2 id="标准语言"><a href="#标准语言" class="headerlink" title="标准语言"></a>标准语言</h2><p>$\Sigma$ 字母表，有限非空集</p><p><strong>单词word</strong> 从$\Sigma$生成的任意有限字符串符号</p><p><strong>空单词empty word</strong> $\lambda$</p><p>$λω = ω = ωλ$</p><p>length($νω$) = length($ν$) + length($ω$)</p><p>$\Sigma^k$长度为k的单词集合</p><p>$\Sigma ^0=\{\lambda\}\quad \Sigma ^1=\{\Sigma\}$</p><p>$\Sigma^*$ 所有单词</p><p>$\Sigma ^+$非空单词</p><h2 id="基本逻辑-Elementary-Logic"><a href="#基本逻辑-Elementary-Logic" class="headerlink" title="基本逻辑 Elementary Logic"></a>基本逻辑 Elementary Logic</h2><p><strong>命题proposition</strong></p><p><strong>命题逻辑 Propositional Logic</strong></p><p>$\land$ 和，且，并，与</p><p>$\lor$或，或者</p><p>$\lnot$非 </p><h3 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h3><div class="table-container"><table><thead><tr><th>A</th><th>B</th><th>$A\land B$</th><th>$A\lor B$</th><th>$\lnot$ A</th><th>$A\Rightarrow B$</th><th>$A\Leftrightarrow B$</th></tr></thead><tbody><tr><td>F</td><td>F</td><td>F</td><td>F</td><td>T</td><td>T</td><td>T</td></tr><tr><td>F</td><td>T</td><td>F</td><td>T</td><td>T</td><td>T</td><td>F</td></tr><tr><td>T</td><td>F</td><td>F</td><td>T</td><td>F</td><td>F</td><td>F</td></tr><tr><td>T</td><td>T</td><td>T</td><td>T</td><td>F</td><td>T</td><td>T</td></tr></tbody></table></div><p><strong>命题逻辑公式 formulae of propositional logic</strong> </p><p>一般情况下，$(A\backslash B )\backslash C\neq A\backslash(B\backslash C)$，当 $A \cap C = \emptyset$时等式成立</p><h2 id="Week-1-小结"><a href="#Week-1-小结" class="headerlink" title="Week 1 小结"></a>Week 1 小结</h2><h5 id="数字符号-notation-for-numbers"><a href="#数字符号-notation-for-numbers" class="headerlink" title="数字符号 notation for numbers"></a>数字符号 notation for numbers</h5><p>$\lfloor m \rfloor , \lceil m \rceil , m | n , n\mod m, |a|, [a, b], (a,b),gcd,lcn$</p><h5 id="集合操作符-Sets-and-set-operations"><a href="#集合操作符-Sets-and-set-operations" class="headerlink" title="集合操作符 Sets and set operations"></a>集合操作符 Sets and set operations</h5><p> $|A|,\in , \cup , \cap , \setminus , \oplus , A^c , Pow(A) , \subseteq , \subset , \times$</p><h5 id="正式语言-字母和文字-Formal-languages-alphabets-and-words"><a href="#正式语言-字母和文字-Formal-languages-alphabets-and-words" class="headerlink" title="正式语言:字母和文字 Formal languages: alphabets and words"></a>正式语言:字母和文字 Formal languages: alphabets and words</h5><p>$\lambda , \sum ^*, \sum ^+, \sum ^1, \sum ^2, \dots ,\sum ^{\leq k}$</p><h5 id="命题逻辑的语言-Language-of-propositional-logic"><a href="#命题逻辑的语言-Language-of-propositional-logic" class="headerlink" title="命题逻辑的语言 Language of propositional logic"></a>命题逻辑的语言 Language of propositional logic</h5><p>$\land , \lor , \lnot , \Rightarrow , \Leftrightarrow , \top , \bot , \mbox {truth tables}$</p><blockquote><p><strong>参考资料</strong></p><p>Textbook (R &amp; W) - Ch. 1, Sec. 1.1-1.4; Ch. 2. Sec. 2.1</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> UNSW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> COMP9020 </tag>
            
            <tag> 已完稿 </tag>
            
            <tag> 离散数学 </tag>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
